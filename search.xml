<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/20/hello-world/"/>
      <url>/2022/08/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Stream流使用方法</title>
      <link href="/2022/03/12/Stream/"/>
      <url>/2022/03/12/Stream/</url>
      
        <content type="html"><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ol><li>提高代码可读性</li><li>大数据量效率高</li></ol><h3 id="1-1函数式编程思想"><a href="#1-1函数式编程思想" class="headerlink" title="1.1函数式编程思想"></a>1.1函数式编程思想</h3><h4 id="1-1-1概念"><a href="#1-1-1概念" class="headerlink" title="1.1.1概念"></a>1.1.1概念</h4><blockquote><p>函数式编程关注对数据进行什么操作</p><p>面向对象关注用什么对象完成什么事</p></blockquote><h4 id="1-1-2优点"><a href="#1-1-2优点" class="headerlink" title="1.1.2优点"></a>1.1.2优点</h4><blockquote><ol><li>简洁</li><li>易理解</li><li>易于“并发编程”</li></ol></blockquote><h2 id="2-Lambda表达式"><a href="#2-Lambda表达式" class="headerlink" title="2. Lambda表达式"></a>2. Lambda表达式</h2><h3 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h3><blockquote><p>jdk8认可的一种语法，对匿名内部类的写法进行简化。是函数式编程的一个重要体现。</p></blockquote><h3 id="2-2-核心原则"><a href="#2-2-核心原则" class="headerlink" title="2.2 核心原则"></a>2.2 核心原则</h3><blockquote><p>可推导时可省略</p><p>方法名可推导方法名可省略</p><p>参数名可推导参数名可省略</p></blockquote><h3 id="2-3-基本格式"><a href="#2-3-基本格式" class="headerlink" title="2. 3 基本格式"></a>2. 3 基本格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数列表)-&gt;&#123;代码&#125;</span><br></pre></td></tr></table></figure><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>我们在创建线程并启动时可以使用匿名内部类的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>可以使用Lambda的格式对其进行修改。修改后如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h3 id="2-4-省略规则"><a href="#2-4-省略规则" class="headerlink" title="2.4 省略规则"></a>2.4 省略规则</h3><ul><li>参数类型可以省略</li><li>方法体只有一句代码时大括号return和唯一一句代码的分号可以省略</li><li>方法只有一个参数时小括号可以省略</li><li>以上这些规则都记不住也可以省略不记</li></ul><h2 id="3-Stream流"><a href="#3-Stream流" class="headerlink" title="3.Stream流"></a>3.Stream流</h2><h3 id="3-1概述"><a href="#3-1概述" class="headerlink" title="3.1概述"></a>3.1概述</h3><blockquote><p>java8的Stream使用的是函数式编程模式，可以对集合或数组进行链状流式操作。方便我们对集合和数组操作。</p></blockquote><h3 id="3-2入门"><a href="#3-2入门" class="headerlink" title="3.2入门"></a>3.2入门</h3><h4 id="3-2-1创建流"><a href="#3-2-1创建流" class="headerlink" title="3.2.1创建流"></a>3.2.1创建流</h4><blockquote><p><strong>collection</strong>：集合对象.stream();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">Stream</span> <span class="variable">stream</span> <span class="operator">=</span> list.stream;</span><br></pre></td></tr></table></figure><p><strong>数组</strong>：Arrays.stream(“数组”)或者Stream.of</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stream.of()</span></span><br><span class="line"> Integer[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"> Stream&lt;Integer&gt; array1 = Stream.of(array);</span><br><span class="line"> <span class="comment">//Arrays.stream()</span></span><br><span class="line"> Stream&lt;Integer&gt; stream = Arrays.stream(array);</span><br></pre></td></tr></table></figure><p><strong>map</strong>：先转成Collection再.stream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;蜡笔小新&quot;</span>,<span class="number">19</span>);</span><br><span class="line">map.put(<span class="string">&quot;黑子&quot;</span>,<span class="number">17</span>);</span><br><span class="line">map.put(<span class="string">&quot;日向翔阳&quot;</span>,<span class="number">16</span>);</span><br><span class="line">Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; stream = map.entrySet().stream();</span><br></pre></td></tr></table></figure></blockquote><h4 id="3-2-2中间操作"><a href="#3-2-2中间操作" class="headerlink" title="3.2.2中间操作"></a>3.2.2中间操作</h4><blockquote><p><strong>filter</strong>:对流中元素进行过滤,符合条件的留在流中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> author.getAge()&gt;<span class="number">18</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> .filter(author -&gt; author.getAge()&gt;<span class="number">18</span>)    </span><br><span class="line">  </span><br></pre></td></tr></table></figure><p><strong>map</strong>:可以把对流中的元素进行计算或转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;Author&gt; authors1 = getAuthors();</span><br><span class="line">        authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Author, String&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> author.toString();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .forEach(author-&gt;&#123;</span><br><span class="line">                    System.out.println(author.getClass());</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">//lambda表达式写法</span></span><br><span class="line"> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(author -&gt; author.toString()</span><br><span class="line">                )</span><br><span class="line">                .forEach(author-&gt;&#123;</span><br><span class="line">                    System.out.println(author.getClass());</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">/*结果全转成String类型</span></span><br><span class="line"><span class="comment">class java.lang.String</span></span><br><span class="line"><span class="comment">class java.lang.String</span></span><br><span class="line"><span class="comment">class java.lang.String</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>distinct</strong>:去重(根据equals方法),根据需求选择是否重写equals</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">authors.stream()</span><br><span class="line">           .distinct()</span><br><span class="line">           .forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                   System.out.println(author);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><p><strong>sorted</strong>:对流中内容进行排序(如果流中对象实现了<strong>Comparable接口</strong>中的compareto()方法则只需要调用sorted()的无参方法,否则调用有参方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   authors.stream()</span><br><span class="line">               .distinct()</span><br><span class="line">               .sorted(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Author&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Author o1, Author o2)</span> &#123;</span><br><span class="line">                       <span class="keyword">return</span> o2.getAge()-o1.getAge();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)</span><br><span class="line">               .forEach(author-&gt;&#123;</span><br><span class="line">                   System.out.println(author);</span><br><span class="line">               &#125;);</span><br><span class="line"><span class="comment">//lambda表达式写法</span></span><br><span class="line"> authors1.stream()</span><br><span class="line">               .distinct()</span><br><span class="line">               .sorted((author1,author2)-&gt;author1.getAge()-author2.getAge())</span><br><span class="line">               .forEach(author-&gt;&#123;</span><br><span class="line">                   System.out.println(author);</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure><p><strong>limit</strong>:设置流的长度限制(超过的会被舍弃)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">authors1.stream()</span><br><span class="line">               .distinct()</span><br><span class="line">               .sorted(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Author&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Author o1, Author o2)</span> &#123;</span><br><span class="line">                       <span class="keyword">return</span> o2.getAge()-o1.getAge();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)</span><br><span class="line">               .limit(<span class="number">2</span>)</span><br><span class="line">               .forEach(author-&gt;&#123;</span><br><span class="line">                   System.out.println(author);</span><br><span class="line">               &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>skip</strong>:跳过流中前n个元素,返回剩下的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">authors1.stream()</span><br><span class="line">         .distinct()</span><br><span class="line">         .sorted((author1,author2)-&gt;author1.getAge()-author2.getAge())</span><br><span class="line">         .skip(<span class="number">1</span>)</span><br><span class="line">         .forEach(author-&gt;&#123;</span><br><span class="line">             System.out.println(author);</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure><p><strong>flatMap</strong>: flatMap可以把一个对象转换成多个对象作为流中的元素。(map只能把一个对象转换成另一个对象来作为流中的元素。而flatMap可以把一个对象转换成多个对象作为流中的元素。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted((author1,author2)-&gt;author1.getAge()-author2.getAge())</span><br><span class="line">                .flatMap(author-&gt;author.getBooks().stream())</span><br><span class="line">     <span class="comment">//将author中的books(list)也转为流对象并且进行拼接</span></span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted((b1,b2)-&gt; (<span class="type">int</span>) (b1.getId()-b2.getId()))</span><br><span class="line">                .forEach(author-&gt;&#123;</span><br><span class="line">                    System.out.println(author);</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果用map出来的就不是一条一条的book信息而是一个类型值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .flatMap(author -&gt; author.getBooks().stream()</span><br><span class="line">                )</span><br><span class="line">                .flatMap(book-&gt; Arrays.stream(book.getCategory().split(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">                .distinct()</span><br><span class="line">                .forEach(author-&gt;&#123;</span><br><span class="line">                    System.out.println(author);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h4 id="3-2-3终结操作"><a href="#3-2-3终结操作" class="headerlink" title="3.2.3终结操作"></a>3.2.3终结操作</h4><blockquote><p><strong>forEach</strong>:对流中的元素进行遍历操作，我们通过传入的参数去指定对遍历到的元素进行什么具体操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">authors1.stream()</span><br><span class="line">               .distinct()</span><br><span class="line">               .flatMap(author -&gt; author.getBooks().stream()</span><br><span class="line">               )</span><br><span class="line">               .flatMap(book-&gt; Arrays.stream(book.getCategory().split(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">               .distinct()</span><br><span class="line">               .forEach(author-&gt;&#123;</span><br><span class="line">                   System.out.println(author);</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure><p><strong>count</strong>:获取流中元素个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">              .distinct()</span><br><span class="line">              .flatMap(author -&gt; author.getBooks().stream()</span><br><span class="line">              )</span><br><span class="line">              .flatMap(book -&gt; Arrays.stream(book.getCategory().split(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">              .distinct()</span><br><span class="line">              .count();</span><br><span class="line">      System.out.println(count);</span><br></pre></td></tr></table></figure><p><strong>max and min</strong>:最大值和最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大  </span></span><br><span class="line">Optional&lt;Integer&gt; max = authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(book -&gt; book.getScore())</span><br><span class="line">                .max((b1, b2) -&gt; b1 - b2);</span><br><span class="line">        System.out.println(max.get());</span><br><span class="line"><span class="comment">//最小</span></span><br><span class="line">  Optional&lt;Integer&gt; max = authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(book -&gt; book.getScore())</span><br><span class="line">                .min((b1, b2) -&gt; b1 - b2);</span><br></pre></td></tr></table></figure><p><strong>collect</strong>:流转换成collect集合</p><ol><li><p><strong>转成List</strong>:Collectors.toList()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; collect = authors1.stream()</span><br><span class="line">        .distinct()</span><br><span class="line">        .map(author -&gt; author.getName())</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li><li><p><strong>转成Set</strong> : Collectors.toSet()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; collect = authors1.stream()</span><br><span class="line">            .distinct()</span><br><span class="line">            .map(author -&gt; author.getName())</span><br><span class="line">            .collect(Collectors.toSet());</span><br></pre></td></tr></table></figure></li><li><p><strong>转成Map</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; collect = authors1.stream()</span><br><span class="line">    <span class="comment">//一定要去重,因为map键不能重复</span></span><br><span class="line">              .distinct()</span><br><span class="line">              .collect(Collectors.toMap(author -&gt; author.getName(), author -&gt; author.getAge()));</span><br><span class="line">      System.out.println(collect);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h5 id="查找与匹配"><a href="#查找与匹配" class="headerlink" title="查找与匹配"></a>查找与匹配</h5><blockquote><ol><li><p><strong>anyMatch</strong>:可以用来判断是否有任意符合匹配条件的元素，结果为boolean类型。(只要有一个满足就行)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .anyMatch(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> author.getAge() &gt; <span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .anyMatch( author-&gt; author.getAge() &gt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>allMatch</strong>:所有都满足返回true </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">            .distinct()</span><br><span class="line">            .allMatch( author-&gt; author.getAge() &gt; <span class="number">18</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>noneMatch</strong>:所有都不符合返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">              .noneMatch(author -&gt; author.getAge() &gt; <span class="number">100</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>findAny</strong>:获取随机一个元素(不能保证)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        Optional&lt;Author&gt; any = authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .findAny();</span><br><span class="line"><span class="comment">//不建议使用get,有可能是空</span></span><br><span class="line">        System.out.println(any.get());</span><br><span class="line"><span class="comment">//建议使用这个</span></span><br><span class="line">   any.ifPresent(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">               System.out.println(author);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>findFirst</strong>:获取第一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    Optional&lt;Author&gt; any = authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .findFirst();</span><br><span class="line"><span class="comment">//建议使用这个</span></span><br><span class="line">   any.ifPresent(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">               System.out.println(author);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>reduce归并</strong> :对流进行操作,按照你定的规则返回一个结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//底层</span></span><br><span class="line">  <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> identity;</span><br><span class="line"><span class="keyword">for</span> (T element : <span class="built_in">this</span> stream)</span><br><span class="line">result = accumulator.apply(result, element)</span><br><span class="line"><span class="keyword">return</span> result;  </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将所有作者的名称拼接起来</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">reduce</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(author -&gt; author.getName())</span><br><span class="line">                .reduce(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> <span class="title class_">BinaryOperator</span>&lt;String&gt;() &#123;</span><br><span class="line">                  </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String s, String s2)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> s + s2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(reduce);</span><br><span class="line"><span class="comment">//简易版</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">reduce</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(author -&gt; author.getName())</span><br><span class="line">                .reduce(<span class="string">&quot;&quot;</span>,(s1,s2)-&gt;s1+s2);</span><br><span class="line">        System.out.println(reduce);</span><br><span class="line"><span class="comment">//reduce中传一个参数的</span></span><br><span class="line">Optional&lt;String&gt; reduce = authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(author -&gt; author.getName())</span><br><span class="line">                .reduce((s1, s2) -&gt; s1 + s2);</span><br><span class="line">       reduce.ifPresent(name-&gt; System.out.println(name));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">源码为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//设定一个tag为foundAny判断是否是首次输入,如果是首次输入将首个输入赋值给result剩下操作与传初始值的操作一样</span></span><br><span class="line">    *     <span class="type">boolean</span> <span class="variable">foundAny</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">     *     <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     *     <span class="keyword">for</span> (T element : <span class="built_in">this</span> stream) &#123;</span><br><span class="line">     *         <span class="keyword">if</span> (!foundAny) &#123;</span><br><span class="line">     *             foundAny = <span class="literal">true</span>;</span><br><span class="line">     *             result = element;</span><br><span class="line">     *         &#125;</span><br><span class="line">     *         <span class="keyword">else</span></span><br><span class="line">     *             result = accumulator.apply(result, element);</span><br><span class="line">     *     &#125;</span><br><span class="line">     *     <span class="keyword">return</span> foundAny ? Optional.of(result) : Optional.empty();</span><br></pre></td></tr></table></figure></li></ol></li></ol></blockquote><h3 id="3-3注意事项"><a href="#3-3注意事项" class="headerlink" title="3.3注意事项"></a>3.3注意事项</h3><blockquote><ol><li><strong>惰性求值</strong>: 流如果没有终结操作,则中间操作不会执行</li><li><strong>流是一次性的</strong>:当一个流对象执行完一次终结操作后,再次使用中间操作或者终结操作会报错</li><li><strong>流不会干扰原数据的</strong>:流对数据进行操作时不会影响原数据,除非你在流中给引用类型赋值.</li></ol></blockquote><h2 id="4-Optional"><a href="#4-Optional" class="headerlink" title="4.Optional"></a>4.Optional</h2><h3 id="4-1概述"><a href="#4-1概述" class="headerlink" title="4.1概述"></a>4.1概述</h3><blockquote><p>代码中经常会出现空指针问题,需要  进行非空判断</p></blockquote><h3 id="4-2使用"><a href="#4-2使用" class="headerlink" title="4.2使用"></a>4.2使用</h3><h4 id="4-2-1创建"><a href="#4-2-1创建" class="headerlink" title="4.2.1创建"></a>4.2.1创建</h4><blockquote><p>Option可以将对象封装进去,然后对封装进去的数据进行操作.Option会提供方法进行非空判断.</p><ol><li><p><strong>静态方法ofNullable</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Author</span> <span class="variable">author</span> <span class="operator">=</span> getAuthor();</span><br><span class="line">        Optional&lt;Author&gt; authorOptional = Optional.ofNullable(author);</span><br></pre></td></tr></table></figure><p>也可以直接将方法的返回值设为Option,这样就可以直接接收到Option对象</p><p>底层代码:<strong>非空时调用of方法</strong>,空时调用<strong>Optional的empty()方法</strong>返回空的Optional对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">ofNullable</span><span class="params">(T value)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> value == <span class="literal">null</span> ? empty() : of(value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>静态方法of</strong>:不会进行非空判断,如果传入为空则报错(不建议使用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Author</span> <span class="variable">author</span> <span class="operator">=</span> getAuthor();</span><br><span class="line">        Optional&lt;Author&gt; authorOptional = Optional.of(author);</span><br><span class="line"><span class="comment">//传入null会报空指针异常</span></span><br><span class="line">authorOptional = Optional.of(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="4-2-2-安全消费-使用"><a href="#4-2-2-安全消费-使用" class="headerlink" title="4.2.2 安全消费(使用)"></a>4.2.2 安全消费(使用)</h4><blockquote><p>获取到Option对象后肯定需要 使用数据<strong>ifPresent</strong>:会判断Option对象是否为空,不为空则使用 .</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    author.ifPresent(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                System.out.println(author);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//简化版</span></span><br><span class="line">     author.ifPresent(au-&gt; System.out.println(au));</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-2-3-获取值"><a href="#4-2-3-获取值" class="headerlink" title="4.2.3 获取值"></a>4.2.3 获取值</h4><blockquote><p>如果我们想获取值自己进行处理可以使用get方法获取，但是不推荐。因为<strong>当Optional内部的数据为空的时候使用get()会出现异常。</strong></p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//一旦为空则会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;No value present&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> Optional&lt;Author&gt;  author= Optional.of(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//Optional中的value为null时会报错</span></span><br><span class="line">        <span class="type">Author</span> <span class="variable">author1</span> <span class="operator">=</span> author.get();</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-2-4-安全获取值"><a href="#4-2-4-安全获取值" class="headerlink" title="4.2.4 安全获取值"></a>4.2.4 安全获取值</h4><blockquote><ol><li><p><strong>orElseGet</strong>:当Option的value为空,返回你传入的内容.</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> &#123;</span><br><span class="line">    <span class="comment">//Option.value是否为空,如果为空返回other.get();other就是你传进来的接口,otherget()就是你传进来的内容</span></span><br><span class="line">     <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other.get();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt;  author= Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line"> <span class="comment">// Optional&lt;Author&gt;  author= Optional.ofNullable(new Author(18L,&quot;亚索&quot;,18,&quot;托儿所&quot;,null));</span></span><br><span class="line">        <span class="type">Author</span> <span class="variable">author1</span> <span class="operator">=</span> author.orElseGet(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Author&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Author <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Author</span>(<span class="number">19L</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">19</span>,<span class="string">&quot;法外狂徒&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(author1);</span><br></pre></td></tr></table></figure></li><li><p><strong>orElseThrow</strong>:当Option的value为空时,抛出定义的异常</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;X <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; T <span class="title function_">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X &#123;</span><br><span class="line">    <span class="comment">//如果value不为空返回value</span></span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//为空抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt;  author= Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line">     <span class="type">Author</span> <span class="variable">value</span> <span class="operator">=</span> author.orElseThrow(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Throwable&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> Throwable <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;value为空&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     System.out.println(value);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="4-2-5-过滤filter"><a href="#4-2-5-过滤filter" class="headerlink" title="4.2.5 过滤filter"></a>4.2.5 过滤filter</h4><blockquote><p>Optional也有一个filter方法,可以对数据进行过滤,如果<strong>原本有数据但是不符合规定,也会返回空value的Optional</strong></p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span> &#123;</span><br><span class="line">    <span class="comment">//做非空判断的,判断你传进来的过滤接口是否为空,如果为空抛出异常</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">public static &lt;T&gt; T requireNonNull(T obj) &#123;</span></span><br><span class="line"><span class="comment">    if (obj == null)</span></span><br><span class="line"><span class="comment">        throw new NullPointerException();</span></span><br><span class="line"><span class="comment">    return obj;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public boolean isPresent() &#123;</span></span><br><span class="line"><span class="comment">    //判断value是否为空,为空直接返回空value</span></span><br><span class="line"><span class="comment">    return value != null;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果接口不为空,value不为空,调用实现接口的test方法看最后返回的内容,如果不满足返回空value的Optional</span></span><br><span class="line">        <span class="keyword">return</span> predicate.test(value) ? <span class="built_in">this</span> : empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; author2 = author.filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> author.getAge() &gt; <span class="number">20</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-2-6-判断isPresen"><a href="#4-2-6-判断isPresen" class="headerlink" title="4.2.6 判断isPresen"></a>4.2.6 判断isPresen</h4><blockquote><p>​<strong>isPresen</strong>:判断value是否为null,为null返回false,不为null返回true</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很简单,判断value是否为null,为null返回false,不为null返回true</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPresent</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">present</span> <span class="operator">=</span> author.isPresent();</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-2-7转换map"><a href="#4-2-7转换map" class="headerlink" title="4.2.7转换map"></a>4.2.7转换map</h4><blockquote><p><strong>map</strong>:数据转换也可以做计算,并且Optional在底层做了ofNullable保证不报错</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends U&gt; mapper)</span> &#123;</span><br><span class="line">    <span class="comment">//判断传入的实现的匿名接口不为null,为null会报错</span></span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="comment">//isPresent()判断value是否为空,不为空则为进else如果为空调用empty()方法返回空的Optional</span></span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; s = author.map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Author, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> author.getName();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><h2 id="5-函数式接口"><a href="#5-函数式接口" class="headerlink" title="5.函数式接口"></a>5.函数式接口</h2><h3 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h3><blockquote><p><strong>接口中只有一个抽象方法</strong>的接口,称为函数式接口</p><p>JDK的函数式接口都有**@FuncationalInterface**注解进行标识.</p></blockquote><h3 id="5-2常见函数式接口"><a href="#5-2常见函数式接口" class="headerlink" title="5.2常见函数式接口"></a>5.2常见函数式接口</h3><blockquote><ol><li><p><strong>Consumer 消费接口</strong></p><p>无返回值,因此一般都是使用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li><li><p>​<strong>Function 计算转换接口</strong></p><p>有R类型的返回值,可以执行运算和转换操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">      </span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; Function&lt;V, R&gt; <span class="title function_">compose</span><span class="params">(Function&lt;? <span class="built_in">super</span> V, ? extends T&gt; before)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="title function_">andThen</span><span class="params">(Function&lt;? <span class="built_in">super</span> R, ? extends V&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Function&lt;T, T&gt; <span class="title function_">identity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>​<strong>Predicate 判断接口</strong></p><p>返回值为boolean类型,判断型接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>**Supplier **</p><p>T类型返回值,可以返回你想要的类型的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="5-3常用默认方法"><a href="#5-3常用默认方法" class="headerlink" title="5.3常用默认方法"></a>5.3常用默认方法</h3><blockquote><p> <strong>用于将Predicate判断接口的拼接</strong><br><strong>and</strong> 相当于&amp;&amp;</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">and</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">      Objects.requireNonNull(other);</span><br><span class="line">    <span class="comment">//返回自己的test的结果与上传进来的and里面的test</span></span><br><span class="line">      <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>or</strong>相当于||</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">or</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">       Objects.requireNonNull(other);</span><br><span class="line">       <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>negate</strong>相当于!</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">authors1.stream()</span><br><span class="line">              .distinct()</span><br><span class="line">              .filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                      <span class="keyword">return</span> author.getAge()&gt;<span class="number">10</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;.and(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                      <span class="keyword">return</span> author.getAge()&lt;<span class="number">23</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;))</span><br><span class="line">              .forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                      System.out.println(author);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="6方法引用"><a href="#6方法引用" class="headerlink" title="6方法引用"></a>6方法引用</h2><blockquote><p>当方法体重只有一个方法调用时可以对代码进行进一步简化</p></blockquote><h3 id="6-1推荐用法"><a href="#6-1推荐用法" class="headerlink" title="6.1推荐用法"></a>6.1推荐用法</h3><blockquote><p>​我们在使用lambda时不需要考虑什么时候用方法引用，用哪种方法引用，方法引用的格式是什么。我们只需要在写完lambda方法发现方法体只有一行代码，并且是方法的调用时使用快捷键尝试是否能够转换成方法引用即可。</p><p>​当我们方法引用使用的多了慢慢的也可以直接写出方法引用。</p></blockquote><h3 id="6-2-基本格式"><a href="#6-2-基本格式" class="headerlink" title="6.2 基本格式"></a>6.2 基本格式</h3><p>​类名或者对象名::方法名</p><h3 id="6-3详解"><a href="#6-3详解" class="headerlink" title="6.3详解"></a>6.3详解</h3><h4 id="6-3-1引用静态方法"><a href="#6-3-1引用静态方法" class="headerlink" title="6.3.1引用静态方法"></a>6.3.1引用静态方法</h4><blockquote><h4 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h4><p> 使用前提如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了某个类的静态方法</strong>，并且我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个静态方法中</strong>，这个时候我们就可以引用类的静态方法。</p><p>格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名::方法名</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">        Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line">        </span><br><span class="line">        authorStream.map(author -&gt; author.getAge())</span><br><span class="line">                .map(age-&gt;String.valueOf(age));</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"> List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">        Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line"></span><br><span class="line">        authorStream.map(author -&gt; author.getAge())</span><br><span class="line">                .map(String::valueOf);</span><br></pre></td></tr></table></figure></blockquote><h4 id="6-3-2-引用对象的实例方法"><a href="#6-3-2-引用对象的实例方法" class="headerlink" title="6.3.2 引用对象的实例方法"></a>6.3.2 引用对象的实例方法</h4><blockquote><h5 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名::方法名</span><br></pre></td></tr></table></figure><h5 id="使用前提-1"><a href="#使用前提-1" class="headerlink" title="使用前提"></a>使用前提</h5><p>​如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了某个对象的成员方法</strong>，并且我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个成员方法中</strong>，这个时候我们就可以引用对象的实例方法</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">authorStream.map(author -&gt; author.getName())</span><br><span class="line">        .forEach(name-&gt;sb.append(name));</span><br></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">authorStream.map(author -&gt; author.getName())</span><br><span class="line">        .forEach(sb::append);</span><br></pre></td></tr></table></figure></blockquote><h4 id="6-3-4-引用类的实例方法"><a href="#6-3-4-引用类的实例方法" class="headerlink" title="6.3.4 引用类的实例方法"></a>6.3.4 引用类的实例方法</h4><blockquote><h5 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名::方法名</span><br></pre></td></tr></table></figure><h5 id="使用前提-2"><a href="#使用前提-2" class="headerlink" title="使用前提"></a>使用前提</h5><p>​如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了第一个参数的成员方法</strong>，并且我们把要<strong>重写的抽象方法中剩余的所有的参数都按照顺序传入了这个成员方法中</strong>，这个时候我们就可以引用类的实例方法。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">interface</span> <span class="title class_">UseString</span>&#123;</span><br><span class="line">       String <span class="title function_">use</span><span class="params">(String str,<span class="type">int</span> start,<span class="type">int</span> length)</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">subAuthorName</span><span class="params">(String str, UseString useString)</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> useString.use(str,start,length);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">       subAuthorName(<span class="keyword">new</span> <span class="title class_">UseString</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> String <span class="title function_">use</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> str.substring(start,length);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    subAuthorName(String::substring);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="6-3-5-构造器引用"><a href="#6-3-5-构造器引用" class="headerlink" title="6.3.5 构造器引用"></a>6.3.5 构造器引用</h4><blockquote><p>如果方法体中的一行代码是构造器的话就可以使用构造器引用。</p><h5 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名::<span class="keyword">new</span></span><br></pre></td></tr></table></figure><h5 id="使用前提-3"><a href="#使用前提-3" class="headerlink" title="使用前提"></a>使用前提</h5><p>​如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了某个类的构造方法</strong>，并且我们把<strong>要重写的抽象方法中的所有的参数都按照顺序传入了这个构造方法中</strong>，这个时候我们就可以引用构造器。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">        .map(author -&gt; author.getName())</span><br><span class="line">        .map(name-&gt;<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(name))</span><br><span class="line">        .map(sb-&gt;sb.append(<span class="string">&quot;张三&quot;</span>).toString())</span><br><span class="line">        .forEach(str-&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">        .map(author -&gt; author.getName())</span><br><span class="line">        .map(StringBuilder::<span class="keyword">new</span>)</span><br><span class="line">        .map(sb-&gt;sb.append(<span class="string">&quot;张三&quot;</span>).toString())</span><br><span class="line">        .forEach(str-&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></blockquote><h2 id="7-高级用法"><a href="#7-高级用法" class="headerlink" title="7.高级用法"></a>7.高级用法</h2><h3 id="7-1-基本类型优化"><a href="#7-1-基本类型优化" class="headerlink" title="7.1 基本类型优化"></a>7.1 基本类型优化</h3><blockquote><p>主要还是流对象在操作时会使用包装类,会经常拆箱装箱,导致效率低下.因此可以对这一现象进行优化.</p><p>可以使用map操作进行避免</p><p>mapToInt,mapToLong,mapToDouble,flatMapToInt,flatMapToDouble</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">authors.stream()</span><br><span class="line">               .mapToInt(author -&gt; author.getAge())</span><br><span class="line">               .map(age -&gt; age + <span class="number">10</span>)</span><br><span class="line">               .filter(age-&gt;age&gt;<span class="number">18</span>)</span><br><span class="line">               .map(age-&gt;age+<span class="number">2</span>)</span><br><span class="line">               .forEach(System.out::println)</span><br></pre></td></tr></table></figure></blockquote><h3 id="7-2并行流"><a href="#7-2并行流" class="headerlink" title="7.2并行流"></a>7.2并行流</h3><blockquote><p>大量数据进行操作时,可以使用并行流提高效率,就是多项成.stream对多线程做了优化,可以使用其方法来实现,从而提高效率</p><p><strong>parallel</strong>:可以把串行流转换成并行流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用parallel需要先得到流对象</span></span><br><span class="line">authors1.stream().parallel()</span><br><span class="line">                .peek(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread()+author.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .distinct()</span><br><span class="line">                .filter(author -&gt; author.getAge()&gt;<span class="number">15</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>parallelStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用parallelStream可以直接得到流对象</span></span><br><span class="line"> authors1.parallelStream()</span><br><span class="line">                .peek(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread()+author.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .distinct()</span><br><span class="line">                .filter(author -&gt; author.getAge()&gt;<span class="number">15</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Stream流 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
