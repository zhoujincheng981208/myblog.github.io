<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/20/hello-world/"/>
      <url>/2022/08/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程JUC</title>
      <link href="/2022/03/18/JUC/"/>
      <url>/2022/03/18/JUC/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1.进程和线程"></a>1.进程和线程</h2><h3 id="1-1概念"><a href="#1-1概念" class="headerlink" title="1.1概念"></a>1.1概念</h3><ol><li>程序:计算机中的.exe文件</li><li><strong>进程</strong>:指运行中的程序,是程序的一次执行过程,或是正在运行的程序.是一个动态的过程:产生,存在和消亡</li><li><strong>线程</strong>:线程由进程创建,是进程的一个实体,进程可以拥有多个线程.</li></ol><h4 id="1-1-1线程与进程的区别"><a href="#1-1-1线程与进程的区别" class="headerlink" title="1.1.1线程与进程的区别:"></a>1.1.1线程与进程的区别:</h4><table><thead><tr><th align="center">名称</th><th align="center">相互影响</th><th align="center">通信</th><th align="center">上下文切换</th></tr></thead><tbody><tr><td align="center">进程</td><td align="center">进程之间基本不相互影响</td><td align="center">比较复杂,同机为IPC(Inter-process communication),不同机需要遵从协议,如:Http</td><td align="center">复杂</td></tr><tr><td align="center">线程</td><td align="center">线程由于共享进程的内存空间等线程之间可以相互影响</td><td align="center">由于共享进程内存空间,通信比较简单</td><td align="center">简单</td></tr></tbody></table><h4 id="1-1-2上下文切换"><a href="#1-1-2上下文切换" class="headerlink" title="1.1.2上下文切换:"></a>1.1.2上下文切换:</h4><blockquote><p>每个任务都有自己的CPU时间片,当前任务在执⾏完 CPU 时间⽚切换到另⼀个任务之前会先保存⾃⼰的状态(程序计数器)，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是⼀次上下⽂切换</strong>。上下文切换会花费时间.</p><p><strong>上下文切换场景</strong></p><ol><li>时间片用完了</li><li>垃圾回收线程需要运行</li><li>更高优先级的线程需要运行</li><li>线程自己调用了sleep，wait，join，yield，park，synchorized，lock等方法</li></ol></blockquote><h3 id="1-2并发并行"><a href="#1-2并发并行" class="headerlink" title="1.2并发并行"></a>1.2并发并行</h3><ol><li><p><strong>并发</strong>:同一时刻多个任务交替执行  单核</p></li><li><p><strong>并行</strong>:同一时刻多个任务同时进行  多核</p></li><li><p>并发和并行可以同时存在</p><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="并发并行示意图"></p></li></ol><h3 id="1-3-线程的三种创建方法"><a href="#1-3-线程的三种创建方法" class="headerlink" title="1.3 线程的三种创建方法"></a>1.3 线程的三种创建方法</h3><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/%E6%97%B6%E9%97%B4%E8%BD%B4.png" alt="时间轴"></p><h4 id="1-3-1继承Thread类-重写run方法-使用start-开启线程"><a href="#1-3-1继承Thread类-重写run方法-使用start-开启线程" class="headerlink" title="1.3.1继承Thread类,重写run方法,使用start()开启线程"></a>1.3.1继承Thread类,重写run方法,使用start()开启线程</h4><h4 id="1-3-2实现Runnable接口-实现run方法-建议使用毕竟接口可以多实现-而继承只能单继承"><a href="#1-3-2实现Runnable接口-实现run方法-建议使用毕竟接口可以多实现-而继承只能单继承" class="headerlink" title="1.3.2实现Runnable接口,实现run方法,(建议使用毕竟接口可以多实现,而继承只能单继承)"></a>1.3.2实现Runnable接口,实现run方法,(建议使用毕竟接口可以多实现,而继承只能单继承)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjc.study.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程实现方式一实现Runnable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">imp</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程实现方式二继承Thread类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">imp2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 方式一</span></span><br><span class="line">        <span class="type">imp</span> <span class="variable">imp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">imp</span>();</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(imp);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="type">imp2</span> <span class="variable">imp2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">imp2</span>();</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        imp2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-3-FutureTask-配合-Thread"><a href="#1-3-3-FutureTask-配合-Thread" class="headerlink" title="1.3.3 FutureTask 配合 Thread"></a>1.3.3 FutureTask 配合 Thread</h4><blockquote><p><strong>FutureTask</strong> 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><p>执行流程:</p><ol><li>创建线程传入Callable实现类</li><li>通过start启动线程</li><li>start底层会调用run方法</li><li>run方法中会调用Callable实现类的call方法(call方法有返回值)</li><li>通过get拿到值</li></ol><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Future接口提供了获取方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">//不用传参会一直等,知道计算出来或者报错</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    <span class="comment">//传入参数timeout时间  unit时间的单位,等到时间到了就结束不管有没有计算出来</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutExceptio</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RunnableFuture接口继承了Runnable接口和Future接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// FutureTask 实现了RunnableFuture接口而RunnableFuture接口继承了Runnable接口和Future接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">//构造方法 需要传一个Callable对象</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public interface Callable&lt;V&gt; &#123;</span></span><br><span class="line"><span class="comment">   //Callable&lt;V&gt;接口中有一个call方法就是用来计算结果的需要抛出异常</span></span><br><span class="line"><span class="comment">    *V call() throws Exception;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.callable = callable;</span><br><span class="line">        <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="type">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="literal">null</span>;</span><br><span class="line">                    ran = <span class="literal">false</span>;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get获取值</span></span><br><span class="line">     <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">            (s = awaitDone(<span class="literal">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjc.study.day66;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建任务对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; task3 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task3, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task3.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="1-4线程状态"><a href="#1-4线程状态" class="headerlink" title="1.4线程状态"></a>1.4线程状态</h3><h4 id="1-4-1线程五状态"><a href="#1-4-1线程五状态" class="headerlink" title="1.4.1线程五状态"></a>1.4.1线程五状态</h4><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/image-20220607150302096.png" alt="image-20220607150302096"></p><blockquote><ol><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li><li>【运行状态】指获取了 CPU 时间片运行中的状态当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li><li>【阻塞状态】<ol><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】</li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li></ol></li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ol></blockquote><h4 id="1-4-2-线程六状态"><a href="#1-4-2-线程六状态" class="headerlink" title="1.4.2 线程六状态"></a>1.4.2 线程六状态</h4><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/image-20220607150613102.png" alt="image-20220607150613102"></p><blockquote><ol><li><p>new(初始化状态)还没调用start</p></li><li><p>RUNNABLE(运行状态)(运不运行看底层)</p></li><li><p>BLOCKED(阻塞状态)(锁(<strong>线9</strong>)等,在EntryList中等待运行的线程)</p></li><li><p>WAITING(等待状态 wait,)</p><ol><li><p>wait进入WAITING,需要使用Obj.notify,Obj.notifyAll(),t.interrupt()(<strong>线2</strong>) </p><ol><li>竞争成功: RUNNABLE</li><li>竞争失败: BLOCKED</li></ol></li><li><p>join 让调用join方法的线程进入WAITING,直到join线程结束入RUNNABLE (<strong>线3</strong>)</p></li><li><p>park和unpark\interrupt也会使线程,从WAITING到RUNNABLE(<strong>线4</strong>)</p></li></ol></li><li><p>TIMED_WAITING(超时等待,sleep(long mills)(<strong>线5</strong>),wait(long mills)(<strong>线6</strong>),join(long mills)(<strong>线7</strong>),parkNanos(long mills)&#x2F;parkUtil(long mills)(<strong>线8</strong>))</p><ol><li><strong>sleep()和waiting()的区别在于sleep()方法不会释放锁,因此sleep()不会进入BLOCKED(阻塞状态),然而wait()会释放锁,因此wait()如果没拿到锁会进入BLOCKED</strong></li></ol></li><li><p>TERMINATED(结束状态)(<strong>线10</strong>)</p></li></ol><p>实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程六状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1.初始化状态&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Ops5.class)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;2.运行状态&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;6.结束状态&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        thread3.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread2.join();</span><br><span class="line">                System.out.println(<span class="string">&quot;4.等待状态&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        thread4.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;5.超时等待状态&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        thread5.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Ops5.class)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;5.阻塞状态&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        thread6.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(thread1.getState());</span><br><span class="line">        System.out.println(thread2.getState());</span><br><span class="line">        System.out.println(thread3.getState());</span><br><span class="line">        System.out.println(thread4.getState());</span><br><span class="line">        System.out.println(thread5.getState());</span><br><span class="line">        System.out.println(thread6.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==========================</span><br><span class="line"><span class="number">2.</span>运行状态</span><br><span class="line"><span class="number">6.</span>结束状态</span><br><span class="line">NEW</span><br><span class="line">RUNNABLE</span><br><span class="line">TERMINATED</span><br><span class="line">WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">BLOCKED</span><br></pre></td></tr></table></figure></blockquote><h4 id="1-4-3-线程七状态"><a href="#1-4-3-线程七状态" class="headerlink" title="1.4.3 线程七状态"></a>1.4.3 线程七状态</h4><blockquote><ol><li>new(初始化状态)</li><li>Ready(就绪状态)&#x2F;&#x2F;这个不算就六个状态</li><li>RUNNABLE(运行状态)(运不运行看底层)</li><li>BLOCKED(阻塞状态)(sleep,wait,锁等)</li><li>WAITING(等待状态)</li><li>TIMED_WAITING(超时等待)</li><li>TERMINATED(结束状态)</li></ol></blockquote><h3 id="1-5-查看线程的命令"><a href="#1-5-查看线程的命令" class="headerlink" title="1.5 查看线程的命令"></a>1.5 查看线程的命令</h3><p><strong>windows</strong></p><blockquote><ol><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li>tasklist 查看进程</li><li>taskkill 杀死进程</li></ol></blockquote><p><strong>linux</strong></p><blockquote><ol><li>ps -fe 查看所有进程</li><li>ps -fT -p <PID> 查看某个进程（PID）的所有线程</li><li>kill 杀死进程</li><li>top 按大写 H 切换是否显示线程</li><li>top -H -p <PID> 查看某个进程（PID）的所有线程</li></ol></blockquote><p><strong>java</strong></p><blockquote><ol><li>jps 命令查看所有 Java 进程</li><li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态 </li><li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li></ol></blockquote><h3 id="1-6为什么不直接使用run方法而选用start方法启动线程"><a href="#1-6为什么不直接使用run方法而选用start方法启动线程" class="headerlink" title="1.6为什么不直接使用run方法而选用start方法启动线程"></a>1.6为什么不直接使用run方法而选用start方法启动线程</h3><blockquote><p>如果直接使用run方法,他就是一个普通的方法,会放在主线程中执行,而不是当做一个线程进行执行.</p><p>使用start启动时会调用底层的start0方法.使线程完成初始化</p><p><strong>start方法源码</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">         * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">         * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">         这个方法不会被主方法线程或由VM创建的“系统”组线程调用。将来添加到此方法的任何新功能可能也必须添加到VM中。状态值为零对应状态“NEW”</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">        <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">         * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">         * and the group&#x27;s unstarted count can be decremented. </span></span><br><span class="line"><span class="comment">         通知组这个线程即将启动，这样就可以将它添加到组的线程列表中，并且可以减少组的未启动计数。*/</span></span><br><span class="line">        group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//底层的线程方法被native修饰使用c或者c++编写</span></span><br><span class="line">            start0();</span><br><span class="line">            <span class="comment">//线程启动成功</span></span><br><span class="line">            started = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//如果线程没有启动成功</span></span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    <span class="comment">//回滚线程</span></span><br><span class="line">                    group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Notifies the group that the thread &#123;<span class="doctag">@code</span> t&#125; has failed</span></span><br><span class="line"><span class="comment">     * an attempt to start.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; The state of this thread group is rolled back as if the</span></span><br><span class="line"><span class="comment">     * attempt to start the thread has never occurred. The thread is again</span></span><br><span class="line"><span class="comment">     * considered an unstarted member of the thread group, and a subsequent</span></span><br><span class="line"><span class="comment">     * attempt to start the thread is permitted.</span></span><br><span class="line"><span class="comment">     *通知组线程t启动尝试失败。这个线程组的状态会回滚，就像启动线程的尝试从未发生过一样。</span></span><br><span class="line"><span class="comment">     该线程再次被视为线程组中未启动的成员，并且允许后续尝试启</span></span><br><span class="line"><span class="comment">     动该线程。t -启动方法被调用的线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  t</span></span><br><span class="line"><span class="comment">     *         the Thread whose start method was invoked</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">threadStartFailed</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">//将该线程移除</span></span><br><span class="line">            remove(t);</span><br><span class="line">            nUnstartedThreads++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 接口实现多线程流程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjc.study.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 理论实现Runnable创建线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadProxy</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//5. 如果target存在则调用实现类的run方法不存在则回滚</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.初始化时传入runnable的实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadProxy</span><span class="params">(Runnable runnable)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target = runnable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.调用start方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.start0();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.start会调用底层由c或者c++编写的线程实现代码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由于dog必须继承animal类因此无法通过extends Thread来创建线程只能通过实现接口的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dog自己的run方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;wang...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建线程  传入runable实例对象</span></span><br><span class="line">        <span class="type">ThreadProxy</span> <span class="variable">threadProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadProxy</span>(<span class="keyword">new</span> <span class="title class_">dog</span>());</span><br><span class="line">        <span class="comment">//3.调用start方法</span></span><br><span class="line">        threadProxy.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="1-7通知线程退出"><a href="#1-7通知线程退出" class="headerlink" title="1.7通知线程退出"></a>1.7通知线程退出</h3><blockquote><ol><li><p>线程完成任务后会自动退出</p></li><li><p>如果希望干预线程退出,可以通过控制变量来控制run方法达到停止线程的目的,即<strong>通知方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjc.study.Stream;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通知方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//设置标志来使run方法达到执行完的条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTag</span><span class="params">(<span class="type">boolean</span> tag)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (tag)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建实现类</span></span><br><span class="line">        <span class="type">ThreadImpl</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadImpl</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread1);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>*<span class="number">100</span>);</span><br><span class="line">        thread1.setTag(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="1-8-常用方法"><a href="#1-8-常用方法" class="headerlink" title="1.8 常用方法"></a>1.8 常用方法</h3><ol><li><p>sleep() 线程休眠 线程进入超时等待状态</p></li><li><p>interrupt() 唤醒线程 会爆InterruptedException异常 ,可以用来打断运行,每个线程都有自己的打断标记打断标记默认为false</p><ol><li><p>interrupt() 打断 sleep，wait，join 的线程不会设置打断标记 ,会抛出异常</p></li><li><p>interrupt() 打断普通线程会将打断标记置位true,底层在Parker中的_counter默认为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两阶段终止模式，即让线程优雅的退出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">thread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        thread.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread current;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        current = <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">               <span class="type">boolean</span> <span class="variable">tag</span> <span class="operator">=</span> Thread.currentThread().isInterrupted();</span><br><span class="line">               <span class="keyword">if</span> (tag)&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;线程正在运行&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">1000</span>);<span class="comment">//众所周知 如果外界使用interrupt()时线程因为sleep进入超时等待状态时会抛出异常并且不会更改打断标记;</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">                   <span class="comment">//因此需要手动设置打断标记</span></span><br><span class="line">                   current.interrupt();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        current.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        current.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">======================</span><br><span class="line">线程正在运行</span><br><span class="line">线程正在运行</span><br><span class="line">线程正在运行</span><br><span class="line">线程正在运行</span><br><span class="line">线程正在运行</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at com.zjc.study.day66.thread.lambda$start$<span class="number">0</span>(Ops4.java:<span class="number">30</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure></li><li><p>与park类似,park如果打断标记为false则不执行park以下的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line"> LockSupport.park();<span class="comment">//如果Thread.currentThread().isInterrupted()为false即打断标记为false则不向下执行</span></span><br><span class="line"> log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line"> log.debug(<span class="string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());</span><br><span class="line"> &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"> t1.start();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> sleep(<span class="number">0.5</span>);</span><br><span class="line"> t1.interrupt();<span class="comment">//也可以用LockSupport.\unpark(t1)</span></span><br><span class="line">&#125;</span><br><span class="line">输出</span><br><span class="line"><span class="number">21</span>:<span class="number">11</span>:<span class="number">52.795</span> [t1] c.TestInterrupt - park... </span><br><span class="line"><span class="number">21</span>:<span class="number">11</span>:<span class="number">53.295</span> [t1] c.TestInterrupt - unpark... </span><br><span class="line"><span class="number">21</span>:<span class="number">11</span>:<span class="number">53.295</span> [t1] c.TestInterrupt - 打断状态：<span class="literal">true</span> </span><br></pre></td></tr></table></figure></li></ol></li><li><p>setName()设置线程名称</p></li><li><p>setPriority() 设置线程优先级 (不绝对保证优先执行)</p></li><li><p>getPriority() 获取优先级</p></li><li><p>yield() 线程礼让(让了但是如果我让了你半天没走我就走了)</p></li><li><p>join() 插队,会执行完插队成功线程的所有任务</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjc.study.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常用方法</span></span><br><span class="line"><span class="comment"> * 1. sleep 线程休眠</span></span><br><span class="line"><span class="comment"> * 2. interrupt() 唤醒线程 会爆InterruptedException异常</span></span><br><span class="line"><span class="comment"> * 3. setName()设置线程名称</span></span><br><span class="line"><span class="comment"> * 4. setPriority 设置线程优先级 (不绝对保证优先执行)</span></span><br><span class="line"><span class="comment"> * 5. getPriority 获取优先级</span></span><br><span class="line"><span class="comment"> * 6. yield 礼让</span></span><br><span class="line"><span class="comment"> * 7. join  插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;要进入休眠了&quot;</span>);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Thread.sleep(10*10000);</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">1</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我要被唤醒了&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我结束休眠了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops12</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建实现类</span></span><br><span class="line">        <span class="type">AThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// Thread.sleep(10*1000);</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">1</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// setName()设置线程名称</span></span><br><span class="line">        thread.setName(<span class="string">&quot;零号线程&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">//插队会执行完</span></span><br><span class="line">        thread2.join();</span><br><span class="line">        <span class="comment">//设置优先级</span></span><br><span class="line">        thread.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        Thread.sleep(<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//唤醒线程 会爆InterruptedException异常</span></span><br><span class="line">        <span class="comment">//thread.interrupt();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9用户线程守护线程"><a href="#1-9用户线程守护线程" class="headerlink" title="1.9用户线程守护线程"></a>1.9用户线程守护线程</h3><ol><li>用户线程 </li><li>守护线程  如果内存中没有线程执行就不执行守护线程  main线程 垃圾回收线程</li></ol><blockquote><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span>  <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是守护线程&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//设置为守护线程</span></span><br><span class="line">    aa.setDaemon(<span class="literal">true</span>);</span><br><span class="line"> <span class="comment">//判断是否是守护线程</span></span><br><span class="line">  System.out.println(aa.isDaemon());</span><br><span class="line">    aa.start();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当程序中有用户线程时守护线程执行,当没有用户线程,守护线程不执行</span></span><br><span class="line"><span class="comment"> * 即当bb线程和cc线程注销后aa守护线程不执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops1</span> &#123;</span><br><span class="line">    <span class="comment">//2.创建多个线程操作资源类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">saleticket</span> <span class="variable">saleticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">saleticket</span>();</span><br><span class="line">        <span class="type">Thread</span>  <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是守护线程&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//设置为守护线程</span></span><br><span class="line">        aa.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        aa.start();</span><br><span class="line">        System.out.println(aa.isDaemon());</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">                saleticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;bb&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">                saleticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;cc&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                    </span><br></pre></td></tr></table></figure></code></pre></blockquote><h3 id="1-10-线程运行原理"><a href="#1-10-线程运行原理" class="headerlink" title="1.10 线程运行原理"></a>1.10 线程运行原理</h3><p>当一个线程运行时</p><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/image-20220602171149616.png" alt="image-20220602171149616"></p><p>线程上下文切换:时间片用完的线程的程序计数器会保存该线程运行的信息,然后cpu执行其他线程,等到线程切换回来时会继续运行,</p><p><img src="F:\Java_note\java笔记\img\image-20220602184711296.png" alt="image-20220602184711296"></p><p><strong>栈和栈帧</strong></p><blockquote><p>JVM是由堆,栈,方法区组成,其中栈内存就是分配给线程使用的,每个线程启动后,虚拟机就会分配一块栈内存给他</p><ul><li>每个栈由多个栈帧组成,对应着每个方法调用时所占的内存</li><li>每个线程只能有一个活动栈帧,对应正在执行的方法</li></ul></blockquote><p><strong>栈帧</strong></p><blockquote><p>栈帧包括局部变量,操作数栈,动态链接,方法返回值</p></blockquote><h2 id="2-锁机制"><a href="#2-锁机制" class="headerlink" title="2.锁机制"></a>2.锁机制</h2><p><strong>临界区 Critical Section</strong></p><blockquote><p><strong>定义</strong> 多个线程对共享资源有读写操作,存在这个共享资源的代码块叫做临界区</p><ol><li>一个程序运行多个线程本身是没有问题的问题出在多个线程访问共享资源</li><li>多个线程读共享资源其实也没有问题在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li><li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong></li></ol></blockquote><p><strong>竞态条件 Race Condition</strong></p><blockquote><p>多个线程在临界区内执行，由于代码的<strong>执行序列</strong>不同而导致结果无法预测，称之为发生了竞态条件</p></blockquote><h3 id="2-1-同步与异步"><a href="#2-1-同步与异步" class="headerlink" title="2.1 同步与异步"></a>2.1 同步与异步</h3><blockquote><p><strong>同步</strong>:需要等到结果返回才能继续运行是同步</p><p><strong>异步</strong>:不需要等待结果返回就可以运行,就是异步(多线程)</p><p>注:同步在多线程中还有另一层意思,就是让多个线程步调一致</p></blockquote><h3 id="2-2线程同步机制"><a href="#2-2线程同步机制" class="headerlink" title="2.2线程同步机制"></a>2.2线程同步机制</h3><blockquote><p>在多线程操作时,一些敏感数据不允许在同一时刻本多个线程访问,因此需要使用线程<strong>同步访问技术</strong>,保证在任何同一时刻,最多只有一个线程访问,保证数据完整</p><p>线程同步也可以理解为:当一个线程对某内存进行操作时,其他线程不允许对该内存操作,直到该线程访问结束.</p></blockquote><h3 id="2-3-synchronized和lock"><a href="#2-3-synchronized和lock" class="headerlink" title="2.3 synchronized和lock"></a>2.3 synchronized和lock</h3><p><strong>(保证了临界区的原子性)</strong></p><table><thead><tr><th align="center">synchronized</th><th align="center">synchronized是java中的关键字,是用内置语言实现的</th><th align="center">synchronized发生异常会自动释放锁</th><th align="center">不能,会一直等</th><th align="center">不行</th><th align="center"></th></tr></thead><tbody><tr><td align="center"><strong>lock</strong></td><td align="center"><strong>lock是个接口</strong></td><td align="center"><strong>lock发生异常不会主动释放,因此尽量使用try,catch,finally</strong></td><td align="center"><strong>lock可以让等待锁的线程响应中断</strong></td><td align="center"><strong>lock可以知道有没有获得锁</strong></td><td align="center"><strong>性能更高</strong></td></tr></tbody></table><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h4><blockquote><p>是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</p><ol><li><p>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修饰代码块</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.ticket = ticket - <span class="number">1</span>;</span><br><span class="line">                System.out.println(ticket);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没票了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//synchronized修饰方法 锁对象为this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.ticket = ticket - <span class="number">1</span>;</span><br><span class="line">            System.out.println(ticket);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没票了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；同上</p></li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//synchronized修饰静态方法 锁对象为本类.class</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">descl</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">dell</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (share.class)&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><pre><code>4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</code></pre></blockquote><h4 id="2-3-1线程八锁"><a href="#2-3-1线程八锁" class="headerlink" title="2.3.1线程八锁"></a>2.3.1线程八锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.加锁成先1后2或先2后1</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            n1.a();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            n1.b();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.和上面一样但是a睡了一会因此2 1s后1,或者1 1s后2</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                n1.a();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            n1.b();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.由于c没有加锁因此最多就是3和2互相当第一个且3当第一个概率大 而2和1会因为加锁交替执行</span></span><br><span class="line"><span class="comment">//故:3/2 1s后1</span></span><br><span class="line"><span class="comment">//或者3 1s后12</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.c(); &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.创建了两个对象,且每个对象的锁对象都是this,因此不构成锁</span></span><br><span class="line"><span class="comment">//2 1s后1(1会休眠1s不存在1先打印)</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">        <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.一样一个锁对象是.class一个是this不是同一个锁对象</span></span><br><span class="line"><span class="comment">//2 1s后1</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            n1.a();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            n1.b();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6.都是.class因此要么a先执行要么b</span></span><br><span class="line"><span class="comment">//1s后1,2或者2 1s后1</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//7.一个是.class一个是this并且创建了两个对象</span></span><br><span class="line"><span class="comment">//2 ls后1</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">        <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8..class文件全局只有一个,尽管创建了两个对象 但是两个对象的锁都是Number.class</span></span><br><span class="line"><span class="comment">//1s后1,2或者2 1s后1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line"> <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2线程安全性分析"><a href="#2-3-2线程安全性分析" class="headerlink" title="2.3.2线程安全性分析"></a>2.3.2线程安全性分析</h4><blockquote><p><strong>成员变量和静态变量是否线程安全?</strong></p><ol><li><p>如果没有共享,则线程安全(没有其他线程进行读写操作)</p></li><li><p>被共享了分为两种状态</p><ol><li>读 安全</li><li>写 不安全</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjc.study.day67;</span><br><span class="line">                                                                                                </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line">                                                                                                </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadSafe</span> <span class="variable">threadSafe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSafe</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            threadSafe.method1();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            threadSafe.method1();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line">                                                                                                </span><br><span class="line">    &#125;</span><br><span class="line">                                                                                                </span><br><span class="line">&#125;</span><br><span class="line">                                                                                                </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//目前的理解是上下文切换时add操作进行到一般然后他知道执行完要将size置为1而另一个线程的add也执行完了本来应该是2但是第一个线程保存的是1因此最后size为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                                                                                                </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">                                                                                                </span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">                                                                                                </span><br><span class="line">    &#125;</span><br><span class="line">                                                                                                </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;method3:&quot;</span>+list.size());</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">                                                                                                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p><strong>局部变量是否安全</strong></p><ol><li><p>局部变量是线程安全的</p></li><li><p>局部变量引用对象不安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops1</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">           <span class="type">ThreadSafeSon</span> <span class="variable">threadSafe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSafeSon</span>();</span><br><span class="line">           <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">               threadSafe.method1();</span><br><span class="line">           &#125;);</span><br><span class="line">           thread.start();</span><br><span class="line">           <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">               threadSafe.method1();</span><br><span class="line">           &#125;);</span><br><span class="line">           thread2.start();</span><br><span class="line">       &#125;</span><br><span class="line">                                                                                                   </span><br><span class="line">   &#125;</span><br><span class="line">                                                                                                   </span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">               method2(list);</span><br><span class="line">               method3(list);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">                                                                                                   </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(List list)</span> &#123;</span><br><span class="line">           list.add(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">                                                                                                   </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(List list)</span> &#123;</span><br><span class="line">           list.remove(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">                                                                                                   </span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">ThreadSafeSon</span> <span class="keyword">extends</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">       <span class="comment">//按道理是局部变量应该不会导致线程不安全,但是其实相当于父类list已经创建好了,子类用的父类的</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(List list)</span> &#123;</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">               list.remove(<span class="number">0</span>);</span><br><span class="line">           &#125;).start();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">### <span class="number">2.4</span>  活跃性</span><br><span class="line"></span><br><span class="line">#### <span class="number">2.4</span><span class="number">.1</span>死锁</span><br><span class="line"></span><br><span class="line">**定义**:多个线程进入阻塞状态,同时一个线程或者多个线程争抢统一资源导致程序无法运行结束</span><br><span class="line"></span><br><span class="line">**解决方法**：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 获取锁的顺序都相同，大家按照相同顺序加锁就可以避免</span><br><span class="line"><span class="number">2.</span> </span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">package</span> com.zjc.study.Stream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现死锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">die</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁1需要资源1和资源2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">suo1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object1) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;锁1正常执行了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁2要资源2和资源1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">suo2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object2) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;锁2正常执行了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops13</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">die</span> <span class="variable">die</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">die</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            die.suo1();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            die.suo2();</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===============================</span><br><span class="line">F:\Java_note\code\Study&gt; jps <span class="comment">//查看正在运行的线程的id</span></span><br><span class="line"><span class="number">14832</span> Launcher</span><br><span class="line"><span class="number">14180</span> </span><br><span class="line"><span class="number">16404</span> Jps</span><br><span class="line"><span class="number">16392</span> Ops13</span><br><span class="line">PS F:\Java_note\code\Study&gt; jstack <span class="number">16392</span> <span class="comment">//查看是否存在死锁，报错太长了没办法展示</span></span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br><span class="line"><span class="comment">//也可以用 jconsole工具</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="2-4-2活锁"><a href="#2-4-2活锁" class="headerlink" title="2.4.2活锁"></a>2.4.2活锁</h4><blockquote><p><strong>定义：</strong>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束，就是又没报错，但是就是执行不完</p><p><strong>解决</strong>：时间交错开就好了，改变线程休眠时间使其不统一就行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjc.study.day612;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops3</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-4-3饥饿"><a href="#2-4-3饥饿" class="headerlink" title="2.4.3饥饿"></a>2.4.3饥饿</h4><blockquote><p><strong>定义：</strong>程序没有问题，但是就是其中几个线程一直能获取到锁，另外几个线程一直拿不到。</p></blockquote><h4 id="2-4-4ReetrantLock-重点"><a href="#2-4-4ReetrantLock-重点" class="headerlink" title="2.4.4ReetrantLock(重点)"></a>2.4.4<strong>ReetrantLock(重点)</strong></h4><blockquote><p><strong>可重入锁</strong>:进去上锁,出来解锁.可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁<br>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住(对一个对象反复加锁)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="comment">//可重入锁,不会被挡住</span></span><br><span class="line">        <span class="comment">//不可重入锁 会被挡住进不到第二层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ol><li><p>可中断<strong>lock.lockInterruptibly()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops4</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;尝试获得锁&quot;</span>);</span><br><span class="line">                <span class="comment">//如果没有竞争就会是普通的lock</span></span><br><span class="line">                <span class="comment">//如果有竞争则进入阻塞队列,可以被其他线程是动用Interrupt()打断</span></span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                log.debug(<span class="string">&quot;没有获得锁&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="comment">//有竞争,因此t1得不到锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//避免让其一直等待</span></span><br><span class="line">        t1.interrupt();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以设置超时时间<strong>lock.tryLock()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjc.study.day612;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops5</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">            <span class="comment">//tryLock()会判断是否可以得到锁得到就进返回true得不到就不进返回false</span></span><br><span class="line">            <span class="comment">//lock.tryLock(1, TimeUnit.MILLISECONDS) 也可以传入时间 等待一段时间看是否可以获得锁也可以使用Interrupt()唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (!lock.tryLock()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获取立刻失败，返回&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以设置公平锁(先入先得锁)</p><ol><li>ReentrantLock()默认是不公平的 </li><li>一般不用公平锁,降低并发度,用tryLock()好一些</li></ol></li><li><p>支持多个条件变量</p><ol><li><p>synchronized 中也有条件变量，可以通过建立多个锁对象来实现,当条件不满足时进入 waitSet 等待</p><p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比synchronized 是那些不满足条件的线程都在一间休息室等消息,而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤<br>醒</p></li><li><p><strong>使用要点</strong>：</p><ul><li>await 前需要获得锁</li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjc.study.day612;</span><br><span class="line">                                                                                                                                    </span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line">                                                                                                                                    </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line">                                                                                                                                    </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line">                                                                                                                                    </span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ops6</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//定义吸烟室</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">smokeCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">//定义吃饭室</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">eatCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasCigrette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasBreadfast</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                                                                                                                                    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                                                                                                                                    </span><br><span class="line">                <span class="keyword">while</span> (!hasCigrette) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;没有烟,&#123;&#125;无法工作&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">                    <span class="comment">//去吸烟室等待</span></span><br><span class="line">                    smokeCondition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;拿到烟了,&#123;&#125;可以工作&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                                                                                                                                    </span><br><span class="line">                <span class="keyword">while</span> (!hasBreadfast) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;没有早餐,&#123;&#125;无法工作&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">                    <span class="comment">//去吃饭室等待</span></span><br><span class="line">                   eatCondition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;有早餐,&#123;&#125;可以工作&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        sendsmoke();</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        sendmeal();</span><br><span class="line">    &#125;</span><br><span class="line">                                                                                                                                    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendsmoke</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            hasCigrette = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//唤醒吸烟室的线程,用signal()唤醒</span></span><br><span class="line">            smokeCondition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                                                                                                                                    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendmeal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            hasBreadfast = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//唤醒吃饭室的线程,用signal()唤醒</span></span><br><span class="line">            eatCondition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></blockquote><blockquote><p><strong>lock基本使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建锁 lock为借口需要借助其实现类 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.ticket = ticket - <span class="number">1</span>;</span><br><span class="line">          System.out.println(ticket);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;没票了&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-5-释放锁"><a href="#2-5-释放锁" class="headerlink" title="2.5 释放锁"></a>2.5 释放锁</h3><blockquote><p><strong>会释放锁</strong></p><ol><li>同步代码块程序正常结束</li><li>当同步代码块同步方法中有break,return等返回语句</li><li>程序执行时出现异常时</li><li>使用wait方法,线程会暂停并且,会释放锁</li></ol></blockquote><blockquote><p><strong>不会释放锁</strong></p><ol><li>sleep(),yield()方法不会释放锁</li><li>线程挂起 suspend()和resume(),已经弃用了.</li></ol></blockquote><h3 id="2-6-sleep与wait区别"><a href="#2-6-sleep与wait区别" class="headerlink" title="2.6 sleep与wait区别"></a>2.6 sleep与wait区别</h3><table><thead><tr><th align="center">sleep</th><th align="center">sleep为Thread类中的静态方法,需要Thread.sleep()调用,底层是用c++实现的(native)</th><th>sleep任何地方可以用</th><th align="center">sleep不归还锁</th></tr></thead><tbody><tr><td align="center"><strong>wait</strong></td><td align="center"><strong>wait为Object类提供的方法,可以直接使用(必须有锁对象objetc)</strong></td><td><strong>wait只有同步代码块中可以使用</strong></td><td align="center"><strong>wait休眠时会归还锁对象</strong></td></tr></tbody></table><blockquote><ul><li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li><li>BLOCKED 和 WAITING 的线程都处于阻塞状态(五种状态的阻塞,计算机底层的阻塞不是六种状态的阻塞)，不占用 CPU 时间片</li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争</li></ul><p><strong>BLOCKED为正在等待锁的线程,在EntryList中排序等待锁,WAITING 是进入 WaitSet 变为 WAITING 状态</strong></p></blockquote><blockquote><p><strong>主要方法:</strong></p><p>objetc.wait()</p><p>objetc.notify()</p><p><strong>如果同时有多个同时休眠,被notify()会随机抽一个唤醒</strong></p><p>objetc. notifyAll()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//wait和notifyAll使用时的正确姿势</span></span><br><span class="line"><span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line"><span class="keyword">while</span>(条件成立)&#123;</span><br><span class="line">     <span class="comment">//干活   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一个线程</span></span><br><span class="line"><span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">object.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-7多线程优点"><a href="#2-7多线程优点" class="headerlink" title="2.7多线程优点"></a>2.7多线程优点</h3><blockquote><p>优点提高效率</p><p><strong>结论</strong></p><ol><li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用cpu ，不至于一个线程总占用 cpu，别的线程没法干活</li><li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分,也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li><li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</li></ol></blockquote><h3 id="2-8-synchronized原理进阶"><a href="#2-8-synchronized原理进阶" class="headerlink" title="2.8 synchronized原理进阶"></a>2.8 synchronized原理进阶</h3><h4 id="2-8-1-Monitor-管程"><a href="#2-8-1-Monitor-管程" class="headerlink" title="2.8.1 Monitor(管程)"></a>2.8.1 Monitor(管程)</h4><blockquote><p><strong>概念</strong>:Moinitor被翻译为监视器或者管程,每一个创建的Java对象都关联着一个Monitor对象,如果使用synchronized给对象上锁(重量级),该<strong>对象头</strong>的<strong>Mark Word</strong>中就被设置了指向Monitor的指针</p></blockquote><blockquote><p><strong>Java对象头(JVM会学)</strong></p><p>32位</p><p>Klass Word (32 bits)存放数据类型</p><p>Mark Word (32 bits)存放头</p><p>普通对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|--------------------------------------------------------------|</span><br><span class="line">| Object Header (64 bits) |</span><br><span class="line">|------------------------------------|-------------------------|</span><br><span class="line">| Mark Word (32 bits) | Klass Word (32 bits) |</span><br><span class="line">|------------------------------------|-------------------------|</span><br></pre></td></tr></table></figure><p>数组对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|---------------------------------------------------------------------------------|</span><br><span class="line">| Object Header (96 bits) |</span><br><span class="line">|--------------------------------|-----------------------|------------------------|</span><br><span class="line">| Mark Word(32bits) | Klass Word(32bits) | array length(32bits) |</span><br><span class="line">|--------------------------------|-----------------------|------------------------|</span><br></pre></td></tr></table></figure><p>Mark Word (32 bits)</p><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/image-20220608202233510.png" alt="image-20220608202233510"></p></blockquote><h4 id="2-8-2-锁的执行流程"><a href="#2-8-2-锁的执行流程" class="headerlink" title="2.8.2 锁的执行流程"></a>2.8.2 锁的执行流程</h4><blockquote><p>一个对象对应一个Monitor</p></blockquote><blockquote><p><strong>锁的执行流程</strong></p><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/%E9%94%81%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="image-20220609111706222"></p><p><strong>注意事项</strong>:</p><ol><li>synchronized 必须进入同一个Moinitor对象才会执行上述流程</li><li>不加synchronized的对象不会关联管程,不遵从上述流程</li></ol></blockquote><h4 id="2-8-3轻量级锁"><a href="#2-8-3轻量级锁" class="headerlink" title="2.8.3轻量级锁"></a>2.8.3轻量级锁</h4><blockquote><p><strong>使用场景</strong>:多个线程访问,但是访问时间岔开(没有竞争)</p><p><strong>区别</strong>:轻量级锁Object不会申请Monitor锁</p><p><strong>步骤</strong></p><ol><li>线程创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</li></ol><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E6%AD%A5%E9%AA%A41.png" alt="image-20220609155236435"></p><ol start="2"><li><p>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E6%AD%A5%E9%AA%A42.png" alt="image-20220609153247280"></p><ol start="3"><li><p>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00(没有锁是01,00代表轻量级锁) ，表示由该线程给对象加锁，这时图示如下</p><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E6%AD%A5%E9%AA%A44.png" alt="image-20220609153648574"></p></li><li><p>如果 <strong>cas 失败</strong> ，有两种情况</p><ol><li><p>已经有别的线程替换过了,持有了轻量级锁,表明有竞争了,进入<strong>锁膨胀</strong></p></li><li><p>如果是自己线程又执行了 synchronized<strong>锁重入</strong>，那么再添加一条 Lock Record 作为重入的计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object)&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(Object)&#123;</span><br><span class="line">        <span class="comment">//这其实是有点脱裤子放屁的感觉,但是难免会写出这样的代码</span></span><br><span class="line">        <span class="comment">//当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</span></span><br><span class="line">        <span class="comment">//当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</span></span><br><span class="line">         <span class="number">1.</span>成功，则解锁成功</span><br><span class="line">             <span class="number">2.</span>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</span><br><span class="line">                                                                                                                                                                                                                                                   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/%E9%94%81%E9%87%8D%E5%85%A5.png" alt="image-20220609154438169"></p></li></ol></li></ol></li></ol></blockquote><h4 id="2-8-4锁膨胀"><a href="#2-8-4锁膨胀" class="headerlink" title="2.8.4锁膨胀"></a>2.8.4锁膨胀</h4><blockquote><p><strong>场景</strong></p><p>已知,轻量级锁只能用于多线程时各个线程利用时间不冲突,当冲突发生时(一个线程已经加了轻量级锁,另一个还线程还想进行CAS操作),证明轻量级锁在这个场景不合适,这时就需要进行锁膨胀,<strong>将轻量级锁变为重量级锁</strong></p><p><strong>步骤:</strong></p><ol><li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li></ol><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/%E9%94%81%E8%86%A8%E8%83%80.png" alt="image-20220609155714016"></p><ol start="2"><li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ul><li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址</li><li>然后自己(这里指的是后来的线程)进入 Monitor 的 EntryList BLOCKED</li></ul></li><li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li></ol></blockquote><h4 id="2-8-4-自旋优化"><a href="#2-8-4-自旋优化" class="headerlink" title="2.8.4 自旋优化"></a>2.8.4 自旋优化</h4><blockquote><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。(多个CPU优势大,单个CPU自旋浪费资源)</p><p>即:当线程1请求访问同步代码块遇到别的线程已经获得锁对象时(monitor里面的Markdown状态码被修改),线程1不会立刻进入阻塞状态,而是会重复执行几次看能否获得锁对象,可以就继续执行了,如果失败会进入阻塞状态.</p><ul><li>自旋会占用CPU时间,单核CPU自旋有点浪费,多核CPU自旋可以提高效率</li><li>java6后自旋就是自适应的,如果该对象自旋成功率高就多自旋,成功率第九少自旋甚至不自旋</li><li>java7后不能控制是否自旋</li></ul></blockquote><blockquote><ol><li>自旋成功情况</li></ol><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/%E8%87%AA%E6%97%8B%E6%88%90%E5%8A%9F.png" alt="image-20220609160129043"></p><ol start="2"><li><p>自旋失败</p><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/%E8%87%AA%E6%97%8B%E5%A4%B1%E8%B4%A5.png" alt="image-20220609160611563"></p></li></ol></blockquote><h4 id="2-8-5偏向锁"><a href="#2-8-5偏向锁" class="headerlink" title="2.8.5偏向锁"></a>2.8.5偏向锁</h4><blockquote><p>场景:大家觉得轻量级锁虽然已经很简单了(较重量级锁取消了申请Mointor锁),但是还是有改进的地方</p><p>Java 6 中引入了偏向锁来做进一步优化：**只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS(比较并交换)**。以后只要不发生竞争，这个对象就归该线程所有.</p><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/%E5%81%8F%E5%90%91%E9%94%81%E6%B5%81%E7%A8%8B.png" alt="image-20220609163640382"></p><p><strong>一个对象创建时：</strong></p><ul><li><p>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 thread、epoch、age 都为 0</p></li><li><p>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 -XX:BiasedLockingStartupDelay&#x3D;0 来禁用延迟</p></li><li><p>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">                                                    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="comment">// 添加虚拟机参数 -XX:BiasedLockingStartupDelay=0 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">ClassLayout</span> <span class="variable">classLayout</span> <span class="operator">=</span> ClassLayout.parseInstance(d);</span><br><span class="line">                                                    </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;synchronized 前&quot;</span>);</span><br><span class="line">            System.out.println(classLayout.toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">            <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;synchronized 中&quot;</span>);</span><br><span class="line">                System.out.println(classLayout.toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;synchronized 后&quot;</span>);</span><br><span class="line">            System.out.println(classLayout.toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">                                                    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==================</span><br><span class="line">输出</span><br><span class="line"><span class="number">11</span>:08:<span class="number">58.117</span> c.TestBiased [t1] - <span class="keyword">synchronized</span> 前 </span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span> </span><br><span class="line"><span class="number">11</span>:08:<span class="number">58.121</span> c.TestBiased [t1] - <span class="keyword">synchronized</span> 中 </span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011111</span> <span class="number">11101011</span> <span class="number">11010000</span> <span class="number">00000101</span> </span><br><span class="line"><span class="number">11</span>:08:<span class="number">58.121</span> c.TestBiased [t1] - <span class="keyword">synchronized</span> 后 </span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011111</span> <span class="number">11101011</span> <span class="number">11010000</span> <span class="number">00000101</span> </span><br></pre></td></tr></table></figure><p>**注:**处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</p></li></ul></blockquote><blockquote><p><strong>偏向锁的撤销</strong></p><ol><li>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销<ul><li>轻量级锁会在锁记录中记录 hashCode</li><li>重量级锁会在 Monitor 中记录 hashCode</li><li>在调用 hashCode 后使用偏向锁，记得去掉 -XX:-UseBiasedLocking</li></ul></li><li>其它线程使用对象<ul><li>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</li></ul></li><li>调用 wait&#x2F;notify</li><li>批量重偏向<ul><li>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象<br>的 Thread ID</li><li>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至<br>加锁线程</li></ul></li><li>批量撤销 <ul><li>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象<br>都会变为不可偏向的，新建的对象也是不可偏向的</li></ul></li></ol></blockquote><h4 id="2-8-6锁消除"><a href="#2-8-6锁消除" class="headerlink" title="2.8.6锁消除"></a>2.8.6锁消除</h4><blockquote><p>当JVM发现不存在多线程时会自动取消锁机制,正常访问</p></blockquote><h4 id="2-8-7-锁粗化"><a href="#2-8-7-锁粗化" class="headerlink" title="2.8.7 锁粗化"></a>2.8.7 锁粗化</h4><blockquote><p>相同对象多次加锁，导致线程发生多次重入，可以使用锁粗化方式来优化，这不同于之前讲的细分锁的粒度</p></blockquote><h3 id="2-9多把锁"><a href="#2-9多把锁" class="headerlink" title="2.9多把锁"></a>2.9多把锁</h3><blockquote><p>**定义:**如果多个需要加锁的代码块业务互不相干可以使用多把不想干所,<strong>增加并发度</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 睡觉和学习是两个不相干的业务，但是因为其加了同一巴锁导致其不能同时运行</span></span><br><span class="line"><span class="comment"> * 效率低，并发度低</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigRoom</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;sleeping 2 小时&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;study 1 小时&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigRoom</span> &#123;</span><br><span class="line">    <span class="comment">//sleep管sleep相关业务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">sleep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">//study管study相关业务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">study</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sleep) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;sleeping 2 小时&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (study) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;study 1 小时&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="3-共享模型之内存"><a href="#3-共享模型之内存" class="headerlink" title="3.共享模型之内存"></a>3.共享模型之内存</h2><h3 id="3-1java内存模型"><a href="#3-1java内存模型" class="headerlink" title="3.1java内存模型"></a>3.1java内存模型</h3><p><strong>定义</strong>:JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。</p><blockquote><p>JMM 体现在以下几个方面</p><ul><li>原子性 保证指令不会受到线程上下文切换的影响</li><li>可见性 保证指令不会受 cpu 缓存的影响</li><li>有序性 保证指令不会受 cpu 指令并行优化的影响</li></ul><p><strong>synchronized可以保证原子性可见性和有序性(成员变量完全交给synchronized管理时可以保证有序性,即除了synchronized代码块里面一外不存在该成员变量的使用,具体可看单例懒汉模式中举例)</strong></p></blockquote><h3 id="3-2原子性"><a href="#3-2原子性" class="headerlink" title="3.2原子性"></a>3.2原子性</h3><blockquote><p><strong>定义</strong>:保证指令不会受到线程上下文切换的影响</p><p>场景:买票</p></blockquote><h3 id="3-3可见性-volatile"><a href="#3-3可见性-volatile" class="headerlink" title="3.3可见性( volatile)"></a>3.3可见性( volatile)</h3><blockquote><p><strong>现象</strong>:退不出的循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"> <span class="keyword">while</span>(run)&#123;</span><br><span class="line"> <span class="comment">// ....</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> t.start();</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> run = <span class="literal">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果在前面示例的死循环中加入 System.out.println()  会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？</span></span><br><span class="line"><span class="comment">//答  System.out.println() 底层加了synchronized()</span></span><br></pre></td></tr></table></figure><p>原理:</p><ol><li><p>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</p><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/image-20220612203708284.png" alt="image-20220612203708284"></p></li><li><p>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</p></li></ol><p>   <img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/image-20220612203804044.png" alt="image-20220612203804044"></p><ol start="3"><li><p>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</p><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/image-20220612204644843.png" alt="image-20220612204644843"></p><p>解决方法:</p><ol><li><p>volatile（易变关键字）:它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取<br>它的值，线程操作 volatile 变量都是直接操作主存</p></li><li><p>使用synchronized也可以</p><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/image-20220612204922827.png" alt="image-20220612204922827"></p></li></ol></li></ol></blockquote><h3 id="3-4原子性和可见性区别"><a href="#3-4原子性和可见性区别" class="headerlink" title="3.4原子性和可见性区别"></a>3.4原子性和可见性区别</h3><blockquote><p>原子性:多个线程操作同一个变量时,是否会因为上下文切换造成错误(买票问题)</p><p>可见性:一个线程对变量的修改另一个线程是否可以看到看到(上文有举例)</p><p>即使线程保证了可见性,不一定能保证原子性,因为线程与线程的上下文切换时机是不一定的,有可能在你读完之后发生了上下文切换,等切换回来时值已经变了.因此保证可见性不一定能保证原子性,要保证原子性还是加锁吧.<strong>保证原子性必须加锁</strong></p><p><strong>在进入synchronized锁时，会去主存中读取此时的最新数据，退出锁时将当前更新刷新到主存中。</strong></p><p>**lock的加锁和释放锁是对内部字段state的修改，而state是一个volatile修饰的变量 ** 但是其锁中间的内容不行(与synchronized不同)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure><p><strong>synchronized可以保证原子性和可见性,但是其属于重量级操作</strong></p></blockquote><h3 id="3-5有序性-volatile"><a href="#3-5有序性-volatile" class="headerlink" title="3.5有序性(volatile)"></a>3.5有序性(volatile)</h3><p><strong>JVM会在不影响正确性的前提下,可以调整语句的执行顺序</strong></p><p>指令重排序在单线程情况下不会有影响,但是在多线程情况下会产生问题,如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 线程1 执行此方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">           r.r1 = num + num;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           r.r1 = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 线程2 执行此方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">       num = <span class="number">2</span>;</span><br><span class="line">       ready = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在不出问题的情况下最后r1的值要么是1要么是4,但是真正运行时会发现有可能出现0.那么0是怎么来的</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">      num = <span class="number">2</span>;</span><br><span class="line">      ready = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>有可能在jvm中重排序成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">      ready = <span class="literal">true</span>;</span><br><span class="line">      num = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这时在多线程情况下就会产生0</p></blockquote><p>解决:在变量上加volatile</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 线程1 执行此方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">           r.r1 = num + num;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           r.r1 = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 线程2 执行此方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">       num = <span class="number">2</span>;</span><br><span class="line">       ready = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-volatile保证可见性和有序性原理"><a href="#3-6-volatile保证可见性和有序性原理" class="headerlink" title="3.6 volatile保证可见性和有序性原理"></a>3.6 volatile保证可见性和有序性原理</h3><p><strong>volatile</strong>只能保证本线程的代码的读和写,因此无法解决原子性</p><p><strong>保证可见性</strong></p><blockquote><p><strong>volatile</strong>底层是内存屏障</p><ul><li>对volatile变量执行写操作<strong>后</strong>会加入写屏障,保证变量同步到主存</li><li>对volatile变量执行读操作<strong>前</strong>会加入读屏障,保证从主存中读取变量</li></ul><ol><li><p>volatile在对变量执行写操作后会加入写屏障(将变量同步到主存)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line"> num = <span class="number">2</span>;<span class="comment">//因为ready是volatile 赋值带写屏障 捎带着num也会同步到主存</span></span><br><span class="line"> ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障 </span></span><br><span class="line"> <span class="comment">// 写屏障 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>volatile在对变量执行读操作后会加入读屏障</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">     <span class="comment">// 读屏障</span></span><br><span class="line">     <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">     <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">         r.r1 = num + num;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         r.r1 = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p><strong>保证有序性</strong></p><blockquote><ol><li><p>volatile在对变量执行写操作后会加入写屏障,写屏障也可以保证写屏障以前的代码不会重排到写屏障后面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line"> num = <span class="number">2</span>;<span class="comment">//因为ready是volatile 赋值带写屏障 捎带着num也会同步到主存</span></span><br><span class="line"> ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障 </span></span><br><span class="line"> <span class="comment">// 写屏障 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>volatile在对变量执行读操作后会加入读屏障,读屏障防止读屏障后面的代码排到读屏障前面去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">     <span class="comment">// 读屏障</span></span><br><span class="line">     <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">     <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">         r.r1 = num + num;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         r.r1 = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="3-7happens-before"><a href="#3-7happens-before" class="headerlink" title="3.7happens-before"></a>3.7happens-before</h3><p>这块一共七条规则:</p><ol><li><p>假如多个线程共用一把锁m,线程解锁m之前对变量做写操作,对以m为锁的其他线程对该变量的读具有可见性</p><p>即你第二个线程能进去证明第一个线程已经写完了,因此肯定能保证可见性,如果没加锁,则不一定谁先执行,就不知道有没有读出来了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ops1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//这块如果用wait有可能造成两个0因为wait会释放锁</span></span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                a = <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;);</span><br><span class="line">        t3.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//===========================================</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>使用volatile修饰的变量的写,对以后执行的其他线程的对变量的读具有可见性</p><p>这个不用解释了,由于写屏障,导致加了volatile的变量执行写操作时会写到主存</p></li><li><p>线程结束前对变量的写,对其他线程得知他结束后的读可见性</p><p>这个也不用解释,执行完的写,肯定是写到主存了,而不是临时储存到高速缓存</p></li><li><p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过<br>t2.interrupted 或 t2.isInterrupted）</p><p><strong>其实相当于同步了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//自己肯定知道t2被打断了</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            x = <span class="number">10</span>;</span><br><span class="line">            t2.interrupt();</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="comment">//这里主线程也知道t2被打断了</span></span><br><span class="line">        <span class="keyword">while</span> (!t2.isInterrupted()) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</p></li><li><p>具有传递性,如果x对y可见,并且 y对z可见,那么有x对z可见,配合 volatile 的防指令重排，有下面的例子</p></li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> y;</span><br><span class="line">   <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           y = <span class="number">10</span>;</span><br><span class="line">           x = <span class="number">20</span>;</span><br><span class="line">       &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="comment">// x=20 对 t2 可见, 同时 y=10 也对 t2 可见</span></span><br><span class="line">           System.out.println(x);</span><br><span class="line">       &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3-8线程安全单例习题"><a href="#3-8线程安全单例习题" class="headerlink" title="3.8线程安全单例习题"></a>3.8线程安全单例习题</h3><p>  单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用getInstance）时的线程安全，并思考注释中的问题</p><ul><li>饿汉式：类加载就会导致该单实例对象被创建</li><li>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题1：为什么加final</span></span><br><span class="line"><span class="comment">//final怕子类覆盖方法破坏单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 问题3：为什么设置为私有? 是否能防止反射创建新的实例?</span></span><br><span class="line">    <span class="comment">//不能 反射太强了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全?</span></span><br><span class="line">  <span class="comment">//没有 静态成员变量可以在类加载时期进行,是线程安全的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由</span></span><br><span class="line">    <span class="comment">//1.提供更好的封装性</span></span><br><span class="line">    <span class="comment">//2.对单例对象更多的控制</span></span><br><span class="line">    <span class="comment">//可以支持泛型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例</span></span><br><span class="line"><span class="comment">//在序列化生成对象时如果发现类中有readResolve方法就会使用readResolve来生成对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-共享模式之无锁"><a href="#4-共享模式之无锁" class="headerlink" title="4.共享模式之无锁"></a>4.共享模式之无锁</h2><h3 id="4-1引入-实现多线程取钱查看余额"><a href="#4-1引入-实现多线程取钱查看余额" class="headerlink" title="4.1引入:实现多线程取钱查看余额"></a>4.1引入:实现多线程取钱查看余额</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jucstudy.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountSafe</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Account.demo(<span class="keyword">new</span> <span class="title class_">AccountSafe</span>(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意这里用的不是Integer而是AtomicInteger</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountSafe</span><span class="params">(<span class="type">int</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(balance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> balance.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> balance.get() - amount;</span><br><span class="line">            <span class="comment">//这句话的意思是我查的时候是pre执行后变成next你最后交换时候看一下有没有人改,值是不是还是pre如果是pre则变成next返回true,</span></span><br><span class="line">            <span class="comment">// 不然就返回false并且不做修改</span></span><br><span class="line">            <span class="keyword">if</span> (balance.compareAndSet(pre, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个工具类</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    Integer <span class="title function_">getBalance</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                account.withdraw(<span class="number">10</span>);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(account.getBalance()</span><br><span class="line">                + <span class="string">&quot; cost: &quot;</span> + (end - start) / <span class="number">1000_000</span> + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2CAS和volatile"><a href="#4-2CAS和volatile" class="headerlink" title="4.2CAS和volatile"></a>4.2CAS和volatile</h3><p>其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。</p><blockquote><p>其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。</p><p>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</p></blockquote><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/CAS%E6%97%A0%E9%94%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="image-20220703203540325"></p><p><strong>CAS底层的存储数据的部分用volatile修饰保证可见性</strong></p><blockquote><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/CAS%E5%BA%95%E5%B1%82value.png" alt="image-20220703204640599"></p><p>使用volatile仅保证共享变量的可见性,让其他线程看到最新的值,并不能解决原子性(同以前)</p><p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</p></blockquote><p><strong>为什么无锁效率更高</strong></p><blockquote><ol><li>无锁情况,即使重试失败,线程仍在飞速运行,而有锁(synchronized)经常会因为上下文切换,导致线程状态变换,发生上下文切换,代价比较大</li><li>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</li></ol></blockquote><p><strong>CAS的特点</strong></p><p><strong>CAS与volatile结合可以实现无锁并发,适用于线程数少,多核CPU的场景</strong></p><blockquote><ul><li>CAS是基于乐观锁的思想:(乐观锁不是锁),不怕别的线程修改共享变量,大不了我就等一会,等我机缘巧合下没人修改了我修改</li><li>synchronized是基于悲观锁的思想:担心别的线程修改共享变量,于是我加了一把锁,一旦我进去了就只能我修改</li><li>CAS体现无锁并发,无阻塞并发<ul><li>因为没有使用synchronized关键字,因此线程不会进入阻塞状态,可以提高效率</li><li>但是如果竞争激烈,可以想象会经过很多次重试,其实也影响效率</li><li>可以在cpu核心数多线程较少的情况下使用</li></ul></li></ul></blockquote><h3 id="4-3原子整数"><a href="#4-3原子整数" class="headerlink" title="4.3原子整数"></a>4.3原子整数</h3><p>JUC并发包提供了:</p><ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ul><p>以AtomicInteger为例:</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将普通的</span></span><br><span class="line">       <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">       <span class="comment">//++i</span></span><br><span class="line">       System.out.println(i.incrementAndGet());</span><br><span class="line">       <span class="comment">//i++</span></span><br><span class="line">       System.out.println(i.getAndIncrement());</span><br><span class="line">       <span class="comment">//i--</span></span><br><span class="line">       System.out.println(i.getAndDecrement());</span><br><span class="line">       <span class="comment">//--i</span></span><br><span class="line">       System.out.println(i.decrementAndGet());</span><br><span class="line">       <span class="comment">//先取值再加5</span></span><br><span class="line">       System.out.println(i.addAndGet(<span class="number">5</span>));</span><br><span class="line">       <span class="comment">//先加5再取值</span></span><br><span class="line">       System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line">       <span class="comment">//getAndUpdate相当于传一个参数且这个参数时自己本身</span></span><br><span class="line">       System.out.println(i.getAndUpdate(p-&gt;p+<span class="number">2</span>));</span><br><span class="line">       System.out.println(i.updateAndGet(p-&gt;p-<span class="number">2</span>));</span><br><span class="line">       <span class="comment">//getAndAccumulate 相当于传本身p以及x=10</span></span><br><span class="line">       System.out.println(i.getAndAccumulate(<span class="number">10</span>,(p,x)-&gt;p+x));</span><br><span class="line">       System.out.println(i.accumulateAndGet(<span class="number">10</span>,(p,x)-&gt;p+x));</span><br><span class="line">       System.out.println(i.get());</span><br></pre></td></tr></table></figure></blockquote><h3 id="4-4原子引用"><a href="#4-4原子引用" class="headerlink" title="4.4原子引用"></a>4.4原子引用</h3><p>即引用类型的原子操作</p><ul><li>AtomicReference</li><li>AtomicMarkableReference</li><li>AtomicStampedReference</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jucstudy.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试接口创建1000个线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    BigDecimal <span class="title function_">getBalance</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(DecimalAccount account)</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                account.withdraw(BigDecimal.TEN);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalAccountSafeCas</span> <span class="keyword">implements</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        DecimalAccount.demo(<span class="keyword">new</span> <span class="title class_">DecimalAccountSafeCas</span>(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10000&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    AtomicReference&lt;BigDecimal&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecimalAccountSafeCas</span><span class="params">(BigDecimal b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        b.accumulateAndGet(amount, (p, x) -&gt; p.subtract(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见问题ABA问题及解决"><a href="#常见问题ABA问题及解决" class="headerlink" title="常见问题ABA问题及解决"></a>常见问题ABA问题及解决</h3><ol><li><p>场景：共享值为A，线程3执行时取到的初值为A,线程1将A改成B,线程2将B改回了A,这时线程3做操作时发现共享值还是A,于是将A改成了C,但是我们要避免这种情况</p></li><li><p>解决:</p><blockquote><p><strong>AtomicStampedReference</strong>:加了个版本号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicStamped_Reference</span> &#123;</span><br><span class="line">    <span class="comment">//初始化时共享值值为a版本号为0</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; a = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="string">&quot;a&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;a:&#123;&#125;,a.stap:&#123;&#125;&quot;</span>,a.getReference(),a.getStamp());</span><br><span class="line">        other();</span><br><span class="line">        <span class="comment">//改为D版本号加1</span></span><br><span class="line">        a.compareAndSet(a.getReference(),<span class="string">&quot;d&quot;</span>,a.getStamp(), a.getStamp()+<span class="number">1</span>);</span><br><span class="line">        log.info(<span class="string">&quot;a:&#123;&#125;,a.stap:&#123;&#125;&quot;</span>,a.getReference(),a.getStamp());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//改为B版本号加1</span></span><br><span class="line">          a.compareAndSet(a.getReference(),<span class="string">&quot;b&quot;</span>,a.getStamp(), a.getStamp()+<span class="number">1</span>);</span><br><span class="line">          log.info(<span class="string">&quot;a:&#123;&#125;,a.stap:&#123;&#125;&quot;</span>,a.getReference(),a.getStamp());</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//改为C版本号加1</span></span><br><span class="line">            a.compareAndSet(a.getReference(),<span class="string">&quot;c&quot;</span>,a.getStamp(), a.getStamp()+<span class="number">1</span>);</span><br><span class="line">            log.info(<span class="string">&quot;a:&#123;&#125;,a.stap:&#123;&#125;&quot;</span>,a.getReference(),a.getStamp());</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AtomicMarkableReference</strong>与<strong>stamp</strong>类似它相当于不关心你修改了几次只关心你修没修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestABAAtomicMarkableReference</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">GarbageBag</span> <span class="variable">bag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GarbageBag</span>(<span class="string">&quot;内容1&quot;</span>);</span><br><span class="line">        <span class="comment">//创建 AtomicMarkableReference对象标记为true</span></span><br><span class="line">        AtomicMarkableReference&lt;GarbageBag&gt; a = <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>&lt;&gt;(bag, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">GarbageBag</span> <span class="variable">prev</span> <span class="operator">=</span> a.getReference();</span><br><span class="line">        log.info(<span class="string">&quot;最开始的内容:&#123;&#125;&quot;</span>, prev);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            bag.setDesc(<span class="string">&quot;设置新的内容&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (!a.compareAndSet(prev, bag, <span class="literal">true</span>, <span class="literal">false</span>))&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(bag.toString());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> a.compareAndSet(prev, <span class="keyword">new</span> <span class="title class_">GarbageBag</span>(<span class="string">&quot;空垃圾袋&quot;</span>), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;换了么？&quot;</span> + success);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工具类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GarbageBag</span> &#123;</span><br><span class="line">    String desc;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GarbageBag</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDesc</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString() + <span class="string">&quot; &quot;</span> + desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><h3 id="4-5原子数组"><a href="#4-5原子数组" class="headerlink" title="4.5原子数组"></a>4.5原子数组</h3><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger_Array</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(</span></span><br><span class="line"><span class="params">            //得到什么返回什么</span></span><br><span class="line"><span class="params">            Supplier&lt;T&gt; arraySupplier,</span></span><br><span class="line"><span class="params">            //一个函数式接口,传入需要的参数返回该参数经过操作后的值.本例题中用来返回数组长度</span></span><br><span class="line"><span class="params">            Function&lt;T, Integer&gt; lengthFun,</span></span><br><span class="line"><span class="params">            //同上只不过传入两个参数并且没有返回值</span></span><br><span class="line"><span class="params">            BiConsumer&lt;T, Integer&gt; putConsumer,</span></span><br><span class="line"><span class="params">            //同上只不过传入一个参数并且没有返回值</span></span><br><span class="line"><span class="params">            Consumer&lt;T&gt; printConsumer)</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">T</span> <span class="variable">array</span> <span class="operator">=</span> arraySupplier.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> lengthFun.apply(array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 每个线程对数组作 10000 次操作</span></span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    putConsumer.accept(array, j % length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ts.forEach(t -&gt; t.start()); <span class="comment">// 启动所有线程</span></span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); <span class="comment">// 等所有线程结束</span></span><br><span class="line">        printConsumer.accept(array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        demo(</span><br><span class="line">            <span class="comment">//传入数组</span></span><br><span class="line">                ()-&gt; <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="number">10</span>),</span><br><span class="line">            <span class="comment">//获取数组长度</span></span><br><span class="line">                (array) -&gt; array.length(),</span><br><span class="line">                <span class="comment">//array.getAndIncrement(index)对数组中的index元素加1</span></span><br><span class="line">                (array, index) -&gt; array.getAndIncrement(index),</span><br><span class="line">                array -&gt; System.out.println(array)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-6-字段更新器"><a href="#4-6-字段更新器" class="headerlink" title="4.6 字段更新器"></a>4.6 字段更新器</h3><p>类中的某个属性更新</p><ul><li>AtomicReferenceFieldUpdater &#x2F;&#x2F; 域 字段 &#x2F;&#x2F;引用类型的字段</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdate</li></ul><p><strong>注:要被修改的字段必须要volatile修饰不然会报错</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字段更新器测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String feild;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test5</span> <span class="variable">test5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test5</span>();</span><br><span class="line">        <span class="type">AtomicReferenceFieldUpdater</span> <span class="variable">fieldUpdater</span> <span class="operator">=</span> AtomicReferenceFieldUpdater.newUpdater(Test5.class, String.class, <span class="string">&quot;feild&quot;</span>);</span><br><span class="line">        fieldUpdater.compareAndSet(test5, <span class="literal">null</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(test5.feild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-原子累加器"><a href="#4-7-原子累加器" class="headerlink" title="4.7 原子累加器"></a>4.7 原子累加器</h3><p>就是做累加操作</p><p>底层创建多个累加单元，都进行累加，操作不同的共享变量，最后累加</p><p>性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p><ul><li><p>LongAdder</p></li><li><p>LongAccumulator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">adder</span> <span class="operator">=</span> adderSupplier.get();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 4 个线程，每人累加 50 万</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500000</span>; j++) &#123;</span><br><span class="line">                    action.accept(adder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(t -&gt; t.start());</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(adder + <span class="string">&quot; cost:&quot;</span> + (end - start) / <span class="number">1000_000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            demo(() -&gt; <span class="keyword">new</span> <span class="title class_">LongAdder</span>(), adder -&gt; adder.increment());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            demo(() -&gt; <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(), adder -&gt; adder.getAndIncrement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h4><p>其中cell为累加单元</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止缓存行伪共享</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line"></span><br><span class="line">    Cell(<span class="type">long</span> x) &#123;</span><br><span class="line">        value = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">cas</span><span class="params">(<span class="type">long</span> prev, <span class="type">long</span> next)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, valueOffset, prev, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略不重要代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/%E4%BC%AA%E5%85%B1%E4%BA%AB.png" alt="image-20220704202210954"></p><p><strong>线程访问时,一级缓存最快,最慢是内存</strong></p><p><strong>普通共享和伪共享</strong></p><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/%E6%99%AE%E9%80%9A%E5%85%B1%E4%BA%AB%E5%92%8C%E4%BC%AA%E5%85%B1%E4%BA%AB.png" alt="image-20220704203915188"></p><p>区别:</p><blockquote><p>前置知识:<br>    Cell是数组形式,在内存中存储是连续的,一个Cell为24字节,一个缓存行可以缓存2个Cell对象</p><p>普通共享:<br>    有两个线程,线程1对Cell0修改,线程2对Cell1修改,假如线程1先完成对Cell0的修改,这时会同步到内存,而线程2所在的核心也就需要将内存更新的情况同步到自己的缓存,同步后才能让线程2对Cell1做修改(无论谁先修改完成都是如此,修改完会导致对方的缓存失效)</p><p>伪共享:<br>    伪共享会给使用了伪共享注解的字段前后各加128字节大小的填充,这时CPU预读时,就不会将两个Cell放到同一缓存行,这样就保证了另一个核心的线程对cell修改时自己的缓存失效需要重新去内存读取的情况</p></blockquote><h3 id="4-8-Unsafe"><a href="#4-8-Unsafe" class="headerlink" title="4.8 Unsafe"></a>4.8 Unsafe</h3><p><strong>概述</strong></p><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得,<strong>CAS底层调用的就是Unsafe</strong></p><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/Unsafe%E6%BA%90%E7%A0%81.png" alt="image-20220704204922108"></p><h2 id="5共享模型之不可变"><a href="#5共享模型之不可变" class="headerlink" title="5共享模型之不可变"></a>5共享模型之不可变</h2><h3 id="5-1不可变类的使用"><a href="#5-1不可变类的使用" class="headerlink" title="5.1不可变类的使用"></a>5.1不可变类的使用</h3><ol><li><p>提出问题</p><blockquote><p>下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="string">&quot;1951-04-21&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*多线程情况下很大概率会报错(我电脑好像没出现过)*/</span></span><br></pre></td></tr></table></figure><p>当然这种可以通过加锁实现不报错,但是性能总归是不好的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (sdf)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="string">&quot;1951-04-21&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;).start();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>可以直接使用日期的不可变类<strong>DateTimeFormatter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, dtf.parse(<span class="string">&quot;1951-04-21&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;).start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></blockquote><p>**不可变:**如果一个对象在不能够改变其内部状态(属性),那么他就是线程安全的,都不能改了还不安全</p></li></ol><h3 id="5-2不可变类的设计"><a href="#5-2不可变类的设计" class="headerlink" title="5.2不可变类的设计"></a>5.2不可变类的设计</h3><p>以String举例</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//保护性拷贝</span></span><br><span class="line">    <span class="comment">//分配一个新的String，使其表示字符数组参数中当前包含的字符序列。</span></span><br><span class="line">    <span class="comment">//复制字符数组的内容;后续对字符数组的修改不会影响新创建的字符串。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[])</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p><strong>final</strong>的使用</p><ol><li><p>设置 final 变量的原理</p><p>final执行时会加写屏障,保证写屏障前的指令不会重排到写指令后,并且只能从主存中读取.同时发现 final 变量的赋值也会通过 putfield 指令来完成保证在其它线程读到它的值时不会出现为 0 的情况</p><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/final%E5%AD%97%E8%8A%82%E7%A0%81.png" alt="image-20220704221714307"></p></li><li><p>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。（先读对象的引用，后读final变量）编译器会在读final域操作的前面插入一个LoadLoad屏障</p></li></ol><p>类以及类中所有属性都使用了final修饰</p><ul><li>属性用final修饰,保证其是只读的不能修改</li><li>类被final修饰保证其不能被继承,子类不能重写其方法破坏其不可变</li></ul></li><li><p><strong>保护性拷贝</strong></p><p>以char转String为例:</p><p>​不会直接将传入的char数组直接转换成String,而是将char数组进行拷贝生辰新的char数组后,将新的char数组的值赋给String对象的value,<strong>防止传入的char数组中元素的改变导致String内容的改变</strong></p><p>​<strong>小贴士</strong>:jdk8及以前String底层是final char类型的数组,以后版本都改成final byte类型的数组,目的是节省空间,char导致了原本在String中一个字符就能表示的字符,必须用两个字符表示</p></li></ol></blockquote><h3 id="5-3无状态的设计"><a href="#5-3无状态的设计" class="headerlink" title="5.3无状态的设计"></a>5.3无状态的设计</h3><p><strong>因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】</strong></p><p>使用举例:<br>    在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这种没有任何成员变量的类是线程安全的</p><h2 id="6-共享模式之工具-线程池"><a href="#6-共享模式之工具-线程池" class="headerlink" title="6.共享模式之工具-线程池"></a>6.共享模式之工具-线程池</h2><h3 id="6-1线程池"><a href="#6-1线程池" class="headerlink" title="6.1线程池"></a>6.1线程池</h3><blockquote><p>拒绝策略接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">// 拒绝策略</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RejectPolicy</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(Test.BlockingQueue&lt;T&gt; queue, T task)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="comment">//定义任务队列</span></span><br><span class="line">    <span class="keyword">private</span> Test.BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line">    <span class="comment">//定义线程集合(里面放可以执行的线程)</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Work&gt; works = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeout;</span><br><span class="line">    <span class="comment">//时间单位</span></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line">    <span class="comment">//核心数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> coreSize;</span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coreSize     核心数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout      最久等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeUnit     时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queueCapcity 等待队列大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rejectPolicy 函数式接口 如果任务数大于核心数时加入队列应选择什么模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">(<span class="type">int</span> coreSize, <span class="type">long</span> timeout, TimeUnit timeUnit, <span class="type">int</span> queueCapcity,</span></span><br><span class="line"><span class="params">                      RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">        <span class="built_in">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="built_in">this</span>.taskQueue = <span class="keyword">new</span> <span class="title class_">Test</span>.BlockingQueue&lt;&gt;(queueCapcity);</span><br><span class="line">        <span class="built_in">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span></span><br><span class="line">        <span class="comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (works) &#123;</span><br><span class="line">            <span class="keyword">if</span> (works.size() &lt; coreSize) &#123;</span><br><span class="line">                <span class="type">Work</span> <span class="variable">work</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Work</span>(task);</span><br><span class="line">                log.debug(<span class="string">&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;</span>, work, task);</span><br><span class="line">                works.add(work);</span><br><span class="line">                work.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                taskQueue.put(task);</span></span><br><span class="line">                <span class="comment">// 1) 死等</span></span><br><span class="line">                <span class="comment">// 2) 带超时等待</span></span><br><span class="line">                <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line">                <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line">                <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">                taskQueue.tryPut(rejectPolicy, task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个内部类就是不断取线程队列中的任务并且执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Work</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Work</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            <span class="comment">// 1) 当 task 不为空，执行任务</span></span><br><span class="line">            <span class="comment">// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行</span></span><br><span class="line"><span class="comment">//            while(task != null || (task = taskQueue.take()) != null) &#123;</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;正在执行...&#123;&#125;&quot;</span>, task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (works) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;worker 被移除&#123;&#125;&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">                works.remove(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程队列:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPool</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>(<span class="number">1</span>,</span><br><span class="line">                <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">1</span>, (queue, task) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 1. 死等</span></span><br><span class="line"><span class="comment">//            queue.put(task);</span></span><br><span class="line">            <span class="comment">// 2) 带超时等待</span></span><br><span class="line">            queue.put(task, <span class="number">1500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line"><span class="comment">//            log.debug(&quot;放弃&#123;&#125;&quot;, task);</span></span><br><span class="line">            <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line"><span class="comment">//            throw new RuntimeException(&quot;任务执行失败 &quot; + task);</span></span><br><span class="line">            <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">            <span class="comment">// task.run();</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, j);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义线程队列</span></span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="comment">//任务队列</span></span><br><span class="line">        <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//定义锁</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="comment">//生产者休息室</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">fullWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        <span class="comment">//消费者休息室</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">emptyWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        <span class="comment">//容量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> capcity;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入容量</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BlockingQueue</span><span class="params">(<span class="type">int</span> capcity)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.capcity = capcity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取队列尺寸</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> queue.size();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阻塞获取</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        emptyWaitSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">                fullWaitSet.signal();</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阻塞添加</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T task)</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.size() == capcity) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);</span><br><span class="line">                        fullWaitSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyWaitSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//队列中获取</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">                <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//设置的等待时间完了还没有获取到线程,就返回null</span></span><br><span class="line">                        <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//到这里就是等待时间还没完,被唤醒后将等待的时间覆盖原来的nanos</span></span><br><span class="line">                        <span class="comment">//因为你被唤醒后不一定可以立即执行,也有可能是继续等待</span></span><br><span class="line">                        nanos = emptyWaitSet.awaitNanos(nanos);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//能走完while相当于队列里面有则获得并且返回就行</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">                <span class="comment">//你拿走了一个就要唤醒生产者继续生产</span></span><br><span class="line">                fullWaitSet.signal();</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//队列添加 写死的超时添加</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">put</span><span class="params">(T task, <span class="type">long</span> timeout, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> timeUnit.toNanos(timeout);</span><br><span class="line">                <span class="keyword">while</span> (queue.size() == capcity) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        log.debug(<span class="string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);</span><br><span class="line">                        nanos = fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyWaitSet.signal();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 还可以支持别的添加方式</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> rejectPolicy 函数式接口,具体怎么实现你可以自己加</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (queue.size() == capcity) &#123;</span><br><span class="line">                    rejectPolicy.reject(<span class="built_in">this</span>, task);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;加入任务队列&quot;</span>);</span><br><span class="line">                    queue.addLast(task);</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="6-2ThreadPoolExecutor"><a href="#6-2ThreadPoolExecutor" class="headerlink" title="6.2ThreadPoolExecutor"></a>6.2ThreadPoolExecutor</h3><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/image-20220821133849505.png" alt="image-20220821133849505"></p><h4 id="6-2-1线程池状态"><a href="#6-2-1线程池状态" class="headerlink" title="6.2.1线程池状态"></a>6.2.1线程池状态</h4><p>ThreadPoolExecutor使用int的高3位来表示线程池状态,低29位表示线程数量</p><table><thead><tr><th align="center">状态名</th><th align="center">高3位</th><th align="center">是否可以接收新任务</th><th align="center">是否可以处理阻塞队列的任务</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">RUNNING</td><td align="center">111</td><td align="center">Y</td><td align="center">Y</td><td align="center"></td></tr><tr><td align="center">SHUTDOWN</td><td align="center">000</td><td align="center">N</td><td align="center">Y</td><td align="center">不会接收新任务，但会处理阻塞队列剩余任务</td></tr><tr><td align="center">STOP</td><td align="center">001</td><td align="center">N</td><td align="center">N</td><td align="center">中断线程正在执行的任务,并且抛弃阻塞队列中的任务</td></tr><tr><td align="center">TIDYING</td><td align="center">010</td><td align="center"></td><td align="center"></td><td align="center">任务全部执行完毕,活动线程为0即进入终结</td></tr><tr><td align="center">TERMINATED</td><td align="center">011</td><td align="center"></td><td align="center"></td><td align="center">终结状态</td></tr></tbody></table><p><strong>为什么用一个int中的前几位数存状态而不是多几个数子存储</strong></p><blockquote><p>这些信息存储在一个原子变量ctl中,目的是为了让线程状态和线程个数合二为一,这样就可以用一次<strong>CAS</strong>操作进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c 为旧值， ctlOf 返回结果为新值</span></span><br><span class="line">ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c)))); </span><br><span class="line"><span class="comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="6-2-2-构造方法"><a href="#6-2-2-构造方法" class="headerlink" title="6.2.2 构造方法"></a>6.2.2 构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,                          </span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,                          </span></span><br><span class="line"><span class="params">                          TimeUnit unit,                          </span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,                          </span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,                          </span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure><ul><li>corePoolSize 核心线程数目 (最多保留的线程数)</li><li>maximumPoolSize 最大线程数目</li><li>keepAliveTime 生存时间 - 针对救急线程</li><li>unit 时间单位 - 针对救急线程</li><li>workQueue 阻塞队列</li><li>threadFactory 线程工厂 - 可以为线程创建时起个好名字</li><li>handler 拒绝策略</li></ul><p><strong>可以直接使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">       service.execute(() -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       service.execute(() -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       service.execute(() -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       service.execute(() -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p><strong>工作方式</strong></p><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="image-20220707155004173"></p><p><strong>执行流程</strong></p><ul><li>救急线程&#x3D;最大线程(maximumPoolSize)-核心线程(corePoolSize)</li><li>线程池一开始没有线程,直至有任务交给线程池时,线程池会创建一个新的线程来执行任务</li><li>当线程池创建线程数等于核心线程数(corePoolSize)时,这时候再加入任务,任务会被放到阻塞队列中 ,直到有空闲线程</li><li>如果阻塞队列有界,那么等阻塞队列慢时,会创建救急线程过来救急.</li><li>如果全部都满了(核心线程+阻塞队列+救急线程),这时候还有任务进来就会执行拒绝策略,JDK实现了4种拒绝策略,其他框架也实现了不同的策略<ul><li><strong>AbortPolicy</strong> 让调用者抛出 RejectedExecutionException 异常，这是默认策略</li><li><strong>CallerRunsPolicy</strong> 让调用者运行任务</li><li><strong>DiscardPolicy</strong> 放弃本次任务</li><li><strong>DiscardOldestPolicy</strong> 放弃队列中最早的任务，本任务取而代之</li><li>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方<br>便定位问题</li><li>Netty 的实现，是创建一个新线程来执行任务</li><li>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</li><li>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li></ul></li></ul><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/%E5%B8%B8%E8%A7%81%E7%AD%96%E7%95%A5.png" alt="image-20220707161944989"></p><h4 id="6-2-3-newFixedThreadPool"><a href="#6-2-3-newFixedThreadPool" class="headerlink" title="6.2.3 newFixedThreadPool"></a>6.2.3 newFixedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//nthreads核心线程数等于最大线程数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                     <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>特点:</strong></p><ul><li>核心线程数等于最大线程数</li><li>阻塞队列无界,不用写拒绝策略</li><li><strong>适用于任务量已知,并且耗时较长</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">       service.execute(()-&gt;&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       service.execute(()-&gt;&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       service.execute(()-&gt;&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       service.execute(()-&gt;&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><h4 id="6-2-4-newCachedThreadPool"><a href="#6-2-4-newCachedThreadPool" class="headerlink" title="6.2.4 newCachedThreadPool"></a>6.2.4 newCachedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>   <span class="variable">MAX_VALUE</span> <span class="operator">=</span> <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                     <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>特点:</p><ul><li>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味<ul><li>全部都是救急线程（60s 后可以回收）</li><li>救急线程可以无限创建</li></ul></li><li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交<br>货）</li><li><strong>评价</strong>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service1</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">       service1.execute(() -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       service1.execute(() -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       service1.execute(() -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       service1.execute(() -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><h4 id="6-2-5-newSingleThreadExecutor"><a href="#6-2-5-newSingleThreadExecutor" class="headerlink" title="6.2.5 newSingleThreadExecutor"></a>6.2.5 newSingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景:</p><p>多个任务派对执行.由于线程数固定为1,任务数大于1时会被放到无界队列中,任务执行完毕时这个线程也不会被释放.</p><p>区别:</p><ul><li>自己创建单线程串行执行任务与该线程池的区别:自己创建如果任务失败而终止没有任何补救措施,而使用线程池,当其中一个任务报错时,线程池会创建新的线程继续执行新的任务</li><li>newSingleThreadExecutor,最大线程数和核心线程数始终为1不能被修改<ul><li>new FinalizableDelegatedExecutorService()应用了装饰模式,只暴露想暴露的方法,不能调用没暴露的方法,newSingleThreadExecutor中的设置没有暴露,因此不能修改</li><li>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改,可以强行调用setCorePoolSize等方法进行修改(没有用上述的FinalizableDelegatedExecutorService装饰类)</li></ul></li></ul><h4 id="6-2-6提交任务"><a href="#6-2-6提交任务" class="headerlink" title="6.2.6提交任务"></a>6.2.6提交任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="type">long</span> timeout, TimeUnit unit)</span><span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="type">long</span> timeout, TimeUnit unit)</span><span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">       service.execute(() -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       Future&lt;String&gt; submit = service.submit(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;s&quot;</span>;</span><br><span class="line">       &#125;);</span><br><span class="line">       System.out.println(submit.get());</span><br><span class="line">       Collection&lt;Callable&lt;String&gt;&gt; callables = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;() ;</span><br><span class="line">       callables.add(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       callables.add(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       List&lt;Future&lt;String&gt;&gt; futures = service.invokeAll(callables);</span><br><span class="line">       futures.stream().forEach(a-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               System.out.println(a.get());</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> service.invokeAny(callables);</span><br><span class="line">       System.out.println(s);</span><br></pre></td></tr></table></figure><h4 id="6-2-7关闭线程池"><a href="#6-2-7关闭线程池" class="headerlink" title="6.2.7关闭线程池"></a>6.2.7关闭线程池</h4><h5 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 SHUTDOWN</span></span><br><span class="line"><span class="comment"> - 不会接收新任务</span></span><br><span class="line"><span class="comment"> - 但已提交任务会执行完</span></span><br><span class="line"><span class="comment"> - 此方法不会阻塞调用线程的执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> checkShutdownAccess();</span><br><span class="line"> <span class="comment">// 修改线程池状态</span></span><br><span class="line"> advanceRunState(SHUTDOWN);</span><br><span class="line"> <span class="comment">// 仅会打断空闲线程</span></span><br><span class="line"> interruptIdleWorkers();</span><br><span class="line"> onShutdown(); <span class="comment">// 扩展点 ScheduledThreadPoolExecutor</span></span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> mainLock.unlock();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)</span></span><br><span class="line"> tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">hreadPoolExecutor</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">        service.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        service.shutdown();</span><br><span class="line">        Future&lt;String&gt; submit = service.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;s&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//会报错,shutdown后不能再新增任务</span></span><br></pre></td></tr></table></figure><h5 id="shutdownnow"><a href="#shutdownnow" class="headerlink" title="shutdownnow"></a>shutdownnow</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*线程池状态变为 STOP </span></span><br><span class="line"><span class="comment">- 不会接收新任务 </span></span><br><span class="line"><span class="comment">- 会将队列中的任务返回 </span></span><br><span class="line"><span class="comment">- 并用 interrupt 的方式中断正在执行的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">       List&lt;Runnable&gt; tasks;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">       mainLock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           checkShutdownAccess();</span><br><span class="line">           advanceRunState(STOP);</span><br><span class="line">           interruptWorkers();</span><br><span class="line">           tasks = drainQueue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           mainLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">       tryTerminate();</span><br><span class="line">       <span class="keyword">return</span> tasks;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其他方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 线程池状态是否是 TERMINATED</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure><h4 id="6-2-8任务调度线程池"><a href="#6-2-8任务调度线程池" class="headerlink" title="6.2.8任务调度线程池"></a>6.2.8任务调度线程池</h4><p>可以设置定时功能,可以调度命令在一个给定的延迟后运行，或周期性地执行</p><p>在『任务调度线程池』功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。</p><h5 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerWait</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        log.info(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;任务1&quot;</span>);</span><br><span class="line">                    sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                log.info(<span class="string">&quot;任务2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        timer.schedule(task, <span class="number">3000</span>);</span><br><span class="line">        timer.schedule(task2, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//==============================================</span></span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">38.870</span> [main] INFO com.example.jucstudy.threadpool.TimerWait - 主线程</span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">39.876</span> [Timer-<span class="number">0</span>] INFO com.example.jucstudy.threadpool.TimerWait - 任务<span class="number">2</span></span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">42.889</span> [Timer-<span class="number">0</span>] INFO com.example.jucstudy.threadpool.TimerWait - 任务<span class="number">1</span></span><br></pre></td></tr></table></figure><p>Timer所有线程都是由一个线程来调度,这个例子里面是主线程在调度,线程都是串行执行的,前一个任务延迟了会影响后一个任务的执行.</p><p>如上所示:任务2执行时间为3s,1s后执行所以任务1的执行时间为4s后(本应该在3s后,但是3s时任务2还在执行,任务1没办法执行,同时也验证了这是串行执行的)</p><h5 id="ScheduledExecutorService线程池"><a href="#ScheduledExecutorService线程池" class="headerlink" title="ScheduledExecutorService线程池"></a>ScheduledExecutorService线程池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建核心数为2的线程池</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">2</span>);</span><br><span class="line">        log.info(<span class="string">&quot;现在时间&quot;</span>);</span><br><span class="line">        scheduledExecutorService.schedule(()-&gt;&#123;</span><br><span class="line">            log.info(<span class="string">&quot;任务1&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;任务1执行完毕&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        scheduledExecutorService.schedule(()-&gt;&#123;</span><br><span class="line">            log.info(<span class="string">&quot;任务2&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;任务2执行完毕&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//==================================================</span></span><br><span class="line"><span class="number">16</span>:<span class="number">53</span>:<span class="number">08.122</span> [main] INFO com.example.jucstudy.threadpool.TimerWait - 现在时间</span><br><span class="line"><span class="number">16</span>:<span class="number">53</span>:<span class="number">09.189</span> [pool-<span class="number">1</span>-thread-<span class="number">2</span>] INFO com.example.jucstudy.threadpool.TimerWait - 任务<span class="number">2</span></span><br><span class="line"><span class="number">16</span>:<span class="number">53</span>:<span class="number">09.189</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] INFO com.example.jucstudy.threadpool.TimerWait - 任务<span class="number">1</span></span><br><span class="line"><span class="number">16</span>:<span class="number">53</span>:<span class="number">10.192</span> [pool-<span class="number">1</span>-thread-<span class="number">2</span>] INFO com.example.jucstudy.threadpool.TimerWait - 任务<span class="number">2</span>执行完毕</span><br><span class="line"><span class="number">16</span>:<span class="number">53</span>:<span class="number">10.192</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] INFO com.example.jucstudy.threadpool.TimerWait - 任务<span class="number">1</span>执行完毕</span><br></pre></td></tr></table></figure><p>ScheduledExecutorService相比Timer,可以多线程同时跑</p><h5 id="scheduleAtFixedRate"><a href="#scheduleAtFixedRate" class="headerlink" title="scheduleAtFixedRate"></a>scheduleAtFixedRate</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//==============================================</span></span><br><span class="line"><span class="number">17</span>:<span class="number">46</span>:<span class="number">52.014</span> [main] DEBUG com.example.jucstudy.threadpool.TimerWait - start</span><br><span class="line"><span class="number">17</span>:<span class="number">46</span>:<span class="number">53.113</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] INFO com.example.jucstudy.threadpool.TimerWait - running</span><br><span class="line"><span class="number">17</span>:<span class="number">46</span>:<span class="number">54.098</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] INFO com.example.jucstudy.threadpool.TimerWait - running</span><br><span class="line"><span class="number">17</span>:<span class="number">46</span>:<span class="number">55.097</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] INFO com.example.jucstudy.threadpool.TimerWait - running</span><br></pre></td></tr></table></figure><p>scheduleAtFixedRate间隔一段时间打印一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//=============================================</span></span><br><span class="line"><span class="number">17</span>:<span class="number">48</span>:<span class="number">32.827</span> [main] DEBUG com.example.jucstudy.threadpool.TimerWait - start</span><br><span class="line"><span class="number">17</span>:<span class="number">48</span>:<span class="number">33.926</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] INFO com.example.jucstudy.threadpool.TimerWait - running</span><br><span class="line"><span class="number">17</span>:<span class="number">48</span>:<span class="number">35.936</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] INFO com.example.jucstudy.threadpool.TimerWait - running</span><br></pre></td></tr></table></figure><p>scheduleAtFixedRate内程序如果运行时间超过间隔,则会将间隔撑大,时间间隔是包括在执行时间里面的</p><p>输出分析：一开始，延时 1s，接下来，由于任务执行时间 &gt; 间隔时间，间隔被『撑』到了 2s</p><h5 id="scheduleWithFixedDelay"><a href="#scheduleWithFixedDelay" class="headerlink" title="scheduleWithFixedDelay"></a>scheduleWithFixedDelay</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        pool.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//============================</span></span><br><span class="line"><span class="number">17</span>:<span class="number">57</span>:<span class="number">11.547</span> [main] DEBUG com.example.jucstudy.threadpool.TimerWait - start...</span><br><span class="line"><span class="number">17</span>:<span class="number">57</span>:<span class="number">12.650</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] DEBUG com.example.jucstudy.threadpool.TimerWait - running...</span><br><span class="line"><span class="number">17</span>:<span class="number">57</span>:<span class="number">15.662</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] DEBUG com.example.jucstudy.threadpool.TimerWait - running...</span><br><span class="line"><span class="number">17</span>:<span class="number">57</span>:<span class="number">18.677</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] DEBUG com.example.jucstudy.threadpool.TimerWait - running...</span><br></pre></td></tr></table></figure><p>scheduleWithFixedDelay时间间隔不包括在程序执行里面</p><p>输出分析：一开始，延时 1s，scheduleWithFixedDelay 的间隔是 上一个任务结束 &lt;-&gt; 延时 &lt;-&gt; 下一个任务开始 所以间隔都是 3s</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>Timer是最开始的,没有线程池的出现的最基础的线程调度工具,串行执行,前一个任务的执行时间以及异常都会影响以后的程序</li><li>ScheduledExecutorService 可以多个线程跑</li><li>scheduleAtFixedRate 按照一个时间不断运行程序,最终间隔时间等于 max(间隔时间,程序运行时间)</li><li>scheduleWithFixedDelay 同上 最终间隔时间等于间隔时间+程序运行时间</li></ol><h4 id="6-2-9正确处理异常"><a href="#6-2-9正确处理异常" class="headerlink" title="6.2.9正确处理异常"></a>6.2.9正确处理异常</h4><h5 id="主动捕获"><a href="#主动捕获" class="headerlink" title="主动捕获"></a>主动捕获</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">pool.submit(() -&gt; &#123;    </span><br><span class="line">    <span class="keyword">try</span> &#123;        </span><br><span class="line">        log.debug(<span class="string">&quot;task1&quot;</span>);        </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;    </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;        </span><br><span class="line">        log.error(<span class="string">&quot;error:&quot;</span>, e);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">21</span>:<span class="number">59</span>:<span class="number">04.558</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - task1 <span class="number">21</span>:<span class="number">59</span>:<span class="number">04.562</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - error: java.lang.ArithmeticException: / by zero  at cn.itcast.n8.TestTimer.lambda$main$<span class="number">0</span>(TestTimer.java:<span class="number">28</span>)  at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">511</span>)  at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>)  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)  at java.lang.Thread.run(Thread.java:<span class="number">748</span>) </span><br></pre></td></tr></table></figure><h5 id="利用Future"><a href="#利用Future" class="headerlink" title="利用Future"></a>利用Future</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123;    </span><br><span class="line">    log.debug(<span class="string">&quot;task1&quot;</span>);    </span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line">log.debug(<span class="string">&quot;result:&#123;&#125;&quot;</span>, f.get());</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">21</span>:<span class="number">54</span>:<span class="number">58.208</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - task1 Exception in thread <span class="string">&quot;main&quot;</span> java.util.concurrent.ExecutionException: java.lang.ArithmeticException: / by zero  at java.util.concurrent.FutureTask.report(FutureTask.java:<span class="number">122</span>)  at java.util.concurrent.FutureTask.get(FutureTask.java:<span class="number">192</span>)  at cn.itcast.n8.TestTimer.main(TestTimer.java:<span class="number">31</span>) Caused by: java.lang.ArithmeticException: / by zero  at cn.itcast.n8.TestTimer.lambda$main$<span class="number">0</span>(TestTimer.java:<span class="number">28</span>)  at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>)  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)  at java.lang.Thread.run(Thread.java:<span class="number">748</span>) </span><br></pre></td></tr></table></figure><h4 id="6-2-10Tomcat线程池"><a href="#6-2-10Tomcat线程池" class="headerlink" title="6.2.10Tomcat线程池"></a>6.2.10Tomcat线程池</h4><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/image-20220821134150947.png" alt="image-20220821134150947"></p><ul><li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的  Semaphore 后面再讲</li><li>Acceptor 只负责【接收新的 socket 连接】</li><li>Poller 只负责监听 socket channel 是否有【可读的 I&#x2F;O 事件】一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理</li><li>Executor 线程池中的工作线程最终负责【处理请求】</li></ul><p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同</p><ul><li>如果总线程数达到 maximumPoolSize<ul><li>这时不会立刻抛 RejectedExecutionException 异常</li><li>而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常</li></ul></li></ul><h3 id="6-3-Fork-x2F-Join"><a href="#6-3-Fork-x2F-Join" class="headerlink" title="6.3 Fork&#x2F;Join"></a>6.3 Fork&#x2F;Join</h3><ol><li><p>概念</p><blockquote><ul><li>Fork&#x2F;Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型运算</li><li>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解</li><li>Fork&#x2F;Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率</li><li>Fork&#x2F;Join 默认会创建与 cpu 核心数大小相同的线程池</li></ul></blockquote></li><li><p>使用</p></li></ol><blockquote><p>提交给 Fork&#x2F;Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值），例如下面定义了一个对 1~n 之间的整数求和的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fork_JoinPool</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>);</span><br><span class="line">     System.out.println(pool.invoke(<span class="keyword">new</span> <span class="title class_">AddTask1</span>(<span class="number">5</span>)));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddTask1</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"> <span class="type">int</span> n;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">AddTask1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.n = n;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + n + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;join() &#123;&#125;&quot;</span>, n);</span><br><span class="line">         <span class="keyword">return</span> n;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">AddTask1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask1</span>(n - <span class="number">1</span>);</span><br><span class="line">     <span class="comment">//这两步限定了这还是串行执行的,必须知道前一个递归的结果才能往后执行</span></span><br><span class="line">     <span class="comment">//t1.fork相当于执行递归流程</span></span><br><span class="line">     t1.fork();</span><br><span class="line">     <span class="comment">//执行完流程就会有一个结果,join获取递归的结果</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> n + t1.join();</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fork_JoinPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>);</span><br><span class="line">        System.out.println(pool.invoke(<span class="keyword">new</span> <span class="title class_">AddTask3</span>(<span class="number">0</span>,<span class="number">5</span>)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddTask3</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="type">int</span> begin;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddTask3</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + begin + <span class="string">&quot;,&quot;</span> + end + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (end - begin) / <span class="number">2</span> + begin;</span><br><span class="line">        <span class="comment">//分治算法</span></span><br><span class="line">        <span class="type">AddTask3</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask3</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">        task2.fork();</span><br><span class="line">        <span class="type">AddTask3</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask3</span>(begin, middle);</span><br><span class="line">        task1.fork();</span><br><span class="line">        <span class="comment">//计算结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> task2.join() + task1.join();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="7-共享模式之工具-JUC"><a href="#7-共享模式之工具-JUC" class="headerlink" title="7.共享模式之工具-JUC"></a>7.共享模式之工具-JUC</h2><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/AQS%E7%B1%BB%E5%9B%BE.png" alt="image-20220710120530316"></p><h3 id="7-1AQS原理"><a href="#7-1AQS原理" class="headerlink" title="7.1AQS原理"></a>7.1AQS原理</h3><p><strong>概述</strong>:全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p><p><strong>特点</strong>:</p><blockquote><ul><li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁<ul><li>getState - 获取 state 状态</li><li>setState - 设置 state 状态</li><li>compareAndSetState - cas 机制设置 state 状态</li><li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li></ul></li><li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li></ul></blockquote><p><strong>需要实现的方法</strong>:</p><blockquote><ul><li>tryAcquire:尝试获得锁</li><li>tryRelease:尝试释放锁</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul></blockquote><p>实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMyLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="comment">//创建同步器类</span></span><br><span class="line">    <span class="comment">//实现独占锁我进去了别人不能进</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MySync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="comment">//将state由0改成1如果可以改则证明加锁成功返回true</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, arg)) &#123;</span><br><span class="line">                <span class="comment">//将拥有线程的对象设置为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        释放锁</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="comment">//释放owner</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            <span class="comment">//然后设置state原因是state被voliate修饰会加写屏障,保证写屏障前的写操作可以写入主存,同时可以被其他线程看到</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        是否持有独占锁</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//AQS内部类已经实现了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建同步器类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MySync</span> <span class="variable">mySync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySync</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁--放入队列等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        mySync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    可中断锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        mySync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    尝试加锁 试一次能加锁就进去，加不了就返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mySync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    带超时时间的尝试加锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> mySync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        mySync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建条件变量（休息室）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mySync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2ReentrantLock-原理"><a href="#7-2ReentrantLock-原理" class="headerlink" title="7.2ReentrantLock 原理"></a>7.2ReentrantLock 原理</h3><h4 id="7-2-1非公平锁实现"><a href="#7-2-1非公平锁实现" class="headerlink" title="7.2.1非公平锁实现"></a>7.2.1非公平锁实现</h4><p>非公平锁:在消息队列中的线程被唤醒后会与新到的线程重新竞争而不是按顺序执行</p><p><strong>ReentrantLock</strong> 先从构造器开始看，默认为非公平锁实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br><span class="line">lock1.lock();</span><br><span class="line">lock1.tryLock();</span><br><span class="line">lock1.lockInterruptibly();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();<span class="comment">//NonfairSync 继承自 AQS</span></span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">       sync.lock();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//我就试一次不行我就不获得了</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//可中断锁</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="普通锁源码"><a href="#普通锁源码" class="headerlink" title="普通锁源码"></a>普通锁源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//普通加锁</span></span><br><span class="line">         <span class="comment">//直接通过CAS设置标志位能设置则将owner设置为当前线程(第一次)</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//不能设置进入acquire方法</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">         <span class="comment">//再判断一次,能拿到就算了,拿不到就存入queue队列(第二次)</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">//存入队列 addWaiter(Node.EXCLUSIVE)将线程创建为一个node对象</span></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    private Node addWaiter(Node mode) &#123;</span></span><br><span class="line"><span class="comment">        Node node = new Node(Thread.currentThread(), mode);</span></span><br><span class="line"><span class="comment">        //tail为等待队列的尾节点</span></span><br><span class="line"><span class="comment">        Node pred = tail;</span></span><br><span class="line"><span class="comment">        //有尾结点</span></span><br><span class="line"><span class="comment">        if (pred != null) &#123;</span></span><br><span class="line"><span class="comment">        //直接尾插(这是个双向链表)</span></span><br><span class="line"><span class="comment">            node.prev = pred;</span></span><br><span class="line"><span class="comment">            //通过compareAndSetTail将尾结点设置成当前节点</span></span><br><span class="line"><span class="comment">            if (compareAndSetTail(pred, node)) &#123;</span></span><br><span class="line"><span class="comment">            //由于是双向性链表将将node节点设置为前任尾节点的后继节点</span></span><br><span class="line"><span class="comment">                pred.next = node;</span></span><br><span class="line"><span class="comment">                return node;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        enq(node);</span></span><br><span class="line"><span class="comment">        return node;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">//先定义failed为true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//是否中断为false</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//死循环</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取node的前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">//如果前驱节点是头节点(头结点是假的标记节点没内容,前驱是头结点就证明你就是等待队列里第一个线程)</span></span><br><span class="line">                <span class="comment">//那就奖励你再试一次(第三次)</span></span><br><span class="line">               <span class="comment">//如果是第二个节点并且成功获取到锁,就进入下一个判断</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">//没成功就讲第二节点设置为头结点</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    <span class="comment">//将用来标记的假头结点的后继节点设置为null 这个节点就可以被垃圾回收了因为没有节点引用指向他了</span></span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    </span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">       <span class="comment">/*         </span></span><br><span class="line"><span class="comment">      private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span></span><br><span class="line"><span class="comment">        int ws = pred.waitStatus;</span></span><br><span class="line"><span class="comment">        //第一次进来时候还不是-1,第二次进来前驱的waitstate就是-1了就返回true</span></span><br><span class="line"><span class="comment">        if (ws == Node.SIGNAL)</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">         //也不大于0</span></span><br><span class="line"><span class="comment">        if (ws &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">            do &#123;</span></span><br><span class="line"><span class="comment">                node.prev = pred = pred.prev;</span></span><br><span class="line"><span class="comment">            &#125; while (pred.waitStatus &gt; 0);</span></span><br><span class="line"><span class="comment">            pred.next = node;</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">        //设置成-1</span></span><br><span class="line"><span class="comment">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //返回false</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">            <span class="comment">//shouldParkAfterFailedAcquire尝试获得锁失败是否需要阻塞,并且设置前驱结点的waitstaus为-1(有责任唤醒后继节点)</span></span><br><span class="line">                <span class="comment">//由于一开始不是-1所以需要设置为-1设置完返回fale,回false重新走一遍for循环(第四次)</span></span><br><span class="line">                <span class="comment">//第二次就是-1了interrupted就是true就会阻塞</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="comment">//真则阻塞</span></span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取标志位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">//标志位为0证明没有人拿到锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//我修改锁的state从0到1,并且修改当前线程为锁的owner成功的话返回true</span></span><br><span class="line">            <span class="comment">//这块可以对比公平锁,公平锁会判断有没有等待队列,并且我是不是等待队列第一个,如果是则运行不是返回false</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//这块是可重入的判断,当前线程如果是线程的拥有者</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">//nextc统计锁用了多少次释放的时候会根据这个判断该线程是否还有锁没有解锁</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="comment">//nextc只能大于等于0小于0证明释放的锁大于上锁肯定就错了</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="comment">//刚才只是运算这块是设置,由于能进这一块肯定是加锁了,所以这块设置nextc就不需要cas操作或者加锁操作</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="可重入判断"><a href="#可重入判断" class="headerlink" title="可重入判断"></a>可重入判断</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               <span class="comment">//nextc统计锁用了多少次释放的时候会根据这个判断该线程是否还有锁没有解锁</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">               <span class="comment">//nextc只能大于等于0小于0证明释放的锁大于上锁肯定就错了</span></span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">               <span class="comment">//刚才只是运算这块是设置,由于能进这一块肯定是加锁了,所以这块设置nextc就不需要cas操作或者加锁操作</span></span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h5 id="可中断锁源码"><a href="#可中断锁源码" class="headerlink" title="可中断锁源码"></a>可中断锁源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可中断获得锁  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//和lock差不多,就是阻塞可以自己中断</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//阻塞可以被外界打断</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>释放锁:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">      sync.release(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //tryRelease方法主要就是释放可重入锁的那个nextc的</span></span><br><span class="line"><span class="comment">    protected final boolean tryRelease(int releases) &#123;</span></span><br><span class="line"><span class="comment">          int c = getState() - releases;</span></span><br><span class="line"><span class="comment">          if (Thread.currentThread() != getExclusiveOwnerThread())</span></span><br><span class="line"><span class="comment">              throw new IllegalMonitorStateException();</span></span><br><span class="line"><span class="comment">          boolean free = false;</span></span><br><span class="line"><span class="comment">          if (c == 0) &#123;</span></span><br><span class="line"><span class="comment">              free = true;</span></span><br><span class="line"><span class="comment">              setExclusiveOwnerThread(null);</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">          setState(c);</span></span><br><span class="line"><span class="comment">          //返回最后释放后剩多少</span></span><br><span class="line"><span class="comment">          return free;</span></span><br><span class="line"><span class="comment">      &#125;*/</span></span><br><span class="line">      <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">          <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">          <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   private void unparkSuccessor(Node node) &#123;</span></span><br><span class="line"><span class="comment">   //获取当前节点的waitstatus</span></span><br><span class="line"><span class="comment">      int ws = node.waitStatus;</span></span><br><span class="line"><span class="comment">   //如果ws小于0则需要唤醒后继节点</span></span><br><span class="line"><span class="comment">      if (ws &lt; 0)</span></span><br><span class="line"><span class="comment">      //将ws从-1置为0</span></span><br><span class="line"><span class="comment">          compareAndSetWaitStatus(node, ws, 0);</span></span><br><span class="line"><span class="comment">      //取后继节点</span></span><br><span class="line"><span class="comment">      Node s = node.next;</span></span><br><span class="line"><span class="comment">      //后继节点为null或者后继节点的ws&gt;0</span></span><br><span class="line"><span class="comment">      if (s == null || s.waitStatus &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">      //s置为null或者s的ws&gt;0证明s不用执行并且需要唤醒s的下一个</span></span><br><span class="line"><span class="comment">          s = null;</span></span><br><span class="line"><span class="comment">          //唤醒后面所有的节点</span></span><br><span class="line"><span class="comment">          for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span></span><br><span class="line"><span class="comment">              if (t.waitStatus &lt;= 0)</span></span><br><span class="line"><span class="comment">                  s = t;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      //如果s不nll则取消s线程的阻塞(后继线程就中断阻塞再继续在死for循环里面竞争锁)</span></span><br><span class="line"><span class="comment">      if (s != null)</span></span><br><span class="line"><span class="comment">          LockSupport.unpark(s.thread);</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">              unparkSuccessor(h);</span><br><span class="line">          <span class="comment">//锁释放成功</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-2公平锁实现原理"><a href="#7-2-2公平锁实现原理" class="headerlink" title="7.2.2公平锁实现原理"></a>7.2.2公平锁实现原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public final boolean hasQueuedPredecessors() &#123;</span></span><br><span class="line"><span class="comment">    // The correctness of this depends on head being initialized</span></span><br><span class="line"><span class="comment">    // before tail and on head.next being accurate if the current</span></span><br><span class="line"><span class="comment">    // thread is first in queue.</span></span><br><span class="line"><span class="comment">    Node t = tail; // Read fields in reverse initialization order</span></span><br><span class="line"><span class="comment">    Node h = head;</span></span><br><span class="line"><span class="comment">    Node s;</span></span><br><span class="line"><span class="comment">    //如果等待队列的头不等于尾(有等待的线程)并且头的后继不是null(有等待的线程),并且投的下一个线程不是正在运行的线程</span></span><br><span class="line"><span class="comment">    return h != t &amp;&amp;</span></span><br><span class="line"><span class="comment">        ((s = h.next) == null || s.thread != Thread.currentThread());</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">            <span class="comment">//对比非公平锁这里加了判断</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-3条件变量实现原理Condition"><a href="#7-2-3条件变量实现原理Condition" class="headerlink" title="7.2.3条件变量实现原理Condition"></a>7.2.3条件变量实现原理Condition</h4><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject(等待室)</p><h5 id="await流程"><a href="#await流程" class="headerlink" title="await流程"></a>await流程</h5><ol><li><p>正在执行的线程Thread0调用await进入Condition的addCondWaiter流程</p><ol><li>先通过addConditionWaiter()将该线程放入Condition的等待队列中的尾部</li><li>通过fullyRelease 释放同步锁</li><li>阻塞Thread0</li><li>unpark AQS 队列中的下一个节点，竞争锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">           <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //将正在运行的线程创建成一个节点存放在condation的等待队列中</span></span><br><span class="line"><span class="comment">         private Node addConditionWaiter() &#123;</span></span><br><span class="line"><span class="comment">           Node t = lastWaiter;</span></span><br><span class="line"><span class="comment">           // 如果尾结点为null并且status不等于-2(不是正常的等待线程)</span></span><br><span class="line"><span class="comment">           if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span></span><br><span class="line"><span class="comment">           //解除垃圾节点</span></span><br><span class="line"><span class="comment">               unlinkCancelledWaiters();</span></span><br><span class="line"><span class="comment">               //t设置为最终的节点</span></span><br><span class="line"><span class="comment">               t = lastWaiter;</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">           //创建node 内容为该线程 状态码为-2</span></span><br><span class="line"><span class="comment">           Node node = new Node(Thread.currentThread(), Node.CONDITION);</span></span><br><span class="line"><span class="comment">           if (t == null)</span></span><br><span class="line"><span class="comment">           //尾节点指向null证明等待队列中没有值</span></span><br><span class="line"><span class="comment">           //头指向当前线程的节点</span></span><br><span class="line"><span class="comment">               firstWaiter = node;</span></span><br><span class="line"><span class="comment">           else</span></span><br><span class="line"><span class="comment">           //尾有值则将该节点赋值给尾的后继</span></span><br><span class="line"><span class="comment">               t.nextWaiter = node;</span></span><br><span class="line"><span class="comment">           //尾指针指向当前节点</span></span><br><span class="line"><span class="comment">           lastWaiter = node;</span></span><br><span class="line"><span class="comment">           return node;</span></span><br><span class="line"><span class="comment">       &#125;*/</span></span><br><span class="line">           <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="comment">//将该线程从原本lock的运行状态取消</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">           <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">               <span class="comment">//将本线程 阻塞</span></span><br><span class="line">               LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">               <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">    <span class="comment">//acquireQueued 唤醒lock等待队列的下一个线程进行竞争</span></span><br><span class="line">           <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">               interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">//如果线程的下一个等待线程为null 清除等待队列</span></span><br><span class="line">           <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">               unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">//失败抛出异常</span></span><br><span class="line">           <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">               reportInterruptAfterWait(interruptMode);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="singal流程"><a href="#singal流程" class="headerlink" title="singal流程"></a>singal流程</h5><ol><li>调用signal中的dosignal方法传入condition等待队列的头结点</li><li>dosingal中将等待队列的头结点给原头结点的下一个节点,并且将原头结点的next置为null</li><li>调用transferForSignal方法将原头结点加入lock的等待队列,并且将状态码由-2改成0(等待状态),将原头结点的前一个节点的状态码由0改成-1即当该节点运行完之后有义务唤醒原头结点</li><li>进入while循环不断唤醒,直至condition的等待队列中头指针等于尾指针等于null</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">      <span class="comment">//获取condition休息室等待队列的头元素</span></span><br><span class="line">          <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">      <span class="comment">//头元素不为null</span></span><br><span class="line">          <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">              <span class="comment">//执行dosingal</span></span><br><span class="line">              doSignal(first);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="comment">//如果头指针指向null将尾指针也指向null</span></span><br><span class="line">              <span class="comment">//同时这一步也是赋值操作,将condition的等待队列的头指针指向first的下一个节点</span></span><br><span class="line">              <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">                  lastWaiter = <span class="literal">null</span>;</span><br><span class="line">              <span class="comment">//将first的下一个节点置为null</span></span><br><span class="line">              <span class="comment">//因为前一步已经完成赋值了</span></span><br><span class="line">              first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">          &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                   (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//transferForSignal(first)返回false证明有别的线程正在修改状态码</span></span><br><span class="line">        <span class="comment">//(first = firstWaiter) != null signal是唤醒这个等待室的所有线程</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">     <span class="comment">//尝试修改该线程的状态从-2(await的状态码)-&gt;0(lock等待队列的状态码)由于唤醒了在队列的最后因此状态码为0</span></span><br><span class="line">       <span class="comment">//这一步返回false证明有别的线程正在执行修改操作因此返回false</span></span><br><span class="line">      <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">//以下操作主要是设置前一个节点的状态码为-1即前一个线程有必要在运行结束时唤醒下一个线程</span></span><br><span class="line">      <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">      <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">      <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">          LockSupport.unpark(node.thread);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="7-3读写锁"><a href="#7-3读写锁" class="headerlink" title="7.3读写锁"></a>7.3读写锁</h3><h4 id="7-3-1ReentrantReadWriteLock"><a href="#7-3-1ReentrantReadWriteLock" class="headerlink" title="7.3.1ReentrantReadWriteLock"></a>7.3.1ReentrantReadWriteLock</h4><p>具体实现和reetrentlock差不多 ,但是不同是写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位</p><p>当读操作远远高于写操作时，这时候使用 读写锁 让 读-读 可以并发，提高性能.类似于数据库中的 select …from … lock in share mode</p><p>提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法,并且支持锁降级,即加写锁写操作时允许读操作</p><p>实用:</p><ol><li>读读可并发</li><li>读写相互阻塞</li><li>写写相互阻塞</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteandRead</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">r</span> <span class="operator">=</span> rw.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">w</span> <span class="operator">=</span> rw.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WriteandRead</span> <span class="variable">writeandRead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WriteandRead</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            writeandRead.read();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            writeandRead.read();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取读锁&quot;</span>);</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;释放读锁...&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取写锁...&quot;</span>);</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;写入&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;释放写锁...&quot;</span>);</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-2StampedLock"><a href="#7-3-2StampedLock" class="headerlink" title="7.3.2StampedLock"></a>7.3.2StampedLock</h4><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用加解读锁</p><ul><li>StampedLock 不支持条件变量</li><li>StampedLock 不支持可重入(有戳)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实现读读优化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stamped_Lock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//(悲观锁)最开始的版本，通过stampedlock加锁时获得一个戳，释放锁时验戳</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">        lock.unlockRead(l);</span><br><span class="line">        <span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">        lock.unlockWrite(l1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//(乐观锁)tryOptimisticRead()乐观读,先读取戳,然后验戳,如果验戳通过,</span></span><br><span class="line">        <span class="comment">// 表示这期间没有写操作,数据可以安全使用,如果校验没通过.需要重新获取读锁,</span></span><br><span class="line">        <span class="comment">// 保证数据安全</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">l2</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">data1</span> <span class="operator">=</span> data;</span><br><span class="line">        <span class="keyword">if</span> (!lock.validate(l2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> data1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果乐观锁失败了</span></span><br><span class="line">        <span class="comment">//锁升级---读锁</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">l3</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(l3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> newData)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">        log.debug(<span class="string">&quot;write lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="built_in">this</span>.data = newData;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;write unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4Semaphore"><a href="#7-4Semaphore" class="headerlink" title="7.4Semaphore"></a>7.4Semaphore</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用:"></a>基本使用:</h4><p>信号量，用来限制能同时访问共享资源的线程上限。,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">     <span class="comment">// 1. 创建 semaphore 对象  传入3</span></span><br><span class="line">     <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);         </span><br><span class="line">     <span class="comment">// 2. 10个线程同时运行        </span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;            </span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                </span><br><span class="line">             <span class="comment">// 3. 获取许可                </span></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">//会在这里做判断看是否有空闲的位置让线程执行</span></span><br><span class="line">                 semaphore.acquire();                </span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    </span><br><span class="line">                 e.printStackTrace();                </span><br><span class="line">             &#125;                </span><br><span class="line">             <span class="keyword">try</span> &#123;                    </span><br><span class="line">                 log.debug(<span class="string">&quot;running...&quot;</span>);                    </span><br><span class="line">                 sleep(<span class="number">1</span>);                    </span><br><span class="line">                 log.debug(<span class="string">&quot;end...&quot;</span>);               </span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;                    </span><br><span class="line">                 <span class="comment">// 4. 释放许可                    </span></span><br><span class="line">                 semaphore.release();                </span><br><span class="line">             &#125;            </span><br><span class="line">         &#125;).start();        </span><br><span class="line">     &#125;    </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//=====================================================</span></span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">49.813</span> [Thread-<span class="number">0</span>] DEBUG com.example.jucstudy.threadpool.Sme - running...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">49.815</span> [Thread-<span class="number">1</span>] DEBUG com.example.jucstudy.threadpool.Sme - running...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">49.816</span> [Thread-<span class="number">2</span>] DEBUG com.example.jucstudy.threadpool.Sme - running...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">50.824</span> [Thread-<span class="number">0</span>] DEBUG com.example.jucstudy.threadpool.Sme - end...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">50.824</span> [Thread-<span class="number">3</span>] DEBUG com.example.jucstudy.threadpool.Sme - running...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">50.824</span> [Thread-<span class="number">1</span>] DEBUG com.example.jucstudy.threadpool.Sme - end...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">50.825</span> [Thread-<span class="number">4</span>] DEBUG com.example.jucstudy.threadpool.Sme - running...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">50.825</span> [Thread-<span class="number">2</span>] DEBUG com.example.jucstudy.threadpool.Sme - end...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">50.825</span> [Thread-<span class="number">5</span>] DEBUG com.example.jucstudy.threadpool.Sme - running...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">51.834</span> [Thread-<span class="number">4</span>] DEBUG com.example.jucstudy.threadpool.Sme - end...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">51.835</span> [Thread-<span class="number">6</span>] DEBUG com.example.jucstudy.threadpool.Sme - running...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">51.833</span> [Thread-<span class="number">5</span>] DEBUG com.example.jucstudy.threadpool.Sme - end...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">51.835</span> [Thread-<span class="number">3</span>] DEBUG com.example.jucstudy.threadpool.Sme - end...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">51.835</span> [Thread-<span class="number">7</span>] DEBUG com.example.jucstudy.threadpool.Sme - running...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">51.836</span> [Thread-<span class="number">8</span>] DEBUG com.example.jucstudy.threadpool.Sme - running...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">52.855</span> [Thread-<span class="number">8</span>] DEBUG com.example.jucstudy.threadpool.Sme - end...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">52.855</span> [Thread-<span class="number">9</span>] DEBUG com.example.jucstudy.threadpool.Sme - running...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">52.855</span> [Thread-<span class="number">7</span>] DEBUG com.example.jucstudy.threadpool.Sme - end...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">52.857</span> [Thread-<span class="number">6</span>] DEBUG com.example.jucstudy.threadpool.Sme - end...</span><br><span class="line"><span class="number">10</span>:<span class="number">56</span>:<span class="number">53.861</span> [Thread-<span class="number">9</span>] DEBUG com.example.jucstudy.threadpool.Sme - end...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="应用"><a href="#应用" class="headerlink" title="应用:"></a>应用:</h4><ul><li><p>使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机<br>线程数量，并且仅是限制线程数，而不是限制资源数即他只能限制一次性执行多少,不能限制生产多少个任务（例如连接数，请对比 Tomcat LimitLatch 的实现）</p></li><li><p>用 Semaphore 实现简单连接池，对比『享元模式』下的实现（用wait notify），性能和可读性显然更好，注意下面的实现中线程数和数据库连接数是相等的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//享元模式新的实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pool</span> &#123;</span><br><span class="line">    <span class="comment">//连接池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poolsize;</span><br><span class="line">    <span class="keyword">private</span> Connection[] connection;</span><br><span class="line">    <span class="comment">//连接状态0代表空闲1代表繁忙</span></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray statas;</span><br><span class="line">    <span class="comment">//利用Semaphore限制执行线程的个数</span></span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pool</span><span class="params">(<span class="type">int</span> poolsize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.poolsize = poolsize;</span><br><span class="line">        <span class="built_in">this</span>.semaphore = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(poolsize);</span><br><span class="line">        <span class="built_in">this</span>.connection = <span class="keyword">new</span> <span class="title class_">Connection</span>[poolsize];</span><br><span class="line">        <span class="built_in">this</span>.statas = <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[poolsize]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; connection.length; i++) &#123;</span><br><span class="line">            connection[i] = <span class="keyword">new</span> <span class="title class_">MockConnection</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//借</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">borrow</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//由于 semaphore限制了每次可以执行的线程数因此可以少判断并且也不用阻塞和唤醒等待线程</span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">0</span>;i&lt;poolsize;i++)&#123;</span><br><span class="line">            <span class="comment">//获取空闲链接</span></span><br><span class="line">            <span class="keyword">if</span>(statas.get(i)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> connection[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Connection conn)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">0</span>;i&lt;poolsize;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (conn==connection[i])&#123;</span><br><span class="line">                statas.set(i,<span class="number">0</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h4><p><strong>获取</strong>:</p><ol><li>tryAcquireShared(arg)返回最新剩余的许可数(当前的许可数-需要的许可数,通过cas设置status)</li><li>如果tryAcquireShared(arg)返回的数字小于0证明许可数不够了要放到消息队列中</li><li>如果你是消息队列的头结点的下一个你可以再尝试一下,再获取不到就进消息队列阻塞</li><li>设置waitstatus和以前一样除了最后一个节点是0其他都是-1</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     protected int tryAcquireShared(int acquires) &#123;</span></span><br><span class="line"><span class="comment">            return nonfairTryAcquireShared(acquires);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">     final int nonfairTryAcquireShared(int acquires) &#123;</span></span><br><span class="line"><span class="comment">     //不断循环</span></span><br><span class="line"><span class="comment">            for (;;) &#123;</span></span><br><span class="line"><span class="comment">            //获取剩余的许可数目</span></span><br><span class="line"><span class="comment">                int available = getState();</span></span><br><span class="line"><span class="comment">                //剩余的许可数目减去本次要用的许可数目等于如果执行本次任务的剩余许可数目</span></span><br><span class="line"><span class="comment">                int remaining = available - acquires;</span></span><br><span class="line"><span class="comment">                //剩余许可数目大于0 则通过cas设置剩余许可数目为remaining</span></span><br><span class="line"><span class="comment">                if (remaining &lt; 0 ||</span></span><br><span class="line"><span class="comment">                    compareAndSetState(available, remaining))</span></span><br><span class="line"><span class="comment">                    //返回执行完本次任务剩余的许可数目</span></span><br><span class="line"><span class="comment">                    return remaining;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//tryAcquireShared(arg)返回执行完本次任务剩余的许可数目,如果&lt;0证明许可数目不够了,需要放入等待队列中,否则继续执行就行</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//将本次任务放入等待队列中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">//如果你的前驱节点是头结点证明你就是要执行的第一个任务你可以尝试获得许可</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">//再次尝试获取许可,流程上面有,就是设置最新的许可数为上一次的许可数-本次需要的许可数(1)</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//证明获取到许可了,将自己设置为头,将前置节点设为null</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="comment">//将failed设置为false</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//shouldParkAfterFailedAcquire如果前驱节点的waitstatus返回true</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">//当前线程阻塞等待唤醒</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">//走进来证明出问题了</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>释放</strong>:</p><ol><li>先进tryrealse这里和上面第一步相反,这里想归还许可数,归还成功返回true</li><li>归还成功进入 doReleaseShared()唤醒后续节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">      sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    protected final boolean tryReleaseShared(int releases) &#123;</span></span><br><span class="line"><span class="comment">        for (;;) &#123;</span></span><br><span class="line"><span class="comment">        //获取当前剩余的许可数</span></span><br><span class="line"><span class="comment">            int current = getState();</span></span><br><span class="line"><span class="comment">            //新的许可数等于当前剩余的许可数+我占用的许可数(要释放的许可数)</span></span><br><span class="line"><span class="comment">            int next = current + releases;</span></span><br><span class="line"><span class="comment">            if (next &lt; current) // overflow</span></span><br><span class="line"><span class="comment">                throw new Error(&quot;Maximum permit count exceeded&quot;);</span></span><br><span class="line"><span class="comment">                //cas设置最新的许可数</span></span><br><span class="line"><span class="comment">            if (compareAndSetState(current, next))</span></span><br><span class="line"><span class="comment">                return true;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">//唤醒头节点,头结点会唤醒后续的节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5CountdownLatch"><a href="#7-5CountdownLatch" class="headerlink" title="7.5CountdownLatch"></a>7.5CountdownLatch</h3><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>上面那个Semaphore可以说相当于限制一次性进入几个而CountdownLatch相当于做统计用的。<strong>用来进行线程同步协作，等待所有线程完成倒计时。</strong></p><p>其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Count</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;其他线程都运行完了&quot;</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//===============================================================</span></span><br><span class="line"><span class="number">17</span>:<span class="number">47</span>:<span class="number">10.302</span> [Thread-<span class="number">2</span>] INFO com.example.jucstudy.threadpool.Count - end...</span><br><span class="line"><span class="number">17</span>:<span class="number">47</span>:<span class="number">10.302</span> [Thread-<span class="number">3</span>] INFO com.example.jucstudy.threadpool.Count - end...</span><br><span class="line"><span class="number">17</span>:<span class="number">47</span>:<span class="number">10.302</span> [Thread-<span class="number">1</span>] INFO com.example.jucstudy.threadpool.Count - end...</span><br><span class="line">其他线程都运行完了</span><br></pre></td></tr></table></figure><h4 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//主要就是这个方法通过cas修改等待数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-6CyclicBarrier"><a href="#7-6CyclicBarrier" class="headerlink" title="7.6CyclicBarrier"></a>7.6CyclicBarrier</h3><h4 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h4><p>循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrier1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span>  <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,j);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=============================================</span></span><br><span class="line"><span class="comment">//由于5攒不到人和他一起所以5没办法执行</span></span><br><span class="line"><span class="number">0</span>:<span class="number">04</span>:<span class="number">48.882</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] INFO com.example.jucstudy.threadpool.CyclicBarrier1 - <span class="number">0</span></span><br><span class="line"><span class="number">20</span>:<span class="number">04</span>:<span class="number">48.880</span> [pool-<span class="number">1</span>-thread-<span class="number">2</span>] INFO com.example.jucstudy.threadpool.CyclicBarrier1 - <span class="number">1</span></span><br><span class="line"><span class="number">20</span>:<span class="number">04</span>:<span class="number">49.894</span> [pool-<span class="number">1</span>-thread-<span class="number">1</span>] INFO com.example.jucstudy.threadpool.CyclicBarrier1 - <span class="number">2</span></span><br><span class="line"><span class="number">20</span>:<span class="number">04</span>:<span class="number">49.894</span> [pool-<span class="number">1</span>-thread-<span class="number">2</span>] INFO com.example.jucstudy.threadpool.CyclicBarrier1 - <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="对比CountdownLatch与CyclicBarrier"><a href="#对比CountdownLatch与CyclicBarrier" class="headerlink" title="对比CountdownLatch与CyclicBarrier"></a>对比CountdownLatch与CyclicBarrier</h3><p><strong>CountdownLatch</strong>：会等待计数器计数完了执行await的线程</p><p><strong>CyclicBarrier</strong>：是等await线程达到计数器后统一执行</p><h3 id="7-7-线程安全集合类概述"><a href="#7-7-线程安全集合类概述" class="headerlink" title="7.7 线程安全集合类概述"></a>7.7 线程安全集合类概述</h3><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88.png" alt="image-20220713201205562"></p><p>线程安全集合类可以分为三大类：</p><ul><li>遗留的线程安全集合如 Hashtable，Vector</li><li>使用 Collections 装饰的线程安全集合，如：会在基础方法上加synchronized(装饰器模式)<ul><li>Collections.synchronizedCollection</li><li>Collections.synchronizedList</li><li>Collections.synchronizedMap</li><li>Collections.synchronizedSet</li><li>Collections.synchronizedNavigableMap</li><li>Collections.synchronizedNavigableSet   </li><li>Collections.synchronizedSortedMap</li><li>Collections.synchronizedSortedSet</li></ul></li><li>java.util.concurrent.*</li></ul><p>重点介绍java.util.concurrent.* 下的线程安全集合类，可以发现它们有规律，里面包含三类关键词：</p><p><strong>Blocking、CopyOnWrite、Concurrent</strong>,性能能高一点,但是并不是100%安全</p><ul><li>Blocking 大部分实现基于锁，并提供用来阻塞的方法</li><li>CopyOnWrite 之类容器修改开销相对较重</li><li>Concurrent 类型的容器<ul><li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量</li><li>弱一致性<ul><li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的</li><li>求大小弱一致性，size 操作未必是 100% 准确</li><li>读取弱一致性</li></ul></li></ul></li></ul><blockquote><p>遍历时如果发生了修改，对于非安全容器来讲，使用 fail-fast 机制也就是让遍历立刻失败，抛出<br>ConcurrentModificationException，不再继续遍历</p></blockquote><h3 id="7-8ConcurrentHashMap"><a href="#7-8ConcurrentHashMap" class="headerlink" title="7.8ConcurrentHashMap"></a>7.8ConcurrentHashMap</h3><ul><li>初始化，使用 cas 来保证并发安全，懒惰初始化 table</li><li>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将链表树化，树化过程会用 synchronized 锁住链表头</li><li>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 bin 的尾部</li><li>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新 table 进行搜索</li><li>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1&#x2F;6 的节点会把复制到新 table 中size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加即可</li></ul><h3 id="7-9LinkedBlockingQueue"><a href="#7-9LinkedBlockingQueue" class="headerlink" title="7.9LinkedBlockingQueue"></a>7.9LinkedBlockingQueue</h3><ul><li><p>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</p></li><li><p>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</p><ul><li>消费者与消费者线程仍然串行(队列头加锁takeLock)</li><li>生产者与生产者线程仍然串行(对列尾队尾putLock)</li></ul></li><li><p>线程安全分析</p><ul><li>当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head 节点的线程安全。两把锁保证了入队和出队没有竞争</li><li>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</li><li>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</li></ul></li><li><p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较</p><ul><li>Linked 支持有界，Array 强制有界</li><li>Linked 实现是链表，Array 实现是数组</li><li>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</li><li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</li><li>Linked 两把锁，Array 一把锁</li></ul></li></ul><h3 id="7-10ConcurrentLinkedQueue"><a href="#7-10ConcurrentLinkedQueue" class="headerlink" title="7.10ConcurrentLinkedQueue"></a>7.10ConcurrentLinkedQueue</h3><ul><li>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</li><li>dummy 节点的引入让两把【锁】将来锁住的是不同对象，避免竞争</li><li>只是这【锁】使用了 cas 来实现</li></ul><p>事实上，ConcurrentLinkedQueue 应用还是非常广泛的<br>例如之前讲的 Tomcat 的 Connector 结构时，Acceptor 作为生产者向 Poller 消费者传递事件信息时，正是采用了<br>  ConcurrentLinkedQueue 将 SocketChannel 给 Poller 使用</p><h3 id="7-11CopyOnWriteArrayList"><a href="#7-11CopyOnWriteArrayList" class="headerlink" title="7.11CopyOnWriteArrayList"></a>7.11CopyOnWriteArrayList</h3><p>适合读多写少(占用空间,以空间换安全)</p><p><strong>写入时拷贝思想</strong></p><p>写入时拷贝: 对数据进行增删改操作时会先将原数据拷贝一份,更改操作在新数据上进行,这时不影响其他线程并发读,达到了读写分离.</p><p>CopyOnWriteArrayList就使用了写入时拷贝思想,这种思想的还有String等等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="comment">//增删改加锁</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        查就没加</span></span><br><span class="line"><span class="comment">        public E get(int index) &#123;</span></span><br><span class="line"><span class="comment">        return get(getArray(), index);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个新的数组</span></span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="comment">//将原数组拷贝进来</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//将新的元素加入到拷贝的数组中</span></span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            <span class="comment">//将拷贝的数组替换原来的数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="comment">//返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>get 弱一致性</strong></p><p>这个很容易理解,你都拷贝了切换到另一个线程读取到原来的数据很正常</p><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/image-20220821134430994.png" alt="image-20220821134430994"></p><p>不要觉得弱一致性就不好</p><ul><li>数据库的 MVCC 都是弱一致性的表现</li><li>并发高和一致性是矛盾的，需要权衡</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
          <category> 多线程 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 多线程 </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-2</title>
      <link href="/2022/03/15/Spring02/"/>
      <url>/2022/03/15/Spring02/</url>
      
        <content type="html"><![CDATA[<h1 id="1-打开IDEA的自动编译"><a href="#1-打开IDEA的自动编译" class="headerlink" title="1. 打开IDEA的自动编译"></a>1. 打开IDEA的自动编译</h1><ul><li>非运行状态的自动编译</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">settings--&gt;build--&gt;compiler--&gt;Build project automatically</span><br></pre></td></tr></table></figure><ul><li>运行时的自动编译</li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help--&gt;find action--&gt;registry--&gt;compile.automake.allow.when.app.running</span><br></pre></td></tr></table></figure><p>IDEA2021.3.x之后不再使用以上方式进行配置了;</p><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/image-20220323185113683.png" alt="image-20220323185113683"></p><hr><h1 id="2-Spring装配Bean的方式"><a href="#2-Spring装配Bean的方式" class="headerlink" title="2. Spring装配Bean的方式"></a>2. Spring装配Bean的方式</h1><p>Spring装配Bean其实就是Spring管理我们的Bean的方式;</p><h2 id="2-1-使用xml装配Bean"><a href="#2-1-使用xml装配Bean" class="headerlink" title="2.1  使用xml装配Bean"></a>2.1  使用xml装配Bean</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.uplooking.spring.UserService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2-使用注解装配Bean"><a href="#2-2-使用注解装配Bean" class="headerlink" title="2.2 使用注解装配Bean"></a>2.2 使用注解装配Bean</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&gt;使用`<span class="meta">@Component</span>`注解来描述bean代替</span><br><span class="line">&lt;bean class=<span class="string">&quot;com.uplooking.spring.UserService&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line"><span class="number">2</span>&gt;使用`<span class="meta">@Component(&quot;userService&quot;)</span>`注解来描述bean代替</span><br><span class="line">&lt;bean id=<span class="string">&quot;userService&quot;</span> class=<span class="string">&quot;com.uplooking.spring.UserService&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>eg:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserService...add()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果直接使用会出现找不到Bean的问题,我们需要让Spring容器来认识这些注解,则需要配置<strong>注解扫描器</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--配置注解扫描器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.uplooking.spring&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>随着业务的增多,现在给Controller  Service  Dao如果都使用一个**@Component<strong>注解则不方便我们后续的开发,所以我们提出来了一些扩展的注解,用于</strong>分层**,但是功能一样</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**@Repository**  用于对DAO实现类进行标注</span><br><span class="line"></span><br><span class="line">**@Service**  用于对Service实现类进行标注</span><br><span class="line"></span><br><span class="line">**@Controller**  用于对Controller实现类进行标注</span><br></pre></td></tr></table></figure><blockquote><p><strong>使用无xml的方式开发spring应用</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(<span class="string">&quot;com.xzy&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">p</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">System.out.println(p);</span><br></pre></td></tr></table></figure><hr><h1 id="3-Spring依赖注入的方式"><a href="#3-Spring依赖注入的方式" class="headerlink" title="3. Spring依赖注入的方式"></a>3. Spring依赖注入的方式</h1><h2 id="3-1-使用XML注入属性"><a href="#3-1-使用XML注入属性" class="headerlink" title="3.1 使用XML注入属性"></a>3.1 使用XML注入属性</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.uplooking.spring.UserService&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.uplooking.spring.UserDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-2-使用注解注入属性-推荐使用"><a href="#3-2-使用注解注入属性-推荐使用" class="headerlink" title="3.2 使用注解注入属性(推荐使用)"></a>3.2 使用注解注入属性(推荐使用)</h2><h3 id="2-2-0-注入普通的字面量值"><a href="#2-2-0-注入普通的字面量值" class="headerlink" title="2.2.0 注入普通的字面量值"></a>2.2.0 注入普通的字面量值</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;小明&quot;)</span><br><span class="line">private String name;</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-1-按类型注入"><a href="#3-2-1-按类型注入" class="headerlink" title="3.2.1 按类型注入"></a>3.2.1 按类型注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDao...inset()..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">   <span class="comment">/*按类型注入属性*/</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.insert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="3-2-2-按名称注入"><a href="#3-2-2-按名称注入" class="headerlink" title="3.2.2 按名称注入"></a>3.2.2 按名称注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDao...inset()..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">/*按名称注入属性*/</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userDao&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.insert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按类型注入和按名称注入,看起来好像没有区别,&#x3D;&#x3D;但是:&#x3D;&#x3D;</p><p>按类型注入和按名称注入,如果注入的是普通的类的对象是没有任何区别的.但是如果注入的是接口类型,抽象类类型的对象,就有很大的不同,按名称注入可以注入唯一的一个对象,按类型注入有可能注入多个对象,则会出错;</p><hr><h1 id="4-XML与注解的选择"><a href="#4-XML与注解的选择" class="headerlink" title="4. XML与注解的选择"></a>4. XML与注解的选择</h1><ol><li><p>在注解还没有提出之前只能使用xml的方式(spring1.0)</p></li><li><p>spring2.0时已经在Spring中出现使用注解装配对象和注入属性的方式</p></li><li><p>spring3.0时,官方已经强烈推荐使用注解开发</p></li><li><p>spring4.0中,官方已经明确说明,xml的方式在新版本中有可能被移除</p></li><li><p>spring5.0中,完全不使用xml了</p></li><li><p>现在的开发方式已经是纯注解(注解开发简单)—-&gt;现在SpringBoot脚手架开发使用注解是非常方便的;</p><p>ps:<strong>&#x3D;&#x3D;在后面的开发过程中建议尽量使用纯注解开发&#x3D;&#x3D;</strong></p></li></ol><hr><h1 id="5-使用纯注解开发Spring"><a href="#5-使用纯注解开发Spring" class="headerlink" title="5. 使用纯注解开发Spring"></a>5. 使用纯注解开发Spring</h1><p><strong>入口类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义扫描的包</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(<span class="string">&quot;com.xzy.spring&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) bean;</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UserService.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UserDao.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;userdao.....add&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="6-Spring中注解的方式装配Bean"><a href="#6-Spring中注解的方式装配Bean" class="headerlink" title="6. Spring中注解的方式装配Bean"></a>6. Spring中注解的方式装配Bean</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Service: 业务层的等效注解</span><br><span class="line">@Repository: 数据方访问层的等效注解</span><br><span class="line">@Controller: 控制层的等效注解</span><br><span class="line">@Configuration: 配置类的等效注解</span><br></pre></td></tr></table></figure><p>以上这四种大家都已经学过了,现在我给大家说一种高级用法;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public BookDao bookDao1() &#123;</span><br><span class="line">    return new BookDao();</span><br><span class="line">&#125;</span><br><span class="line">注意: @Bean会把当前方法的执行的返回值交给Spring容器管理,此对象的名称可以在@Bean中指定,不指定默认是方法的名称 eg: &quot;bookDao1&quot;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的基础上再来一个骚操作:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public BookDao bookDao1(@Qualifier(&quot;user&quot;)  User user) &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    return new BookDao();</span><br><span class="line">&#125;</span><br><span class="line">注意: @Bean注入对象时,因为Spring要调用这个方法,如果包含形参,Spring会自动按类型注入,当然也可以自定义按名称进行注入; @Qualifier(&quot;xxx&quot;)</span><br></pre></td></tr></table></figure><hr><h1 id="6-Spring与Junit的整合-基于Xml配置方式"><a href="#6-Spring与Junit的整合-基于Xml配置方式" class="headerlink" title="6. Spring与Junit的整合(基于Xml配置方式)"></a>6. Spring与Junit的整合(基于Xml配置方式)</h1><p>6.1 导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Spring整合单元测试的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-2-在单元测试类使用注解"><a href="#6-2-在单元测试类使用注解" class="headerlink" title="6.2 在单元测试类使用注解"></a>6.2 在单元测试类使用注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span> &#123;</span><br><span class="line">        userService.addUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="7-Spring整合单元测试-基于注解方式"><a href="#7-Spring整合单元测试-基于注解方式" class="headerlink" title="7. Spring整合单元测试(基于注解方式)"></a>7. Spring整合单元测试(基于注解方式)</h1><p>pom依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建一个Spring的配置类,让其去扫描我们指定的包;</p><p><code>SpringConfig.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzy.spring.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.xzy.spring&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单元测试类,@ContextConfiguration就不用去指定applicationContext.xml</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span> &#123;</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="8-在实际项目中哪些对象需要交给Spring管理"><a href="#8-在实际项目中哪些对象需要交给Spring管理" class="headerlink" title="8. 在实际项目中哪些对象需要交给Spring管理"></a>8. 在实际项目中哪些对象需要交给Spring管理</h1><ul><li>实体类(不会交给Spring管理) ,因为实体类是用来封装数据的,Spring管理的对象一般都是单例的;</li><li>Servlet也不会交给Spring管理(Servlet是由Tomcat来创建)</li></ul><p><strong>Spring容器要在什么时候创建?</strong></p><p>监听ServletContext的创建,在ServletContext创建时,初始化Spring容器,把创建的容器放入到ServletContext的域中;</p><hr><h1 id="9-Spring与web整合-了解"><a href="#9-Spring与web整合-了解" class="headerlink" title="9. Spring与web整合(了解)"></a>9. Spring与web整合(了解)</h1><p>原始的web应用存在那些问题?</p><ul><li><p>项目中的service层和dao层的对象,无任何容器管理</p></li><li><p>对象中的属性也是由开发者进行手动的注入</p></li></ul><blockquote><p>引入Spring到web项目中的目的,让Spring管理我们项目中的对象,注入对象中的属性—&gt;IOC   DI</p></blockquote><hr><h2 id="9-1-导入pom依赖"><a href="#9-1-导入pom依赖" class="headerlink" title="9.1 导入pom依赖"></a>9.1 导入pom依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="9-2-配置Spring提供的监听器"><a href="#9-2-配置Spring提供的监听器" class="headerlink" title="9.2 配置Spring提供的监听器"></a>9.2 配置Spring提供的监听器</h2><p><strong>web.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="7-3-获取ApplicationContext"><a href="#7-3-获取ApplicationContext" class="headerlink" title="7.3 获取ApplicationContext"></a>7.3 获取ApplicationContext</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">userService = (UserService) applicationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">userService.addUser();</span><br></pre></td></tr></table></figure><hr><h1 id="10-自定义监听器实现web整合-重要"><a href="#10-自定义监听器实现web整合-重要" class="headerlink" title="10. 自定义监听器实现web整合(重要)"></a>10. 自定义监听器实现web整合(重要)</h1><ul><li>基于xml的容器初始化(不常用)</li><li>&#x3D;&#x3D;<strong>基于注解的容器初始化</strong>&#x3D;&#x3D;</li></ul><hr><h1 id="11-图书管理系统改造成基于Spring的项目"><a href="#11-图书管理系统改造成基于Spring的项目" class="headerlink" title="11. 图书管理系统改造成基于Spring的项目"></a>11. 图书管理系统改造成基于Spring的项目</h1><ul><li>基于注解方式的Spring开发</li></ul><p><img src="https://zhoujincheng-picture.oss-cn-hangzhou.aliyuncs.com/image-20220324210430611.png" alt="image-20220324210430611"></p><ul><li><p>在什么时候初始化容器</p><p>项目启动时(自己编写监听器)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring全家桶 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-1</title>
      <link href="/2022/03/15/Spring01/"/>
      <url>/2022/03/15/Spring01/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Java中的框架简介"><a href="#1-Java中的框架简介" class="headerlink" title="1. Java中的框架简介"></a>1. Java中的框架简介</h1><ul><li>盖房子的时候搭建的架子</li><li>自己编码的时候遵循框架的约束即可</li></ul><p>框架和工具有啥区别:</p><p>Spring是框架,DbUtils是工具类</p><p>工具类对代码的侵入性不高,我们可以随时的进行修改其他工具,但是其功能也都是比较弱;</p><p>框架对代码的侵入性非常高,我们使用框架的时候就在项目创建的时候就要引入,整个开发过程和框架的耦合度非常高;</p><hr><h1 id="2-Java中的框架有哪些"><a href="#2-Java中的框架有哪些" class="headerlink" title="2. Java中的框架有哪些?"></a>2. Java中的框架有哪些?</h1><p>其实Java变成语言是相当的<strong>繁琐</strong>,那么为什么还有这么多得公司在用,Java开发者依然是世界上开发者最多的领域?</p><p>原因:  java拥有完善的<strong>生态圈</strong></p><ul><li>Struts</li><li>Hibernate</li><li>Spring</li><li>SpringMvc</li><li>Mybatis</li><li>….</li></ul><hr><h1 id="3-Struts2"><a href="#3-Struts2" class="headerlink" title="3. Struts2"></a>3. Struts2</h1><pre><code>Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互</code></pre><h1 id="4-HiberNate"><a href="#4-HiberNate" class="headerlink" title="4. HiberNate"></a>4. HiberNate</h1><ol><li>开源的对象关系映射框架(ORM)</li><li>对jdbc的封装的框架</li><li>与pojo(JavaBean)建立映射关系</li></ol><h1 id="5-Spring"><a href="#5-Spring" class="headerlink" title="5. Spring"></a>5. Spring</h1><pre><code>JavaBean的管理</code></pre><h1 id="6-Java企业级开发的演化"><a href="#6-Java企业级开发的演化" class="headerlink" title="6. Java企业级开发的演化"></a>6. Java企业级开发的演化</h1><ol><li><strong>Servlet + Java Bean</strong></li><li><strong>Servlet + Java Bean + Jsp</strong></li><li><strong>Struts2 + Spring + HiberNate(SSH)</strong></li><li><strong>Spring Mvc + Spring + mybatis(ibatis) (SSM)</strong></li><li><strong>Spring Boot(Spring的快速开发脚手架程序)</strong></li></ol><h1 id="7-Spring"><a href="#7-Spring" class="headerlink" title="7. Spring"></a>7. Spring</h1><h2 id="7-1-Spring的简介"><a href="#7-1-Spring的简介" class="headerlink" title="7.1 Spring的简介"></a>7.1 Spring的简介</h2><p>Spring是分层的JavaSE&#x2F;EE full-stack(一站式) 轻量级开源框架</p><p><strong>分层:</strong></p><ol><li>SUN提供的JavaEE的三层结构:web层、业务层(service)、数据访问层(dao)（持久层，集成层）</li><li>Struts2是web层基于MVC设计模式框架.</li><li>Hibernate是持久的一个ORM的数据持久层的框架.</li></ol><p><strong>一站式:</strong></p><ol><li>Spring对web层提供的解决方案&#x3D;&#x3D;&#x3D;&gt;<code>Spring Mvc</code></li><li>Spring对Service层提供的解决方案&#x3D;&#x3D;&#x3D;&gt;<code>Spring</code>  ~&#96;SpringCore&#96;</li><li>Spring对Dao层提供的解决方案&#x3D;&#x3D;&#x3D;&gt;<code>Jdbc Template</code>  <code>SpringData</code></li></ol><p><strong>常用的解决方案:</strong></p><pre><code>1.web (Struts2 SpringMvc)2.service(Spring)3.dao(JDBC ,DBUtils, HiberNate, mybatis, Jdbc Template,SpringData)</code></pre><h2 id="7-2-Spring的核心"><a href="#7-2-Spring的核心" class="headerlink" title="7.2 Spring的核心"></a>7.2 Spring的核心</h2><h3 id="7-2-1-IOC-控制反转"><a href="#7-2-1-IOC-控制反转" class="headerlink" title="7.2.1 IOC(控制反转)"></a>7.2.1 IOC(控制反转)</h3><pre><code>把对象的创建权交给Spring容器</code></pre><h3 id="7-2-2-AOP-面向切面编程"><a href="#7-2-2-AOP-面向切面编程" class="headerlink" title="7.2.2 AOP(面向切面编程)"></a>7.2.2 AOP(面向切面编程)</h3><pre><code>是面向对象的功能延伸.不是替换面向对象,是用来解决OOP(面向对象编程)中一些问题.</code></pre><h2 id="7-3-Spring的版本"><a href="#7-3-Spring的版本" class="headerlink" title="7.3 Spring的版本"></a>7.3 Spring的版本</h2><pre><code>**spring3.x****spring4.x****spring5.x(推荐使用)**</code></pre><h2 id="7-4-Spring的优点"><a href="#7-4-Spring的优点" class="headerlink" title="7.4 Spring的优点"></a>7.4 Spring的优点</h2><ol><li><p><strong>方便解耦 简化开发</strong></p><pre><code>把所有对象的创建交给Spring管理</code></pre></li><li><p><strong>支持Aop编程</strong></p><pre><code>解决在OOP中遇到的一些问题</code></pre></li><li><p><strong>声明式事务的支持</strong></p></li><li><p><strong>方便调试程序</strong></p><pre><code>在spring中有专门的调试模块Spring-Test</code></pre></li><li><p><strong>方便集成各种优秀的框架</strong></p><pre><code>Spring对各种主流的框架都提供了支持</code></pre></li><li><p><strong>Spring对一些比较难用的API都进行了封装,方便了程序猿的使用(邮件 远程调用….)</strong></p></li></ol><h2 id="7-5-日志框架"><a href="#7-5-日志框架" class="headerlink" title="7.5 日志框架"></a>7.5 日志框架</h2><pre><code>**log4j**:开源的优秀的日志框架..........**日志门面**:运行这些日志系统的slf4jlogging (apache的日志门面)</code></pre><p>日志的级别:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. debug</span><br><span class="line">2. info</span><br><span class="line">3. warn</span><br><span class="line">4. error</span><br></pre></td></tr></table></figure><p>配置文件 <code>log4j.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender </span></span><br><span class="line"><span class="attr">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span></span><br><span class="line"><span class="attr">log4j.rootLogger</span>=<span class="string">DEBUG, stdout </span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Log</span> <span class="variable">log4j</span> <span class="operator">=</span> <span class="type">Log</span> <span class="variable">log4j</span> <span class="operator">=</span> LogFactory.getLog(TestLog.class);</span><br><span class="line">log4j.info(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">log4j.debug(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">log4j.error(<span class="string">&quot;error&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="7-6-Spring的入门"><a href="#7-6-Spring的入门" class="headerlink" title="7.6 Spring的入门"></a>7.6 Spring的入门</h2><h3 id="7-6-1-pom依赖"><a href="#7-6-1-pom依赖" class="headerlink" title="7.6.1 pom依赖"></a>7.6.1 pom依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="7-6-2-创建log4j的配置文件"><a href="#7-6-2-创建log4j的配置文件" class="headerlink" title="7.6.2 创建log4j的配置文件"></a>7.6.2 创建log4j的配置文件</h3><p><strong>log4j.properties</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### direct log messages to stdout ###</span></span><br><span class="line"><span class="attr">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.Target</span>=<span class="string">System.out</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span></span><br><span class="line"><span class="attr">log4j.rootLogger</span>=<span class="string">debug, stdout</span></span><br></pre></td></tr></table></figure><h3 id="7-6-3-创建Spring的配置文件"><a href="#7-6-3-创建Spring的配置文件" class="headerlink" title="7.6.3 创建Spring的配置文件"></a>7.6.3 创建Spring的配置文件</h3><p>在resources目录下创建<strong>applicationContext.xml</strong></p><p><strong>引入XML的约束:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--把User叫给Spring来管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.uplooking.spring.ops1.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="7-6-4-使用ApplicationContext创建对象"><a href="#7-6-4-使用ApplicationContext创建对象" class="headerlink" title="7.6.4. 使用ApplicationContext创建对象"></a>7.6.4. 使用ApplicationContext创建对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Spring的工厂对象(BeanFactory  AppplicationContext)</span></span><br><span class="line">      <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">      <span class="comment">//使用applicationContext.xml中配置的id来获取对象(Spring内部会帮我们创建对象==&gt;IOC)</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) applicationContext.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">      System.out.println(user);</span><br></pre></td></tr></table></figure><p>注意: Spring中加载日志配置文件的顺序 “Spring自带的log4j的配置优先”</p><p>​Spring中的自带的日志系统的隔离级别为<code>info</code></p><hr><h2 id="7-7-ApplicationContext-BeanFactory的区别"><a href="#7-7-ApplicationContext-BeanFactory的区别" class="headerlink" title="7.7 ApplicationContext BeanFactory的区别"></a>7.7 ApplicationContext BeanFactory的区别</h2><ol><li>applicationContext继承自BeanFactory</li><li>在老版本的Spring中使用的是BeanFactory,在新版本的Spring中使用ApplicationContext</li><li>BeanFactory会在调用getBean时候实例化对象</li><li>ApplicationContext会在容器加载时把Spring容器管理的所有的Bean实例化(仅对scope&#x3D;”<strong>singleton</strong>“有效)</li></ol><h1 id="8-bean中的name和id属性"><a href="#8-bean中的name和id属性" class="headerlink" title="8. bean中的name和id属性"></a>8. bean中的name和id属性</h1><ol><li>name与id都是用来给Spring管理的对象命名的</li><li>id遵循的是xml的规范(唯一)</li><li>name可以配置多个(name&#x3D;”user,user2,user3”)</li><li>name可以出现特殊字符,id不能出现特出字符</li><li>一般使用name即可</li></ol><hr><h1 id="9-Spring管理对象的创建的方式-三种"><a href="#9-Spring管理对象的创建的方式-三种" class="headerlink" title="9. Spring管理对象的创建的方式(三种)"></a>9. Spring管理对象的创建的方式(三种)</h1><h3 id="9-1-使用构造器创建对象-默认"><a href="#9-1-使用构造器创建对象-默认" class="headerlink" title="9.1 使用构造器创建对象(默认)"></a>9.1 使用构造器创建对象(默认)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--默认使用无参数的构造器来创建对象的--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;user&quot;</span> class=<span class="string">&quot;com.uplooking.spring.ops1.User&quot;</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="9-2-使用静态工厂创建对象"><a href="#9-2-使用静态工厂创建对象" class="headerlink" title="9.2 使用静态工厂创建对象"></a>9.2 使用静态工厂创建对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFactory</span> &#123;</span><br><span class="line"> <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="keyword">static</span> <span class="title function_">newInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--Spring使用静态工厂实例化对象--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;user&quot;</span> class=<span class="string">&quot;com.uplooking.spring.ops1.UserFactory&quot;</span> factory-method=<span class="string">&quot;newInstance&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="9-3-使用实例工厂创建对象"><a href="#9-3-使用实例工厂创建对象" class="headerlink" title="9.3 使用实例工厂创建对象"></a>9.3 使用实例工厂创建对象</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class UserFactory &#123;</span><br><span class="line">    public User newInstance() &#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">&lt;!--使用实例工厂来创建对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.uplooking.spring.ops1.UserFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;userFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;newInstance&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于applicationContext.getBean(“bean的名称”)的问题:</p><ul><li>bean的名称为,在xml中配置的id,或者name属性的值</li><li>如果我们在xml中不对bean的name或者id进行注册,那么默认的name为  “全类名”</li></ul><hr><h1 id="10-属性的注入-DI"><a href="#10-属性的注入-DI" class="headerlink" title="10. 属性的注入(DI)"></a>10. 属性的注入(DI)</h1><p><strong>DI:依赖注入</strong>&#x3D;&#x3D;&gt;在对象的创建过程中给属性赋值</p><ul><li><strong>用构造器注入</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用构造器注入属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小花&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>用setter方法注入</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--setter方法注入 property的name属性值为: setter方法的名字的首字母小写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;admin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在实际开发过程中推荐使用setter方法注入的方式</p><hr><h1 id="11-IOC与DI的区别-面试题"><a href="#11-IOC与DI的区别-面试题" class="headerlink" title="11. IOC与DI的区别(面试题)"></a>11. IOC与DI的区别(面试题)</h1><pre><code>IOC和DI是没有什么关系的;  一个是转移对象的创建权,一个是注入属性,要是非得扯上一点点关系(DI是在IOC的过程中进行的)IOC:把对象的创建权交给Spring容器DI:创建对象时注入对象的属性</code></pre><hr><h1 id="12-Bean的作用范围"><a href="#12-Bean的作用范围" class="headerlink" title="12. Bean的作用范围"></a>12. Bean的作用范围</h1><pre><code>scope=&quot;singleton&quot; 全局创建一个实例scope=&quot;prototype&quot; 当ApplicationContext调用getBean()时,创建对象,每调用一次创建一个对象注意: 容器初始化的时候 &quot;Spring只会帮我们创建scope=singleton的对象&quot;</code></pre><hr><h1 id="13-Bean的初始化和销毁"><a href="#13-Bean的初始化和销毁" class="headerlink" title="13. Bean的初始化和销毁"></a>13. Bean的初始化和销毁</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化方法...init()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销毁方法....destory()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;bean id=<span class="string">&quot;user&quot;</span> class=<span class="string">&quot;com.xzy.spring.ops1.User&quot;</span> scope=<span class="string">&quot;singleton&quot;</span> init-method=<span class="string">&quot;init&quot;</span> destroy-method=<span class="string">&quot;destory&quot;</span>/&gt;</span><br><span class="line"><span class="comment">/*容器创建时,会创建配置的Bean的对象,并且执行init()方法,*/</span></span><br><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="comment">/*Spring容器关闭时执行销毁的方法*/</span></span><br><span class="line">applicationContext.close();</span><br></pre></td></tr></table></figure><hr><h1 id="14-Bean的生命周期-了解"><a href="#14-Bean的生命周期-了解" class="headerlink" title="14. Bean的生命周期(了解)"></a>14. Bean的生命周期(了解)</h1><ol><li>instantiate bean对象实例化(如果<code>scope=&quot;singleton&quot;</code>时,在容器加载时创建实例)—&gt;<code>构造器</code></li><li>封装属性(DI)调用setter方法—&gt;<code>setter方法</code></li><li><strong>如果存在类实现 BeanPostProcessor（初始化之前执行） ，执行postProcessBeforeInitialization</strong>(aop的底层)</li><li>调用<bean init-method="init"> 指定初始化方法 init</li><li>如果存在类实现 BeanPostProcessor（初始化之后执行） ，执行postProcessAfterInitialization</li><li>执行业务代码</li><li>配置了 <bean destory-method="destory">,指定销毁方法</li></ol><hr><h1 id="15-DI属性的注入"><a href="#15-DI属性的注入" class="headerlink" title="15. DI属性的注入"></a>15. DI属性的注入</h1><h3 id="1-普通的字面量的注入-简单属性的注入"><a href="#1-普通的字面量的注入-简单属性的注入" class="headerlink" title="1. 普通的字面量的注入(简单属性的注入)"></a>1. 普通的字面量的注入(简单属性的注入)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.uplooking.spring.ops1.User&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小花&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-对象注入"><a href="#2-对象注入" class="headerlink" title="2. 对象注入"></a>2. 对象注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.uplooking.spring.ops1.Orders&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--对象的注入--&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-Map的注入"><a href="#3-Map的注入" class="headerlink" title="3 .Map的注入"></a>3 .Map的注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.uplooking.spring.ops1.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小花花&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;17&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;k1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;v1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;k2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;v2&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;k3&quot;</span> <span class="attr">value</span>=<span class="string">&quot;v3&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-List的注入"><a href="#4-List的注入" class="headerlink" title="4. List的注入"></a>4. List的注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.uplooking.spring.ops1.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小花花&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;17&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;loves&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>c++<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>c<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-List中存放对象"><a href="#5-List中存放对象" class="headerlink" title="5. List中存放对象"></a>5. List中存放对象</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.uplooking.spring.ops1.Orders&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.uplooking.spring.ops1.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ordersList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;orders&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring全家桶 </tag>
            
            <tag> Spring </tag>
            
            <tag> IOC </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-3</title>
      <link href="/2022/03/15/Spring03/"/>
      <url>/2022/03/15/Spring03/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spring中的AOP简介"><a href="#1-Spring中的AOP简介" class="headerlink" title="1. Spring中的AOP简介"></a>1. Spring中的AOP简介</h1><ul><li>AOP Aspect Oriented Programing 面向切面编程 </li><li>AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码（性能监视、事务管理、安全检查、缓存） </li><li>Spring中的Aop是纯Java来实现的,使用<strong>动态代理</strong>的方式增强代码 </li><li>Spring使用动态代理的机制是判断<strong>委托类是否实现了接口</strong>,如果实现了接口则使用<strong>jdk的动态代理</strong>,如果没有实现接口则使用<strong>cglib的动态代理</strong></li><li>AOP不是由Spring提出来的,是由<strong>AOP联盟</strong>定义的</li></ul><hr><h1 id="2-代理模式"><a href="#2-代理模式" class="headerlink" title="2. 代理模式"></a>2. 代理模式</h1><pre><code>不使用对象来进行真实操作,使用我们自己创建的&quot;代理&quot;对象来操作</code></pre><h2 id="2-1-静态代理"><a href="#2-1-静态代理" class="headerlink" title="2.1 静态代理"></a>2.1 静态代理</h2><p><strong>创建发起者</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzy.spring;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发起者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiMen</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">say</span><span class="params">(String msg,Integer score)</span> &#123;</span><br><span class="line">        <span class="comment">//创建目标类的对象</span></span><br><span class="line">        <span class="type">Pan</span> <span class="variable">pan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pan</span>();</span><br><span class="line">        <span class="comment">//创建代理类的对象</span></span><br><span class="line">        <span class="type">KindWoman</span> <span class="variable">wang</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Wang</span>(pan);</span><br><span class="line">        <span class="comment">//调用代理方法</span></span><br><span class="line">        <span class="keyword">return</span> wang.hear(msg,score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>创建委托类和代理类的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzy.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">KindWoman</span>  &#123;</span><br><span class="line">    String <span class="title function_">hear</span><span class="params">(String msg,Integer score)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>创建委托类(被代理类):</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzy.spring;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托类(被代理类)  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pan</span> <span class="keyword">implements</span> <span class="title class_">KindWoman</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hear</span><span class="params">(String msg, Integer score)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;pan听到的msg为:&quot;</span> + msg);</span><br><span class="line">        <span class="keyword">return</span> score &gt; <span class="number">60</span> ? <span class="string">&quot;yes&quot;</span> : <span class="string">&quot;NONONO&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>创建代理类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzy.spring;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wang</span> <span class="keyword">implements</span> <span class="title class_">KindWoman</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Pan pan;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Wang</span><span class="params">(Pan pan)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pan = pan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hear</span><span class="params">(String msg, Integer score)</span> &#123;</span><br><span class="line">        <span class="comment">//前置增强</span></span><br><span class="line">        System.out.println(<span class="string">&quot;wang听到的msg为:&quot;</span> + msg + <span class="string">&quot;=======&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="string">&quot;我是wang,目标回复的内容为=&quot;</span> + pan.hear(msg, score + <span class="number">20</span>);</span><br><span class="line">        <span class="comment">//后置增强</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序执行的入口:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzy.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">XiMen</span> <span class="variable">xiMen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XiMen</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> xiMen.say(<span class="string">&quot;你好,美女,今晚一起吃饭&quot;</span>, <span class="number">50</span>);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>总结:</p><ol><li>代理模式是通过调用代理对象,从而调用到真实对象的一种设计模式</li><li>代理模式中要求 <code>委托类</code>和<code>代理类</code>实现同一个接口</li><li><code>代理类</code>中持有<code>委托类的对象</code></li></ol></blockquote><hr><h2 id="2-2-动态代理"><a href="#2-2-动态代理" class="headerlink" title="2.2 动态代理"></a>2.2 动态代理</h2><h3 id="2-2-1-基于原生的JDK的动态代理"><a href="#2-2-1-基于原生的JDK的动态代理" class="headerlink" title="2.2.1 基于原生的JDK的动态代理"></a>2.2.1 基于原生的JDK的动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//真实对象</span></span><br><span class="line">        <span class="type">Pan</span> <span class="variable">pan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pan</span>();</span><br><span class="line">        <span class="type">KindWoman</span> <span class="variable">kindWoman</span> <span class="operator">=</span> (KindWoman) Proxy.newProxyInstance(App.class.getClassLoader(), pan.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> method.invoke(pan, args);</span><br><span class="line">                System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> kindWoman.hear(<span class="string">&quot;你好,我们一起吃个饭&quot;</span>, <span class="number">45</span>);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-2-基于CGLIB的动态代理"><a href="#2-2-2-基于CGLIB的动态代理" class="headerlink" title="2.2.2 基于CGLIB的动态代理"></a>2.2.2 基于CGLIB的动态代理</h3><ul><li>因为原生的jdk的动态代理存在缺陷,<strong>代理类和委托类必须实现同一个接口</strong></li><li>所以有个开源的动态代理框架出现了(CGLIB)</li><li>CGLIB不要求委托类必须实现接口&#x3D;&#x3D;&#x3D;&gt;因为CGLIB底层是基于<strong>继承</strong>实现的</li></ul><h3 id="2-2-3-jdk的动态代理与cglib"><a href="#2-2-3-jdk的动态代理与cglib" class="headerlink" title="2.2.3 jdk的动态代理与cglib"></a>2.2.3 jdk的动态代理与cglib</h3><ul><li>jdk的动态代理底层实现是基于<strong>接口实现</strong>的</li><li>cglib的动态代理底层是基于<strong>继承</strong>的</li></ul><h1 id="3-Aop的专业术语"><a href="#3-Aop的专业术语" class="headerlink" title="3. Aop的专业术语"></a>3. Aop的专业术语</h1><ul><li><strong>Joinpoint(连接点)</strong> :目标类中可以被增强的方法(例如有四个方法)</li><li><strong>Pointcut(切入点,切点)</strong> : 目标类中要被增强的方法</li><li><strong>Advice(通知&#x2F;增强)</strong> :增强的代码<ul><li>前置增强(通知)</li><li>后置增强(通知)</li><li>环绕增强(通知)</li></ul></li><li><strong>Target(目标对象)</strong> :目标对象</li><li><strong>Weaving(织入) :<strong>把</strong>增强</strong>应用<strong>切点</strong>的过程</li><li><strong>Proxy（代理）</strong>: 一个类被AOP织入增强后，就产生一个结果代理类 </li><li><strong>Aspect(切面):</strong> 是<strong>切点</strong>和<strong>通知</strong>的结合</li></ul><hr><h1 id="4-基于Jdk动态代理实现自定义AOP"><a href="#4-基于Jdk动态代理实现自定义AOP" class="headerlink" title="4. 基于Jdk动态代理实现自定义AOP"></a>4. 基于Jdk动态代理实现自定义AOP</h1><ul><li><p><strong>pom依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>创建接口</strong> <code>UserService</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>定义目标类</strong> <code>UserServiceImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>定义切面</strong> <code>MyAspect</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>定义目标对象的工厂类(用于创建目标对象说对应的代理对象)</strong> <code>UserServiceFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">newUserServiceProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="comment">//创建切面对象</span></span><br><span class="line">        <span class="type">MyAspect</span> <span class="variable">myAspect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAspect</span>();</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userServiceProxy</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(UserServiceFactory.class.getClassLoader(), UserServiceImpl.class.getInterfaces(), <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                myAspect.before();</span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(userService, args);</span><br><span class="line">                myAspect.after();</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> userServiceProxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>入口类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">UserServiceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceFactory</span>();</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> factory.newUserServiceProxy();</span><br><span class="line">    userService.addUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="5-AOP联盟定义的通知类型"><a href="#5-AOP联盟定义的通知类型" class="headerlink" title="5. AOP联盟定义的通知类型"></a>5. AOP联盟定义的通知类型</h1><p>Spring按照通知(Advice)在目标类方法的切点的位置,分为5类:</p><ul><li><strong>前置通知</strong><code>org.springframework.aop.MethodBeforeAdvice</code><ul><li>在目标方法执行前实施增强</li></ul></li><li><strong>后置通知</strong><code>org.springframework.aop.AfterReturningAdvice</code><ul><li>在目标方法执行后实施增强</li></ul></li><li><strong>环绕通知</strong><code>org.aopalliance.intercept.MethodInterceptor</code><ul><li>在目标方法执行前后实施增强,环绕通知，必须手动执行目标方法</li></ul></li><li><strong>异常抛出通知</strong><code>org.springframework.aop.ThrowsAdvice</code></li><li>在方法抛出异常后实施增强</li><li><strong>引介通知</strong> <code>org.springframework.aop.IntroductionInterceptor</code><ul><li>在目标类中添加一些新的方法和属性</li></ul></li></ul><hr><h1 id="6-Spring中的AOP-不建议使用"><a href="#6-Spring中的AOP-不建议使用" class="headerlink" title="6. Spring中的AOP(不建议使用)"></a>6. Spring中的AOP(不建议使用)</h1><h2 id="6-1-Spring中的半自动AOP"><a href="#6-1-Spring中的半自动AOP" class="headerlink" title="6.1 Spring中的半自动AOP"></a>6.1 Spring中的半自动AOP</h2><ul><li><p><strong>定义接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>定义目标类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>定义切面(实现Spring提供的拦截器)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> <span class="keyword">implements</span> <span class="title class_">org</span>.aopalliance.intercept.MethodInterceptor &#123;</span><br><span class="line">    <span class="comment">//定义三个通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation methodInvocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodInvocation.proceed();</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>配置Spring中自带的工厂 <code>applicationContext.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                           https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id=&quot;userServiceFactory&quot; class=&quot;com.it.framework.UserServiceFactory&quot;&gt;&lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定义目标对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.it.framework.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义切面对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.it.framework.MyAspect&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--定义工厂对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userServiceproxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置接口--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interfaces&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.it.framework.UserService&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置目标对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;userServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;interceptorNames&quot;</span> <span class="attr">value</span>=<span class="string">&quot;myAspect&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置动态代理方式,true是使用cglib的方式,默认使用jdk的动态代理--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;optimize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="6-2-Spring中的全自动AOP"><a href="#6-2-Spring中的全自动AOP" class="headerlink" title="6.2 Spring中的全自动AOP"></a>6.2 Spring中的全自动AOP</h2><ul><li><p><strong>pom依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring全自动aop依赖aspectj联盟的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>定义接口</strong>&#x3D;&#x3D;&#x3D;&gt;同半自动AOP一致</p></li><li><p><strong>定义目标类</strong>&#x3D;&#x3D;&#x3D;&gt;同半自动AOP一致</p></li><li><p><strong>定义切面(实现Spring提供的拦截器)</strong>&#x3D;&#x3D;&#x3D;&gt;同半自动AOP一致</p></li><li><p>配置<code>applicationContext.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义目标对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.it.framework.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--定义切面对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.it.framework.MyAspect&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        proxy-target-class=true表示使用cglib动态代理</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义切点表达式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.it.framework.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>入口类</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义目标对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.it.framework.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--定义切面对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.it.framework.MyAspect&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    proxy-target-class=true表示使用cglib动态代理</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义切点表达式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.it.framework.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h1 id="7-切点表达式"><a href="#7-切点表达式" class="headerlink" title="7. 切点表达式"></a>7. 切点表达式</h1><ul><li><p><strong>用于描述需要增强的方法(切点)</strong></p></li><li><p>语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(修饰符  返回值  包.类.方法名(参数) <span class="keyword">throws</span>异常)</span><br></pre></td></tr></table></figure></li><li><p><strong>修饰符，一般省略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>     公共方法</span><br><span class="line">  * 任意</span><br></pre></td></tr></table></figure></li><li><p><strong>返回值类型，不能省略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>         返回没有值</span><br><span class="line">String       返回值字符串</span><br><span class="line">*            任意</span><br></pre></td></tr></table></figure></li><li><p><strong>包  可以省略</strong></p><p>  com.it.spring       固定包<br>  com.it.spring..     spring包下面的所有子包（含自己）</p></li><li><p><strong>类，可以省略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UserServiceImpl指定类</span><br><span class="line">*Impl以Impl结尾</span><br><span class="line">User*以User开头</span><br><span class="line">*任意</span><br></pre></td></tr></table></figure></li><li><p><strong>方法名，不能省略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addUser固定方法</span><br><span class="line">add*以add开头</span><br><span class="line">*Do以Do结尾</span><br><span class="line">*任意</span><br></pre></td></tr></table></figure></li><li><p><strong>(参数)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">()无参</span><br><span class="line">(<span class="type">int</span>)一个整型</span><br><span class="line">(<span class="type">int</span> ,<span class="type">int</span>)两个</span><br><span class="line">(..)参数任意</span><br></pre></td></tr></table></figure></li><li><p><strong>throws ,可省略，一般不写</strong></p></li><li><p><strong>eg</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserServiceImpl类中任意参数的方法</span><br><span class="line"> * com.it.framework.UserServiceImpl.*(..)</span><br></pre></td></tr></table></figure></li></ul><h1 id="8-x3D-x3D-基于Aspectj的AOP-x3D-x3D"><a href="#8-x3D-x3D-基于Aspectj的AOP-x3D-x3D" class="headerlink" title="8.  &#x3D;&#x3D;基于Aspectj的AOP&#x3D;&#x3D;"></a>8.  &#x3D;&#x3D;基于Aspectj的AOP&#x3D;&#x3D;</h1><ul><li>AspectJ是一个基于Java语言的面向切面的AOP框架</li><li>Spring2.0以后新增了对AspectJ<strong>切点表达式</strong>支持 </li><li>@AspectJ 是AspectJ1.5新增功能，通过JDK5注解技术，允许直接在Bean类中定义切面 </li><li>新版本Spring框架，建议使用AspectJ方式来开发AOP</li></ul><h2 id="8-1-AspectJ的增强类型"><a href="#8-1-AspectJ的增强类型" class="headerlink" title="8.1 AspectJ的增强类型"></a>8.1 AspectJ的增强类型</h2><ul><li>@Before 前置通知，相当于BeforeAdvice</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* com.uplooking.aop.UserDao.add*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeAdvice</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;前置通知....&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@AfterReturning 后置通知，相当于AfterReturningAdvice</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(* com.uplooking.aop.UserDao.add*(..))&quot;, returning = &quot;ret&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturningAdvice</span><span class="params">(String ret)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;后置通知..&quot;</span> + ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Around 环绕通知，相当于MethodInterceptor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(* com.uplooking.aop.UserDao.add*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">arounrAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;环绕通知前..&quot;</span>);</span><br><span class="line">    pjp.proceed();</span><br><span class="line">    System.out.println(<span class="string">&quot;环绕通知后..&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@AfterThrowing抛出通知，相当于ThrowAdvice</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(&quot;execution(* com.uplooking.aop.UserDao.add*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">throwAdvice</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;异常通知....&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@After 最终final通知，不管是否异常，该通知都会执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After(value = &quot;execution(* com.uplooking.aop.UserDao.add*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterAdvice</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;最终通知....&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-2-基于Aspectj的Aop"><a href="#9-2-基于Aspectj的Aop" class="headerlink" title="9.2.  基于Aspectj的Aop"></a>9.2.  基于Aspectj的Aop</h2><ul><li><strong>pom依赖</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Spring整合Aspectj的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>定义切面</strong></p><pre><code>  切面 = 切点  +  通知</code></pre></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切面 = 切点(切点表达式)  +  通知(方法)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* add*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeAdvice</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>定义要增强的类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add1...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除用户...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改用户...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询用户...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>配置</strong><code>applicationContext.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--组件扫描器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.uplooking.aop&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--aop自动创建代理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>测试程序</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="comment">//edu.uplooking.com  passwd :80684</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.add();</span><br><span class="line">        userDao.add1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring全家桶 </tag>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
            <tag> 代理模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream流使用方法</title>
      <link href="/2022/03/12/Stream/"/>
      <url>/2022/03/12/Stream/</url>
      
        <content type="html"><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ol><li>提高代码可读性</li><li>大数据量效率高</li></ol><h3 id="1-1函数式编程思想"><a href="#1-1函数式编程思想" class="headerlink" title="1.1函数式编程思想"></a>1.1函数式编程思想</h3><h4 id="1-1-1概念"><a href="#1-1-1概念" class="headerlink" title="1.1.1概念"></a>1.1.1概念</h4><blockquote><p>函数式编程关注对数据进行什么操作</p><p>面向对象关注用什么对象完成什么事</p></blockquote><h4 id="1-1-2优点"><a href="#1-1-2优点" class="headerlink" title="1.1.2优点"></a>1.1.2优点</h4><blockquote><ol><li>简洁</li><li>易理解</li><li>易于“并发编程”</li></ol></blockquote><h2 id="2-Lambda表达式"><a href="#2-Lambda表达式" class="headerlink" title="2. Lambda表达式"></a>2. Lambda表达式</h2><h3 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h3><blockquote><p>jdk8认可的一种语法，对匿名内部类的写法进行简化。是函数式编程的一个重要体现。</p></blockquote><h3 id="2-2-核心原则"><a href="#2-2-核心原则" class="headerlink" title="2.2 核心原则"></a>2.2 核心原则</h3><blockquote><p>可推导时可省略</p><p>方法名可推导方法名可省略</p><p>参数名可推导参数名可省略</p></blockquote><h3 id="2-3-基本格式"><a href="#2-3-基本格式" class="headerlink" title="2. 3 基本格式"></a>2. 3 基本格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数列表)-&gt;&#123;代码&#125;</span><br></pre></td></tr></table></figure><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>我们在创建线程并启动时可以使用匿名内部类的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>可以使用Lambda的格式对其进行修改。修改后如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h3 id="2-4-省略规则"><a href="#2-4-省略规则" class="headerlink" title="2.4 省略规则"></a>2.4 省略规则</h3><ul><li>参数类型可以省略</li><li>方法体只有一句代码时大括号return和唯一一句代码的分号可以省略</li><li>方法只有一个参数时小括号可以省略</li><li>以上这些规则都记不住也可以省略不记</li></ul><h2 id="3-Stream流"><a href="#3-Stream流" class="headerlink" title="3.Stream流"></a>3.Stream流</h2><h3 id="3-1概述"><a href="#3-1概述" class="headerlink" title="3.1概述"></a>3.1概述</h3><blockquote><p>java8的Stream使用的是函数式编程模式，可以对集合或数组进行链状流式操作。方便我们对集合和数组操作。</p></blockquote><h3 id="3-2入门"><a href="#3-2入门" class="headerlink" title="3.2入门"></a>3.2入门</h3><h4 id="3-2-1创建流"><a href="#3-2-1创建流" class="headerlink" title="3.2.1创建流"></a>3.2.1创建流</h4><blockquote><p><strong>collection</strong>：集合对象.stream();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">Stream</span> <span class="variable">stream</span> <span class="operator">=</span> list.stream;</span><br></pre></td></tr></table></figure><p><strong>数组</strong>：Arrays.stream(“数组”)或者Stream.of</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stream.of()</span></span><br><span class="line"> Integer[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"> Stream&lt;Integer&gt; array1 = Stream.of(array);</span><br><span class="line"> <span class="comment">//Arrays.stream()</span></span><br><span class="line"> Stream&lt;Integer&gt; stream = Arrays.stream(array);</span><br></pre></td></tr></table></figure><p><strong>map</strong>：先转成Collection再.stream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;蜡笔小新&quot;</span>,<span class="number">19</span>);</span><br><span class="line">map.put(<span class="string">&quot;黑子&quot;</span>,<span class="number">17</span>);</span><br><span class="line">map.put(<span class="string">&quot;日向翔阳&quot;</span>,<span class="number">16</span>);</span><br><span class="line">Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; stream = map.entrySet().stream();</span><br></pre></td></tr></table></figure></blockquote><h4 id="3-2-2中间操作"><a href="#3-2-2中间操作" class="headerlink" title="3.2.2中间操作"></a>3.2.2中间操作</h4><blockquote><p><strong>filter</strong>:对流中元素进行过滤,符合条件的留在流中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> author.getAge()&gt;<span class="number">18</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> .filter(author -&gt; author.getAge()&gt;<span class="number">18</span>)    </span><br><span class="line">  </span><br></pre></td></tr></table></figure><p><strong>map</strong>:可以把对流中的元素进行计算或转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;Author&gt; authors1 = getAuthors();</span><br><span class="line">        authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Author, String&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> author.toString();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .forEach(author-&gt;&#123;</span><br><span class="line">                    System.out.println(author.getClass());</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">//lambda表达式写法</span></span><br><span class="line"> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(author -&gt; author.toString()</span><br><span class="line">                )</span><br><span class="line">                .forEach(author-&gt;&#123;</span><br><span class="line">                    System.out.println(author.getClass());</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">/*结果全转成String类型</span></span><br><span class="line"><span class="comment">class java.lang.String</span></span><br><span class="line"><span class="comment">class java.lang.String</span></span><br><span class="line"><span class="comment">class java.lang.String</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>distinct</strong>:去重(根据equals方法),根据需求选择是否重写equals</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">authors.stream()</span><br><span class="line">           .distinct()</span><br><span class="line">           .forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                   System.out.println(author);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><p><strong>sorted</strong>:对流中内容进行排序(如果流中对象实现了<strong>Comparable接口</strong>中的compareto()方法则只需要调用sorted()的无参方法,否则调用有参方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   authors.stream()</span><br><span class="line">               .distinct()</span><br><span class="line">               .sorted(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Author&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Author o1, Author o2)</span> &#123;</span><br><span class="line">                       <span class="keyword">return</span> o2.getAge()-o1.getAge();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)</span><br><span class="line">               .forEach(author-&gt;&#123;</span><br><span class="line">                   System.out.println(author);</span><br><span class="line">               &#125;);</span><br><span class="line"><span class="comment">//lambda表达式写法</span></span><br><span class="line"> authors1.stream()</span><br><span class="line">               .distinct()</span><br><span class="line">               .sorted((author1,author2)-&gt;author1.getAge()-author2.getAge())</span><br><span class="line">               .forEach(author-&gt;&#123;</span><br><span class="line">                   System.out.println(author);</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure><p><strong>limit</strong>:设置流的长度限制(超过的会被舍弃)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">authors1.stream()</span><br><span class="line">               .distinct()</span><br><span class="line">               .sorted(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Author&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Author o1, Author o2)</span> &#123;</span><br><span class="line">                       <span class="keyword">return</span> o2.getAge()-o1.getAge();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)</span><br><span class="line">               .limit(<span class="number">2</span>)</span><br><span class="line">               .forEach(author-&gt;&#123;</span><br><span class="line">                   System.out.println(author);</span><br><span class="line">               &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>skip</strong>:跳过流中前n个元素,返回剩下的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">authors1.stream()</span><br><span class="line">         .distinct()</span><br><span class="line">         .sorted((author1,author2)-&gt;author1.getAge()-author2.getAge())</span><br><span class="line">         .skip(<span class="number">1</span>)</span><br><span class="line">         .forEach(author-&gt;&#123;</span><br><span class="line">             System.out.println(author);</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure><p><strong>flatMap</strong>: flatMap可以把一个对象转换成多个对象作为流中的元素。(map只能把一个对象转换成另一个对象来作为流中的元素。而flatMap可以把一个对象转换成多个对象作为流中的元素。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted((author1,author2)-&gt;author1.getAge()-author2.getAge())</span><br><span class="line">                .flatMap(author-&gt;author.getBooks().stream())</span><br><span class="line">     <span class="comment">//将author中的books(list)也转为流对象并且进行拼接</span></span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted((b1,b2)-&gt; (<span class="type">int</span>) (b1.getId()-b2.getId()))</span><br><span class="line">                .forEach(author-&gt;&#123;</span><br><span class="line">                    System.out.println(author);</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果用map出来的就不是一条一条的book信息而是一个类型值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .flatMap(author -&gt; author.getBooks().stream()</span><br><span class="line">                )</span><br><span class="line">                .flatMap(book-&gt; Arrays.stream(book.getCategory().split(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">                .distinct()</span><br><span class="line">                .forEach(author-&gt;&#123;</span><br><span class="line">                    System.out.println(author);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h4 id="3-2-3终结操作"><a href="#3-2-3终结操作" class="headerlink" title="3.2.3终结操作"></a>3.2.3终结操作</h4><blockquote><p><strong>forEach</strong>:对流中的元素进行遍历操作，我们通过传入的参数去指定对遍历到的元素进行什么具体操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">authors1.stream()</span><br><span class="line">               .distinct()</span><br><span class="line">               .flatMap(author -&gt; author.getBooks().stream()</span><br><span class="line">               )</span><br><span class="line">               .flatMap(book-&gt; Arrays.stream(book.getCategory().split(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">               .distinct()</span><br><span class="line">               .forEach(author-&gt;&#123;</span><br><span class="line">                   System.out.println(author);</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure><p><strong>count</strong>:获取流中元素个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">              .distinct()</span><br><span class="line">              .flatMap(author -&gt; author.getBooks().stream()</span><br><span class="line">              )</span><br><span class="line">              .flatMap(book -&gt; Arrays.stream(book.getCategory().split(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">              .distinct()</span><br><span class="line">              .count();</span><br><span class="line">      System.out.println(count);</span><br></pre></td></tr></table></figure><p><strong>max and min</strong>:最大值和最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大  </span></span><br><span class="line">Optional&lt;Integer&gt; max = authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(book -&gt; book.getScore())</span><br><span class="line">                .max((b1, b2) -&gt; b1 - b2);</span><br><span class="line">        System.out.println(max.get());</span><br><span class="line"><span class="comment">//最小</span></span><br><span class="line">  Optional&lt;Integer&gt; max = authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(book -&gt; book.getScore())</span><br><span class="line">                .min((b1, b2) -&gt; b1 - b2);</span><br></pre></td></tr></table></figure><p><strong>collect</strong>:流转换成collect集合</p><ol><li><p><strong>转成List</strong>:Collectors.toList()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; collect = authors1.stream()</span><br><span class="line">        .distinct()</span><br><span class="line">        .map(author -&gt; author.getName())</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li><li><p><strong>转成Set</strong> : Collectors.toSet()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; collect = authors1.stream()</span><br><span class="line">            .distinct()</span><br><span class="line">            .map(author -&gt; author.getName())</span><br><span class="line">            .collect(Collectors.toSet());</span><br></pre></td></tr></table></figure></li><li><p><strong>转成Map</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; collect = authors1.stream()</span><br><span class="line">    <span class="comment">//一定要去重,因为map键不能重复</span></span><br><span class="line">              .distinct()</span><br><span class="line">              .collect(Collectors.toMap(author -&gt; author.getName(), author -&gt; author.getAge()));</span><br><span class="line">      System.out.println(collect);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h5 id="查找与匹配"><a href="#查找与匹配" class="headerlink" title="查找与匹配"></a>查找与匹配</h5><blockquote><ol><li><p><strong>anyMatch</strong>:可以用来判断是否有任意符合匹配条件的元素，结果为boolean类型。(只要有一个满足就行)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .anyMatch(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> author.getAge() &gt; <span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .anyMatch( author-&gt; author.getAge() &gt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>allMatch</strong>:所有都满足返回true </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">            .distinct()</span><br><span class="line">            .allMatch( author-&gt; author.getAge() &gt; <span class="number">18</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>noneMatch</strong>:所有都不符合返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">              .noneMatch(author -&gt; author.getAge() &gt; <span class="number">100</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>findAny</strong>:获取随机一个元素(不能保证)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        Optional&lt;Author&gt; any = authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .findAny();</span><br><span class="line"><span class="comment">//不建议使用get,有可能是空</span></span><br><span class="line">        System.out.println(any.get());</span><br><span class="line"><span class="comment">//建议使用这个</span></span><br><span class="line">   any.ifPresent(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">               System.out.println(author);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>findFirst</strong>:获取第一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    Optional&lt;Author&gt; any = authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .findFirst();</span><br><span class="line"><span class="comment">//建议使用这个</span></span><br><span class="line">   any.ifPresent(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">               System.out.println(author);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>reduce归并</strong> :对流进行操作,按照你定的规则返回一个结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//底层</span></span><br><span class="line">  <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> identity;</span><br><span class="line"><span class="keyword">for</span> (T element : <span class="built_in">this</span> stream)</span><br><span class="line">result = accumulator.apply(result, element)</span><br><span class="line"><span class="keyword">return</span> result;  </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将所有作者的名称拼接起来</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">reduce</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(author -&gt; author.getName())</span><br><span class="line">                .reduce(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> <span class="title class_">BinaryOperator</span>&lt;String&gt;() &#123;</span><br><span class="line">                  </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String s, String s2)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> s + s2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(reduce);</span><br><span class="line"><span class="comment">//简易版</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">reduce</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(author -&gt; author.getName())</span><br><span class="line">                .reduce(<span class="string">&quot;&quot;</span>,(s1,s2)-&gt;s1+s2);</span><br><span class="line">        System.out.println(reduce);</span><br><span class="line"><span class="comment">//reduce中传一个参数的</span></span><br><span class="line">Optional&lt;String&gt; reduce = authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(author -&gt; author.getName())</span><br><span class="line">                .reduce((s1, s2) -&gt; s1 + s2);</span><br><span class="line">       reduce.ifPresent(name-&gt; System.out.println(name));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">源码为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//设定一个tag为foundAny判断是否是首次输入,如果是首次输入将首个输入赋值给result剩下操作与传初始值的操作一样</span></span><br><span class="line">    *     <span class="type">boolean</span> <span class="variable">foundAny</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">     *     <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     *     <span class="keyword">for</span> (T element : <span class="built_in">this</span> stream) &#123;</span><br><span class="line">     *         <span class="keyword">if</span> (!foundAny) &#123;</span><br><span class="line">     *             foundAny = <span class="literal">true</span>;</span><br><span class="line">     *             result = element;</span><br><span class="line">     *         &#125;</span><br><span class="line">     *         <span class="keyword">else</span></span><br><span class="line">     *             result = accumulator.apply(result, element);</span><br><span class="line">     *     &#125;</span><br><span class="line">     *     <span class="keyword">return</span> foundAny ? Optional.of(result) : Optional.empty();</span><br></pre></td></tr></table></figure></li></ol></li></ol></blockquote><h3 id="3-3注意事项"><a href="#3-3注意事项" class="headerlink" title="3.3注意事项"></a>3.3注意事项</h3><blockquote><ol><li><strong>惰性求值</strong>: 流如果没有终结操作,则中间操作不会执行</li><li><strong>流是一次性的</strong>:当一个流对象执行完一次终结操作后,再次使用中间操作或者终结操作会报错</li><li><strong>流不会干扰原数据的</strong>:流对数据进行操作时不会影响原数据,除非你在流中给引用类型赋值.</li></ol></blockquote><h2 id="4-Optional"><a href="#4-Optional" class="headerlink" title="4.Optional"></a>4.Optional</h2><h3 id="4-1概述"><a href="#4-1概述" class="headerlink" title="4.1概述"></a>4.1概述</h3><blockquote><p>代码中经常会出现空指针问题,需要  进行非空判断</p></blockquote><h3 id="4-2使用"><a href="#4-2使用" class="headerlink" title="4.2使用"></a>4.2使用</h3><h4 id="4-2-1创建"><a href="#4-2-1创建" class="headerlink" title="4.2.1创建"></a>4.2.1创建</h4><blockquote><p>Option可以将对象封装进去,然后对封装进去的数据进行操作.Option会提供方法进行非空判断.</p><ol><li><p><strong>静态方法ofNullable</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Author</span> <span class="variable">author</span> <span class="operator">=</span> getAuthor();</span><br><span class="line">        Optional&lt;Author&gt; authorOptional = Optional.ofNullable(author);</span><br></pre></td></tr></table></figure><p>也可以直接将方法的返回值设为Option,这样就可以直接接收到Option对象</p><p>底层代码:<strong>非空时调用of方法</strong>,空时调用<strong>Optional的empty()方法</strong>返回空的Optional对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">ofNullable</span><span class="params">(T value)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> value == <span class="literal">null</span> ? empty() : of(value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>静态方法of</strong>:不会进行非空判断,如果传入为空则报错(不建议使用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Author</span> <span class="variable">author</span> <span class="operator">=</span> getAuthor();</span><br><span class="line">        Optional&lt;Author&gt; authorOptional = Optional.of(author);</span><br><span class="line"><span class="comment">//传入null会报空指针异常</span></span><br><span class="line">authorOptional = Optional.of(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="4-2-2-安全消费-使用"><a href="#4-2-2-安全消费-使用" class="headerlink" title="4.2.2 安全消费(使用)"></a>4.2.2 安全消费(使用)</h4><blockquote><p>获取到Option对象后肯定需要 使用数据<strong>ifPresent</strong>:会判断Option对象是否为空,不为空则使用 .</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    author.ifPresent(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                System.out.println(author);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//简化版</span></span><br><span class="line">     author.ifPresent(au-&gt; System.out.println(au));</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-2-3-获取值"><a href="#4-2-3-获取值" class="headerlink" title="4.2.3 获取值"></a>4.2.3 获取值</h4><blockquote><p>如果我们想获取值自己进行处理可以使用get方法获取，但是不推荐。因为<strong>当Optional内部的数据为空的时候使用get()会出现异常。</strong></p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//一旦为空则会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;No value present&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> Optional&lt;Author&gt;  author= Optional.of(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//Optional中的value为null时会报错</span></span><br><span class="line">        <span class="type">Author</span> <span class="variable">author1</span> <span class="operator">=</span> author.get();</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-2-4-安全获取值"><a href="#4-2-4-安全获取值" class="headerlink" title="4.2.4 安全获取值"></a>4.2.4 安全获取值</h4><blockquote><ol><li><p><strong>orElseGet</strong>:当Option的value为空,返回你传入的内容.</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> &#123;</span><br><span class="line">    <span class="comment">//Option.value是否为空,如果为空返回other.get();other就是你传进来的接口,otherget()就是你传进来的内容</span></span><br><span class="line">     <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other.get();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt;  author= Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line"> <span class="comment">// Optional&lt;Author&gt;  author= Optional.ofNullable(new Author(18L,&quot;亚索&quot;,18,&quot;托儿所&quot;,null));</span></span><br><span class="line">        <span class="type">Author</span> <span class="variable">author1</span> <span class="operator">=</span> author.orElseGet(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Author&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Author <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Author</span>(<span class="number">19L</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">19</span>,<span class="string">&quot;法外狂徒&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(author1);</span><br></pre></td></tr></table></figure></li><li><p><strong>orElseThrow</strong>:当Option的value为空时,抛出定义的异常</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;X <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; T <span class="title function_">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X &#123;</span><br><span class="line">    <span class="comment">//如果value不为空返回value</span></span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//为空抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt;  author= Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line">     <span class="type">Author</span> <span class="variable">value</span> <span class="operator">=</span> author.orElseThrow(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Throwable&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> Throwable <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;value为空&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     System.out.println(value);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="4-2-5-过滤filter"><a href="#4-2-5-过滤filter" class="headerlink" title="4.2.5 过滤filter"></a>4.2.5 过滤filter</h4><blockquote><p>Optional也有一个filter方法,可以对数据进行过滤,如果<strong>原本有数据但是不符合规定,也会返回空value的Optional</strong></p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span> &#123;</span><br><span class="line">    <span class="comment">//做非空判断的,判断你传进来的过滤接口是否为空,如果为空抛出异常</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">public static &lt;T&gt; T requireNonNull(T obj) &#123;</span></span><br><span class="line"><span class="comment">    if (obj == null)</span></span><br><span class="line"><span class="comment">        throw new NullPointerException();</span></span><br><span class="line"><span class="comment">    return obj;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public boolean isPresent() &#123;</span></span><br><span class="line"><span class="comment">    //判断value是否为空,为空直接返回空value</span></span><br><span class="line"><span class="comment">    return value != null;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果接口不为空,value不为空,调用实现接口的test方法看最后返回的内容,如果不满足返回空value的Optional</span></span><br><span class="line">        <span class="keyword">return</span> predicate.test(value) ? <span class="built_in">this</span> : empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; author2 = author.filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> author.getAge() &gt; <span class="number">20</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-2-6-判断isPresen"><a href="#4-2-6-判断isPresen" class="headerlink" title="4.2.6 判断isPresen"></a>4.2.6 判断isPresen</h4><blockquote><p>​<strong>isPresen</strong>:判断value是否为null,为null返回false,不为null返回true</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很简单,判断value是否为null,为null返回false,不为null返回true</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPresent</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">present</span> <span class="operator">=</span> author.isPresent();</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-2-7转换map"><a href="#4-2-7转换map" class="headerlink" title="4.2.7转换map"></a>4.2.7转换map</h4><blockquote><p><strong>map</strong>:数据转换也可以做计算,并且Optional在底层做了ofNullable保证不报错</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends U&gt; mapper)</span> &#123;</span><br><span class="line">    <span class="comment">//判断传入的实现的匿名接口不为null,为null会报错</span></span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="comment">//isPresent()判断value是否为空,不为空则为进else如果为空调用empty()方法返回空的Optional</span></span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; s = author.map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Author, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> author.getName();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><h2 id="5-函数式接口"><a href="#5-函数式接口" class="headerlink" title="5.函数式接口"></a>5.函数式接口</h2><h3 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h3><blockquote><p><strong>接口中只有一个抽象方法</strong>的接口,称为函数式接口</p><p>JDK的函数式接口都有**@FuncationalInterface**注解进行标识.</p></blockquote><h3 id="5-2常见函数式接口"><a href="#5-2常见函数式接口" class="headerlink" title="5.2常见函数式接口"></a>5.2常见函数式接口</h3><blockquote><ol><li><p><strong>Consumer 消费接口</strong></p><p>无返回值,因此一般都是使用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li><li><p>​<strong>Function 计算转换接口</strong></p><p>有R类型的返回值,可以执行运算和转换操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">      </span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; Function&lt;V, R&gt; <span class="title function_">compose</span><span class="params">(Function&lt;? <span class="built_in">super</span> V, ? extends T&gt; before)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="title function_">andThen</span><span class="params">(Function&lt;? <span class="built_in">super</span> R, ? extends V&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Function&lt;T, T&gt; <span class="title function_">identity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>​<strong>Predicate 判断接口</strong></p><p>返回值为boolean类型,判断型接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>**Supplier **</p><p>T类型返回值,可以返回你想要的类型的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="5-3常用默认方法"><a href="#5-3常用默认方法" class="headerlink" title="5.3常用默认方法"></a>5.3常用默认方法</h3><blockquote><p> <strong>用于将Predicate判断接口的拼接</strong><br><strong>and</strong> 相当于&amp;&amp;</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">and</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">      Objects.requireNonNull(other);</span><br><span class="line">    <span class="comment">//返回自己的test的结果与上传进来的and里面的test</span></span><br><span class="line">      <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>or</strong>相当于||</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">or</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">       Objects.requireNonNull(other);</span><br><span class="line">       <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>negate</strong>相当于!</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">authors1.stream()</span><br><span class="line">              .distinct()</span><br><span class="line">              .filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                      <span class="keyword">return</span> author.getAge()&gt;<span class="number">10</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;.and(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                      <span class="keyword">return</span> author.getAge()&lt;<span class="number">23</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;))</span><br><span class="line">              .forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                      System.out.println(author);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="6方法引用"><a href="#6方法引用" class="headerlink" title="6方法引用"></a>6方法引用</h2><blockquote><p>当方法体重只有一个方法调用时可以对代码进行进一步简化</p></blockquote><h3 id="6-1推荐用法"><a href="#6-1推荐用法" class="headerlink" title="6.1推荐用法"></a>6.1推荐用法</h3><blockquote><p>​我们在使用lambda时不需要考虑什么时候用方法引用，用哪种方法引用，方法引用的格式是什么。我们只需要在写完lambda方法发现方法体只有一行代码，并且是方法的调用时使用快捷键尝试是否能够转换成方法引用即可。</p><p>​当我们方法引用使用的多了慢慢的也可以直接写出方法引用。</p></blockquote><h3 id="6-2-基本格式"><a href="#6-2-基本格式" class="headerlink" title="6.2 基本格式"></a>6.2 基本格式</h3><p>​类名或者对象名::方法名</p><h3 id="6-3详解"><a href="#6-3详解" class="headerlink" title="6.3详解"></a>6.3详解</h3><h4 id="6-3-1引用静态方法"><a href="#6-3-1引用静态方法" class="headerlink" title="6.3.1引用静态方法"></a>6.3.1引用静态方法</h4><blockquote><h4 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h4><p> 使用前提如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了某个类的静态方法</strong>，并且我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个静态方法中</strong>，这个时候我们就可以引用类的静态方法。</p><p>格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名::方法名</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">        Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line">        </span><br><span class="line">        authorStream.map(author -&gt; author.getAge())</span><br><span class="line">                .map(age-&gt;String.valueOf(age));</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"> List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">        Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line"></span><br><span class="line">        authorStream.map(author -&gt; author.getAge())</span><br><span class="line">                .map(String::valueOf);</span><br></pre></td></tr></table></figure></blockquote><h4 id="6-3-2-引用对象的实例方法"><a href="#6-3-2-引用对象的实例方法" class="headerlink" title="6.3.2 引用对象的实例方法"></a>6.3.2 引用对象的实例方法</h4><blockquote><h5 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名::方法名</span><br></pre></td></tr></table></figure><h5 id="使用前提-1"><a href="#使用前提-1" class="headerlink" title="使用前提"></a>使用前提</h5><p>​如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了某个对象的成员方法</strong>，并且我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个成员方法中</strong>，这个时候我们就可以引用对象的实例方法</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">authorStream.map(author -&gt; author.getName())</span><br><span class="line">        .forEach(name-&gt;sb.append(name));</span><br></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">authorStream.map(author -&gt; author.getName())</span><br><span class="line">        .forEach(sb::append);</span><br></pre></td></tr></table></figure></blockquote><h4 id="6-3-4-引用类的实例方法"><a href="#6-3-4-引用类的实例方法" class="headerlink" title="6.3.4 引用类的实例方法"></a>6.3.4 引用类的实例方法</h4><blockquote><h5 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名::方法名</span><br></pre></td></tr></table></figure><h5 id="使用前提-2"><a href="#使用前提-2" class="headerlink" title="使用前提"></a>使用前提</h5><p>​如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了第一个参数的成员方法</strong>，并且我们把要<strong>重写的抽象方法中剩余的所有的参数都按照顺序传入了这个成员方法中</strong>，这个时候我们就可以引用类的实例方法。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">interface</span> <span class="title class_">UseString</span>&#123;</span><br><span class="line">       String <span class="title function_">use</span><span class="params">(String str,<span class="type">int</span> start,<span class="type">int</span> length)</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">subAuthorName</span><span class="params">(String str, UseString useString)</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> useString.use(str,start,length);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">       subAuthorName(<span class="keyword">new</span> <span class="title class_">UseString</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> String <span class="title function_">use</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> str.substring(start,length);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    subAuthorName(String::substring);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="6-3-5-构造器引用"><a href="#6-3-5-构造器引用" class="headerlink" title="6.3.5 构造器引用"></a>6.3.5 构造器引用</h4><blockquote><p>如果方法体中的一行代码是构造器的话就可以使用构造器引用。</p><h5 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名::<span class="keyword">new</span></span><br></pre></td></tr></table></figure><h5 id="使用前提-3"><a href="#使用前提-3" class="headerlink" title="使用前提"></a>使用前提</h5><p>​如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了某个类的构造方法</strong>，并且我们把<strong>要重写的抽象方法中的所有的参数都按照顺序传入了这个构造方法中</strong>，这个时候我们就可以引用构造器。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">        .map(author -&gt; author.getName())</span><br><span class="line">        .map(name-&gt;<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(name))</span><br><span class="line">        .map(sb-&gt;sb.append(<span class="string">&quot;张三&quot;</span>).toString())</span><br><span class="line">        .forEach(str-&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">        .map(author -&gt; author.getName())</span><br><span class="line">        .map(StringBuilder::<span class="keyword">new</span>)</span><br><span class="line">        .map(sb-&gt;sb.append(<span class="string">&quot;张三&quot;</span>).toString())</span><br><span class="line">        .forEach(str-&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></blockquote><h2 id="7-高级用法"><a href="#7-高级用法" class="headerlink" title="7.高级用法"></a>7.高级用法</h2><h3 id="7-1-基本类型优化"><a href="#7-1-基本类型优化" class="headerlink" title="7.1 基本类型优化"></a>7.1 基本类型优化</h3><blockquote><p>主要还是流对象在操作时会使用包装类,会经常拆箱装箱,导致效率低下.因此可以对这一现象进行优化.</p><p>可以使用map操作进行避免</p><p>mapToInt,mapToLong,mapToDouble,flatMapToInt,flatMapToDouble</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">authors.stream()</span><br><span class="line">               .mapToInt(author -&gt; author.getAge())</span><br><span class="line">               .map(age -&gt; age + <span class="number">10</span>)</span><br><span class="line">               .filter(age-&gt;age&gt;<span class="number">18</span>)</span><br><span class="line">               .map(age-&gt;age+<span class="number">2</span>)</span><br><span class="line">               .forEach(System.out::println)</span><br></pre></td></tr></table></figure></blockquote><h3 id="7-2并行流"><a href="#7-2并行流" class="headerlink" title="7.2并行流"></a>7.2并行流</h3><blockquote><p>大量数据进行操作时,可以使用并行流提高效率,就是多项成.stream对多线程做了优化,可以使用其方法来实现,从而提高效率</p><p><strong>parallel</strong>:可以把串行流转换成并行流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用parallel需要先得到流对象</span></span><br><span class="line">authors1.stream().parallel()</span><br><span class="line">                .peek(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread()+author.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .distinct()</span><br><span class="line">                .filter(author -&gt; author.getAge()&gt;<span class="number">15</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>parallelStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用parallelStream可以直接得到流对象</span></span><br><span class="line"> authors1.parallelStream()</span><br><span class="line">                .peek(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread()+author.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .distinct()</span><br><span class="line">                .filter(author -&gt; author.getAge()&gt;<span class="number">15</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Stream流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql</title>
      <link href="/2022/03/12/mysql/"/>
      <url>/2022/03/12/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="in里面的子查询不会使用索引"><a href="#in里面的子查询不会使用索引" class="headerlink" title="in里面的子查询不会使用索引"></a>in里面的子查询不会使用索引</h1><blockquote><p> 生产尽量不用子查询</p></blockquote><h1 id="1-mysql简介"><a href="#1-mysql简介" class="headerlink" title="1. mysql简介"></a>1. mysql简介</h1><ul><li><p>MySQL是一个<strong>关系型数据库管理系统</strong></p></li><li><p>由瑞典MySQL AB 公司开发，属于 <a href="https://baike.baidu.com/item/Oracle">Oracle</a> 旗下产品</p></li><li><p>Mysql是一个<strong>开源免费的</strong>关系型数据库管理系统</p></li><li><p>mysql分为社区办和企业版</p></li><li><p>我们学习的是社区版</p></li></ul><hr><h1 id="2-关系型数据库"><a href="#2-关系型数据库" class="headerlink" title="2. 关系型数据库"></a>2. 关系型数据库</h1><p>建立在关系模型基础上的数据库,借助数学中的集合代数等一些数学概念和方法,处理关系型数据库中的数据</p><hr><h1 id="3-Mysql的安装"><a href="#3-Mysql的安装" class="headerlink" title="3. Mysql的安装"></a>3. Mysql的安装</h1><ul><li>windows的安装</li><li>Linux的安装</li></ul><hr><h1 id="4-Mysql默认的字符集的配置-了解"><a href="#4-Mysql默认的字符集的配置-了解" class="headerlink" title="4. Mysql默认的字符集的配置(了解)"></a>4. Mysql默认的字符集的配置(了解)</h1><p>以windows中的mysql的配置为例:</p><ul><li><p>找到mysql的存放配置文件的地方 <code>C:\ProgramData\MySQL\MySQL Server 5.6/my.ini</code></p></li><li><p>修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>但是: <strong>我们完全不建议这样修改</strong>,因为我们每个项目系统使用的数据库编码完全有可能不一样;</p></blockquote><hr><h1 id="5-启动和停止mysql的服务"><a href="#5-启动和停止mysql的服务" class="headerlink" title="5. 启动和停止mysql的服务"></a>5. 启动和停止mysql的服务</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br><span class="line">net stop mysql</span><br></pre></td></tr></table></figure><p>注意: 如果命令显式不可用代表操作系统的版本不支持(家庭版)</p><hr><h1 id="6-mysql的登录命令"><a href="#6-mysql的登录命令" class="headerlink" title="6. mysql的登录命令"></a>6. mysql的登录命令</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u用户名  <span class="operator">-</span>p密码 </span><br><span class="line"><span class="operator">-</span>h: 默认为localhost</span><br><span class="line"><span class="operator">-</span>P: 默认<span class="number">3306</span></span><br></pre></td></tr></table></figure><hr><h1 id="7-mysql常用的系统命令"><a href="#7-mysql常用的系统命令" class="headerlink" title="7. mysql常用的系统命令"></a>7. mysql常用的系统命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看mysql的版本</span></span><br><span class="line">SELECT VERSION();</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看mysql当前登录的用户</span></span><br><span class="line">select user();</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看mysql的当前日期</span></span><br><span class="line">select now();</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看当前所在的数据库</span></span><br><span class="line">select database();</span><br></pre></td></tr></table></figure><hr><h1 id="8-mysql的语句规范"><a href="#8-mysql的语句规范" class="headerlink" title="8. mysql的语句规范"></a>8. mysql的语句规范</h1><ul><li>关键字和函数名建议大写</li><li>数据库的名称,表的名称,字段的名称建议小写</li><li>数据库 表名 字段名建议加上&#96;&#96;</li><li>sql语句的<strong>定界符</strong>默认以 ; 结尾</li></ul><hr><h1 id="9-数据库的操作SQL类型-了解"><a href="#9-数据库的操作SQL类型-了解" class="headerlink" title="9. 数据库的操作SQL类型(了解)"></a>9. 数据库的操作SQL类型(了解)</h1><ul><li><p>DDL(数据定义语言)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE/VIEW/INDEX</span><br></pre></td></tr></table></figure></li><li><p>DML(数据操纵语言)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 插入：<span class="keyword">INSERT</span></span><br><span class="line"><span class="number">2</span>) 更新：<span class="keyword">UPDATE</span></span><br><span class="line"><span class="number">3</span>) 删除：<span class="keyword">DELETE</span></span><br></pre></td></tr></table></figure></li><li><p>DQL(数据查询语言)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DQL基本结构是由<span class="keyword">SELECT</span>子句，<span class="keyword">FROM</span>子句，<span class="keyword">WHERE</span></span><br><span class="line">子句组成的查询块：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>字段名表<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表或视图名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>查询条件<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><hr></li></ul><h1 id="10-mysql中的概念"><a href="#10-mysql中的概念" class="headerlink" title="10. mysql中的概念"></a>10. mysql中的概念</h1><ul><li>数据库管理系统: 管理数据库的系统</li><li>数据库: 数组库是用来存放和组织<code>表</code>的</li><li>表:是存储数据的<strong>容器</strong>  </li><li>记录: 一行的数据</li><li>属性: 一列属性值</li></ul><hr><h1 id="11-数据库的操作-必会"><a href="#11-数据库的操作-必会" class="headerlink" title="11. 数据库的操作(必会)"></a>11. 数据库的操作(必会)</h1><ul><li>创建数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `db2`; #最简单的方式创建一个数据库</span><br></pre></td></tr></table></figure><p>注意: 数据库的名称可以加 &#96;&#96; ,也可以不加,默认mysql会给你自动加上</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE db2;  #可以省略``</span><br></pre></td></tr></table></figure><ul><li>带判断的创建数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `db1`; #如果不存在db1这个数据库则创建db1数据库,如果存在则不会创建但是也不会报错</span><br></pre></td></tr></table></figure><ul><li>创建数据库并且指定字符集</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#mysql默认的字符集是latin1,latin1不支持中文</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `db3` <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8MB4;</span><br></pre></td></tr></table></figure><ul><li>删除数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#删除数据库,如果数据库不存在则会报错</span><br><span class="line"><span class="keyword">DROP</span> DATABASE `db1`;</span><br><span class="line">#带判断的删除数据库</span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `db1`</span><br></pre></td></tr></table></figure><ul><li>查询数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查询数据库的创建信息</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE `db3`;</span><br><span class="line">#查询当前RDBMS中有哪些数据库</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br><span class="line">#查询当前所在的数据库</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br></pre></td></tr></table></figure><ul><li>进入数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE <span class="string">&#x27;db1&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="12-mysql中的数据类型"><a href="#12-mysql中的数据类型" class="headerlink" title="12. mysql中的数据类型"></a>12. mysql中的数据类型</h1><h2 id="12-1-整形"><a href="#12-1-整形" class="headerlink" title="12.1 整形"></a>12.1 整形</h2><table><thead><tr><th align="center">类型</th><th align="center">范围</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><strong>tinyint</strong></td><td align="center"><strong>1个字节 范围(-128<del>127)||0</del>255(无符号)</strong></td><td align="center"><strong>与java中的byte类型对应</strong></td></tr><tr><td align="center"><strong>smallint</strong></td><td align="center"><strong>2个字节 范围(-32768~32767|| 0 ~ 65535(无符号))</strong></td><td align="center"><strong>与java中的short对应</strong></td></tr><tr><td align="center">mediumint</td><td align="center">3 个字节, -8388608 to 8388607||0 to 16777215(无符号)</td><td align="center"></td></tr><tr><td align="center"><strong>int:Integer</strong></td><td align="center">4 个字节, -2147483648 to 2147483647||0 to 4294967295(无符号)</td><td align="center">与Java中的int类型对应</td></tr><tr><td align="center"><strong>bigint</strong></td><td align="center">8 个字节, -9223372036854775808 to 922337203685477580||0 to 18446744073709551615(无符号)</td><td align="center"><strong>与java中的long对应</strong></td></tr></tbody></table><hr><h2 id="12-2-浮点型"><a href="#12-2-浮点型" class="headerlink" title="12.2 浮点型"></a>12.2 浮点型</h2><table><thead><tr><th align="center">类型</th><th align="center">范围</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">float(m,d)</td><td align="center">单精度浮点型  8位精度(4字节)   m总个数，d小数位</td><td align="center">与java的float对应</td></tr><tr><td align="center">double(m,d)</td><td align="center">双精度浮点型  16位精度(8字节)   m总个数，d小数位</td><td align="center">与java的double对应</td></tr></tbody></table><p>注意: 在实际开发过程中设计数据库时&#x3D;&#x3D;一定一定一定&#x3D;&#x3D;,<strong>涉及到小数的不要使用FLOAT和DOUBLE类型</strong></p><hr><h2 id="12-3-定点"><a href="#12-3-定点" class="headerlink" title="12.3 定点"></a>12.3 定点</h2><p>浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值</p><table><thead><tr><th align="center">类型</th><th align="center">范围</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">decimal(m,d)</td><td align="center">参数m&lt;65 是总个数，d&lt;30且 d&lt;m 是小数位</td><td align="center">表示金额等精确值</td></tr></tbody></table><p>注意: Decimal这个类型如果Insert的数据比我们预设的d的长度大,也会进行四舍五入;  一般存储小数都会使用DECIMAL类型,<strong>不会丢失精度</strong></p><hr><h2 id="12-4-字符串"><a href="#12-4-字符串" class="headerlink" title="12.4 字符串"></a>12.4 字符串</h2><table><thead><tr><th align="center">类型</th><th align="center">范围</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><strong>char(n)</strong></td><td align="center"><strong>固定长度，最多255个</strong></td><td align="center">定长字符串,n 范围(0,255)， 如果不是定长的数据，n&lt;&#x3D;4 时才使用</td></tr><tr><td align="center"><strong>varchar(n)</strong></td><td align="center">最多65532个字符</td><td align="center">变长字符串，65532&gt;n&gt;4, 注意，n 是字符数，而不是字节数</td></tr><tr><td align="center">tinytext</td><td align="center">存储 L+1 个字节，其中 L &lt; 2^8</td><td align="center"></td></tr><tr><td align="center"><strong>text</strong></td><td align="center">存储 L+2 个字节，其中 L &lt; 2^16</td><td align="center">存储文本的</td></tr><tr><td align="center">mediumtext</td><td align="center">存储 L+3 个字节，其中 L &lt; 2^24</td><td align="center"></td></tr><tr><td align="center">longtext</td><td align="center">存储 L+4 个字节，其中 L &lt; 2^32</td><td align="center"></td></tr></tbody></table><h2 id="12-5-Blob二进制类型"><a href="#12-5-Blob二进制类型" class="headerlink" title="12.5 Blob二进制类型"></a>12.5 Blob二进制类型</h2><ul><li><p>BLOB和text存储方式不同，TEXT以文本方式存储，英文存储区分大小写，而Blob是以二进制方式存储，不分大小写。</p></li><li><p>BLOB存储的数据只能整体读出。 </p></li><li><p>TEXT可以指定字符集，BLOB不用指定字符集。</p></li></ul><hr><h2 id="12-6-日期时间类型"><a href="#12-6-日期时间类型" class="headerlink" title="12.6 日期时间类型"></a>12.6 日期时间类型</h2><table><thead><tr><th align="center">类型</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">date</td><td align="center">日期 ‘2008-12-2’</td></tr><tr><td align="center">time</td><td align="center">时间 ‘12:25:36’</td></tr><tr><td align="center">datetime</td><td align="center">日期时间 ‘2008-12-2 22:06:44’</td></tr><tr><td align="center">timestamp</td><td align="center">自动存储记录修改时间</td></tr></tbody></table><hr><h1 id="13-mysql中数据类型属性-约束"><a href="#13-mysql中数据类型属性-约束" class="headerlink" title="13. mysql中数据类型属性(约束)"></a>13. mysql中数据类型属性(约束)</h1><table><thead><tr><th align="center">MySQL关键字</th><th align="center">含义</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">NULL</td><td align="center">数据列可包含NULL值</td><td align="center">mysql默认不指定约束,字段也不添加值,默认为NULL</td></tr><tr><td align="center">NOT NULL</td><td align="center">数据列不允许包含NULL值</td><td align="center">非空约束</td></tr><tr><td align="center">DEFAULT</td><td align="center">默认值</td><td align="center">默认值约束</td></tr><tr><td align="center">PRIMARY KEY</td><td align="center">主键</td><td align="center">主键约束 &#x3D; 非空约束+唯一约束</td></tr><tr><td align="center">AUTO_INCREMENT</td><td align="center">自动递增，适用于整数类型</td><td align="center">自增(一般和<strong>数值类型的主键</strong>联合使用)</td></tr><tr><td align="center">UNSIGNED</td><td align="center">无符号</td><td align="center">保留正数部分</td></tr><tr><td align="center">UNIQUE</td><td align="center">唯一约束</td><td align="center">此字段的值不能重复</td></tr></tbody></table><hr><h1 id="14-表的操作"><a href="#14-表的操作" class="headerlink" title="14. 表的操作"></a>14. 表的操作</h1><p>数据表是数据库的最重要的组成部分之一,是其他对象的基础;</p><h2 id="14-1-查看数据库中的所有的表"><a href="#14-1-查看数据库中的所有的表" class="headerlink" title="14.1 查看数据库中的所有的表"></a>14.1 查看数据库中的所有的表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure><hr><h2 id="14-2-创建表"><a href="#14-2-创建表" class="headerlink" title="14.2 创建表"></a>14.2 创建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  `<span class="keyword">user</span>`(id <span class="type">int</span>,name <span class="type">char</span>(<span class="number">32</span>),age tinyint);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 带条件的创建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`(id <span class="type">int</span>,name <span class="type">char</span>(<span class="number">32</span>),age tinyint);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时指定字符集,如果不指定默认使用的是数据库的字符集</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`(id <span class="type">int</span>,name <span class="type">char</span>(<span class="number">32</span>),age tinyint) <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看表结构</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> `<span class="keyword">user</span>`;</span><br><span class="line"><span class="keyword">DESC</span> `<span class="keyword">user</span>`;  #简写</span><br></pre></td></tr></table></figure><hr><h2 id="14-3-删除表"><a href="#14-3-删除表" class="headerlink" title="14.3 删除表"></a>14.3 删除表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 带判断的删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`;</span><br></pre></td></tr></table></figure><hr><h2 id="14-4-修改表结构"><a href="#14-4-修改表结构" class="headerlink" title="14.4 修改表结构"></a>14.4 修改表结构</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">member</span>` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> sex <span class="type">CHAR</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- COLUMN关键字可以省略</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">member</span>` <span class="keyword">ADD</span>  sex <span class="type">CHAR</span>(<span class="number">1</span>);  </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">member</span> <span class="keyword">DROP</span> <span class="keyword">COLUMN</span>  city;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">member</span> <span class="keyword">DROP</span>  city;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询列</span></span><br><span class="line"><span class="keyword">DESC</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MODIFY只能修改列的属性 不能修改名字</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">member</span> MODIFY age <span class="type">SMALLINT</span>;</span><br><span class="line"><span class="comment">-- CHANGE 既能修改列的名称也能修改列的属性</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">member</span> CHANGE sex sex1 <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="15-记录-数据-的操作"><a href="#15-记录-数据-的操作" class="headerlink" title="15. 记录(数据)的操作"></a>15. 记录(数据)的操作</h1><h2 id="15-1-添加数据"><a href="#15-1-添加数据" class="headerlink" title="15.1 添加数据"></a>15.1 添加数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给表插入一条数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span>(id,nick_name,age,sex) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;小明&#x27;</span>,<span class="number">12</span>,<span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 批量插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span>(id,nick_name,age,sex) <span class="keyword">VALUES</span>(<span class="number">4</span>,&quot;小短腿&quot;,<span class="number">10</span>,<span class="string">&#x27;男&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;大胖&#x27;</span>,<span class="number">30</span>,<span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 骚操作(不指定字段全量插入)----&gt;一般不建议使用全量插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span> <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;小明&#x27;</span>,<span class="number">20</span>);</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span> <span class="keyword">VALUES</span>(<span class="keyword">DEFAULT</span>,<span class="string">&#x27;小明&#x27;</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="15-2-查询数据-简单查询"><a href="#15-2-查询数据-简单查询" class="headerlink" title="15.2 查询数据(简单查询)"></a>15.2 查询数据(简单查询)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 最简单的查询语句</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询指定的字段</span></span><br><span class="line"><span class="keyword">SELECT</span> nick_name <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="15-3-修改数据"><a href="#15-3-修改数据" class="headerlink" title="15.3 修改数据"></a>15.3 修改数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">member</span> <span class="keyword">SET</span> nick_name<span class="operator">=</span><span class="string">&#x27;小胖子&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="15-4-删除数据"><a href="#15-4-删除数据" class="headerlink" title="15.4 删除数据"></a>15.4 删除数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;                               </span><br></pre></td></tr></table></figure><hr><h1 id="16-表和表之间关系"><a href="#16-表和表之间关系" class="headerlink" title="16. 表和表之间关系"></a>16. 表和表之间关系</h1><h2 id="16-1-一对一的关系"><a href="#16-1-一对一的关系" class="headerlink" title="16.1 一对一的关系"></a>16.1 一对一的关系</h2><p>例如: 一个会员表中的一条记录只对应我们身份证表中的一条记录</p><ul><li><p>我们如果设计数据库时出现了一对一的表应该尽量避免;我们只需要给字段多的一方的表<strong>添加额外的字段即可</strong></p></li><li><p>如果我们设计的时候**无法避免(考虑的优化为题)**一对一的设计,我们需要让两个表的主键进行对应</p></li><li><p>如果一个表中的字段的个数超过16个,<strong>强烈建议</strong>使用一对一的表的设计</p></li></ul><hr><h2 id="16-2-一对多的关系"><a href="#16-2-一对多的关系" class="headerlink" title="16.2 一对多的关系"></a>16.2 一对多的关系</h2><p>例如: 一个会员对应多个订单,而一个订单只对应一个会员</p><ul><li>在多的一方的表加一个字段对应一的一方的表中的主键,数据类型要保持一致</li><li>而且我们根据墨菲定律,还可以为其加一个约束条件(<strong>外键(FOREIGN KEY)</strong>)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在表创建之后添加外键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在多的一方的表中添加了一个字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> m_id <span class="type">INT</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加外键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY orders(m_id)  <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY(m_id)  <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 可以指定外键的名称</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> ifbk_orders_mid_merber <span class="keyword">FOREIGN</span> KEY(m_id)  <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表的时候直接添加外键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> orders(</span><br><span class="line">id <span class="type">INT</span>  AUTO_INCREMENT COMMENT <span class="string">&#x27;订单ID&#x27;</span>,</span><br><span class="line">number <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单编号&#x27;</span>,</span><br><span class="line">address <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单的发货地址&#x27;</span>,</span><br><span class="line">m_id <span class="type">INT</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY(m_id) <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id)</span><br><span class="line">) COMMENT <span class="string">&#x27;订单表&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><p>创建一对多的表的时候,首先要创建一方对应的那个表</p></li><li><p>我们为了数据的安全性,我们会把多方中的参照的字段设置为外键,而且类型要和一方中的主键保持一致</p></li><li><p><strong>一般我们在商业项目中,尽量不要使用外键(等会解释)</strong></p></li></ul><hr><h2 id="16-3-多对多的关系"><a href="#16-3-多对多的关系" class="headerlink" title="16.3 多对多的关系"></a>16.3 多对多的关系</h2><p><img src="/upload/image-20201122113930434.png" alt="image-20201122113930434"></p><blockquote><p>思想: 借助一个额外的表,实现多对多关系</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建商品表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> shop(</span><br><span class="line">id <span class="type">INT</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">shop_name <span class="type">VARCHAR</span>(<span class="number">255</span>) COMMENT <span class="string">&#x27;商品名称&#x27;</span>,</span><br><span class="line">stock <span class="type">INT</span> UNSIGNED COMMENT <span class="string">&#x27;商品库存&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">) COMMENT <span class="string">&#x27;商品表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> member_shop;</span><br><span class="line"><span class="comment">-- 创建第三方的表(member_shop)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>  member_shop(</span><br><span class="line">m_id <span class="type">INT</span> COMMENT <span class="string">&#x27;参照member中的id&#x27;</span>,</span><br><span class="line">s_id <span class="type">INT</span> COMMENT <span class="string">&#x27;参照shop中的id&#x27;</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY(m_id) <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id),</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY(s_id) <span class="keyword">REFERENCES</span> shop(id)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT <span class="string">&#x27;第三方的表&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="17-mysql的多字段查询"><a href="#17-mysql的多字段查询" class="headerlink" title="17. mysql的多字段查询"></a>17. mysql的多字段查询</h1><blockquote><p>select * 这种方式不建议使用,我们只查询需要的字段,select * 这种方式对性能有影响</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询多个字段</span></span><br><span class="line"><span class="keyword">SELECT</span> nick_name,age <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询字段并且指定字段的别名</span></span><br><span class="line"><span class="keyword">SELECT</span> nick_name <span class="keyword">AS</span> nname,age <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br><span class="line"><span class="keyword">SELECT</span> nick_name  nname,age <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这才是一条完整的sql语句,我们在实际的开发中不会写这个多的东西,会省略一些东西(库名,字段的别名,表的别名...),sql的执行引擎会帮我们进行词法和语法的补全</span></span><br><span class="line"><span class="keyword">SELECT</span> db3.member.nick_name <span class="keyword">AS</span> nick_name,db3.member.age <span class="keyword">AS</span> age <span class="keyword">FROM</span> db3.member <span class="keyword">AS</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="18-mysql中的排序"><a href="#18-mysql中的排序" class="headerlink" title="18. mysql中的排序"></a>18. mysql中的排序</h1><blockquote><p>ORDER BY col_name ASC|DESC</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不指定任何的排序字段的情况下,默认是按主键的升序排列的</span></span><br><span class="line"><span class="keyword">SELECT</span> id,nick_name,age <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 指定按age来排序(默认是升序)</span></span><br><span class="line"><span class="keyword">SELECT</span> id,nick_name,age <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 指定按age的降序进行排序</span></span><br><span class="line"><span class="keyword">SELECT</span> id,nick_name,age <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span> ;</span><br></pre></td></tr></table></figure><hr><h1 id="19-mysql中的分组查询"><a href="#19-mysql中的分组查询" class="headerlink" title="19. mysql中的分组查询"></a>19. mysql中的分组查询</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    sname <span class="type">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">    age TINYINT UNSIGNED,</span><br><span class="line">    grade <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询grade字段不为NULL的总记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询每个班级及其班级的总人数</span></span><br><span class="line"><span class="keyword">SELECT</span> grade, <span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span>(grade);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- HAING 是对分组后的数据进行条件过滤</span></span><br><span class="line"><span class="keyword">SELECT</span> grade, <span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span>(grade) <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(grade)<span class="operator">&gt;</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询年龄age&gt;25的,班级及其班级里面的人数  WHERE 是对分组之前的数据进行筛选</span></span><br><span class="line"><span class="keyword">SELECT</span> grade,<span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">25</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span>(grade) ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询年龄age&gt;25的,班级人数&gt;1的,班级及其班级里面的人数</span></span><br><span class="line"><span class="keyword">SELECT</span> grade,<span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">25</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span>(grade) <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(grade)<span class="operator">&gt;</span><span class="number">1</span> ;</span><br></pre></td></tr></table></figure><hr><h1 id="20-AND和OR"><a href="#20-AND和OR" class="headerlink" title="20. AND和OR"></a>20. AND和OR</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- and代表两个添加都成立</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span>  <span class="keyword">WHERE</span>  age<span class="operator">&gt;</span><span class="number">25</span> <span class="keyword">AND</span> sex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- or其中只要有一个成立则查出来</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span>  <span class="keyword">WHERE</span>  age<span class="operator">&gt;</span><span class="number">25</span> <span class="keyword">OR</span> sex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span> </span><br></pre></td></tr></table></figure><hr><h1 id="21-IN和NOT-IN"><a href="#21-IN和NOT-IN" class="headerlink" title="21. IN和NOT IN"></a>21. IN和NOT IN</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 多个OR连接并不是很方便</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">OR</span> age<span class="operator">=</span><span class="number">40</span> <span class="keyword">OR</span> age<span class="operator">=</span><span class="number">50</span> <span class="keyword">OR</span> age<span class="operator">=</span><span class="number">45</span> ;</span><br><span class="line"><span class="comment">-- 使用IN进行匹配,达到上面OR的效果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="keyword">IN</span>(<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">45</span>) ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 多个AND连接不方便</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="operator">!=</span> <span class="number">30</span> <span class="keyword">AND</span> age<span class="operator">!=</span><span class="number">40</span> <span class="keyword">AND</span> age<span class="operator">!=</span><span class="number">50</span> <span class="keyword">AND</span> age<span class="operator">!=</span><span class="number">45</span> ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="keyword">NOT</span> <span class="keyword">IN</span>(<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">45</span>) ;</span><br></pre></td></tr></table></figure><hr><h1 id="22-BETWEEN…AND"><a href="#22-BETWEEN…AND" class="headerlink" title="22. BETWEEN…AND"></a>22. BETWEEN…AND</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询指定区域内的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age<span class="operator">&gt;=</span><span class="number">30</span> <span class="keyword">AND</span> age<span class="operator">&lt;=</span><span class="number">40</span></span><br><span class="line"><span class="comment">-- 也可以使用BETWEEN...and来代替</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">30</span> <span class="keyword">AND</span> <span class="number">40</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="23-NOT-BETWEEN…AND"><a href="#23-NOT-BETWEEN…AND" class="headerlink" title="23. NOT BETWEEN…AND"></a>23. NOT BETWEEN…AND</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age<span class="operator">&lt;</span><span class="number">30</span> <span class="keyword">OR</span> age<span class="operator">&gt;</span><span class="number">40</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">30</span> <span class="keyword">AND</span> <span class="number">40</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="24-mysql的子查询"><a href="#24-mysql的子查询" class="headerlink" title="24. mysql的子查询"></a>24. mysql的子查询</h1><p>把一个查询的结果当成另一个查询的条件进行使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询小花购买过的全部的商品</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  member_shop </span><br><span class="line"><span class="keyword">WHERE</span> m_id <span class="operator">=</span> </span><br><span class="line">  (<span class="keyword">SELECT</span> </span><br><span class="line">    id</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    <span class="keyword">member</span> </span><br><span class="line">  <span class="keyword">WHERE</span> nick_name <span class="operator">=</span> <span class="string">&#x27;小花&#x27;</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="25-多表连接查询"><a href="#25-多表连接查询" class="headerlink" title="25. 多表连接查询"></a>25. 多表连接查询</h1><ul><li><p>内连接(显式内连接)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询小花下过的订单(使用多表连接进行查询)  笛卡尔积</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  member.id m_id,</span><br><span class="line">  member.nick_name,</span><br><span class="line">  orders.`address`,</span><br><span class="line">  orders.`create_time` </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">member</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders </span><br><span class="line"><span class="keyword">ON</span> member.id <span class="operator">=</span> orders.m_id </span><br><span class="line"><span class="keyword">WHERE</span> member.nick_name <span class="operator">=</span> <span class="string">&#x27;小花&#x27;</span> ;</span><br></pre></td></tr></table></figure><p>注意:我们使用内连接的时候可以省略<code>INNER JOIN</code>,使<code>逗号</code>在多个表之间进行连接(隐式连接),连接条件也要使用<code>WHERE</code>关键系代替<code>ON</code>关键字</p><p>隐式连接的<strong>语法不太友好</strong>,简单的多个表之间的查询可以使用,但是复杂的sql就不建议使用<code>隐式连接</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询小花下过的订单(使用多表连接进行查询)  笛卡尔积</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  m.id  m_id,</span><br><span class="line">  m.nick_name,</span><br><span class="line">  o.`address`,</span><br><span class="line">  o.`create_time`</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">member</span> m,</span><br><span class="line">  orders o</span><br><span class="line"><span class="keyword">WHERE</span> m.id <span class="operator">=</span> o.m_id </span><br><span class="line">  <span class="keyword">AND</span> m.nick_name <span class="operator">=</span> <span class="string">&#x27;小花&#x27;</span> ;</span><br></pre></td></tr></table></figure></li><li><p>外链接</p><ul><li><p>左外连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  member.id m_id,</span><br><span class="line">  member.nick_name,</span><br><span class="line">  orders.`address`,</span><br><span class="line">  orders.`create_time` </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">member</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders </span><br><span class="line"><span class="keyword">ON</span> member.id <span class="operator">=</span> orders.m_id </span><br><span class="line"><span class="keyword">AND</span> member.nick_name <span class="operator">=</span> <span class="string">&#x27;小花&#x27;</span> ;</span><br></pre></td></tr></table></figure></li><li><p>右外连接(不建议使用,因为可以直接转换为左外链接)</p></li></ul><hr></li></ul><h1 id="26-多表的连接的商业项目使用建议"><a href="#26-多表的连接的商业项目使用建议" class="headerlink" title="26. 多表的连接的商业项目使用建议"></a>26. 多表的连接的商业项目使用建议</h1><ul><li>多表连接时尽量使用<strong>显式连接</strong>,因为显式连接的sql的语义明确</li><li>生产环境建议表的联查个数不要超过3张表(可以是3张)</li><li>如果3张表的联查还不能解决你的问题,那么你就需要在<strong>业务层面解决</strong>或者是<strong>数据库设计缺陷</strong></li><li><strong>在项目中不建议使用外键</strong>,我们完全可以在业务层保证数据的安全性;<ul><li>数据库本质的作用是用来存储数据,而不是进行数据约束的;因为外检会造成我们数据源库迁移的灾难;</li></ul></li></ul><hr><h1 id="27-级联删除与级联更新"><a href="#27-级联删除与级联更新" class="headerlink" title="27. 级联删除与级联更新"></a>27. 级联删除与级联更新</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ON DELETE CASCADE  级联删除</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY(`m_id`) <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ON UPDATE CASCADE   级联更新</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders  <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY (`m_id`) <span class="keyword">REFERENCES</span> <span class="keyword">member</span> (`id`)  <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE;</span><br></pre></td></tr></table></figure><p>当然级联更新和级联删除时可以同时设置的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders  <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY (`m_id`) <span class="keyword">REFERENCES</span> <span class="keyword">member</span> (`id`) </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE  <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE;</span><br></pre></td></tr></table></figure><blockquote><p>也可以借助可视化工具进行修改级联删除和级联更新</p></blockquote><hr><h1 id="28-mysql中的分隔符-定界符"><a href="#28-mysql中的分隔符-定界符" class="headerlink" title="28. mysql中的分隔符(定界符)"></a>28. mysql中的分隔符(定界符)</h1><p>mysql中默认的分割符是 <code>;</code>  也就是说遇到 <code>;</code> 就会立即执行sql</p><p>在<strong>函数 存储过程</strong>这些特性中需要写多个sql组成一个整体,当成整体来执行,而这些特性中,一条一条的语句之间语法规定必须用<code>;</code>来分开</p><p>所以我们要创建函数 存储过程 必须先要把默认的分隔符 <code>;</code>替换成其他的符号;</p><p><strong>在会话中替换默认的分隔符,使用下面语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$  </span><br></pre></td></tr></table></figure><hr><h1 id="29-mysql中的函数"><a href="#29-mysql中的函数" class="headerlink" title="29. mysql中的函数"></a>29. mysql中的函数</h1><p><img src="/upload/image-20201125194255210.png" alt="image-20201125194255210"></p><p>函数:在编程中函数其实就是一段业务的封装</p><p>mysql中的函数: 对多个sql业务的封装,<strong>避免反复的进行词法和语法分析</strong></p><h2 id="29-1-系统函数"><a href="#29-1-系统函数" class="headerlink" title="29.1 系统函数"></a>29.1 系统函数</h2><p>mysql系统帮我们定义的函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询mysql系统当前时间</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW();</span><br><span class="line"><span class="comment">-- 查询当前mysql的版本</span></span><br><span class="line"><span class="keyword">SELECT</span> VERSION();</span><br><span class="line"><span class="comment">-- 查询当前所在的数据库</span></span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"><span class="comment">-- 查询当前登录mysql的用户和主机</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>();</span><br><span class="line"><span class="comment">-- 获取一个字符串对应的md5值</span></span><br><span class="line"><span class="keyword">SELECT</span> MD5(&quot;HELLO&quot;);</span><br></pre></td></tr></table></figure><hr><h2 id="29-2-聚合函数"><a href="#29-2-聚合函数" class="headerlink" title="29.2 聚合函数"></a>29.2 聚合函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 统计某个字段的记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(`age`) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="comment">-- 查询某个字段的最大值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(age) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="comment">-- 查询某个字段的最小值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(age) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="comment">-- 查询某个字段的平均值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(age) <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><hr><h2 id="29-3-自定义函数-了解"><a href="#29-3-自定义函数-了解" class="headerlink" title="29.3 自定义函数(了解)"></a>29.3 自定义函数(了解)</h2><p>我们自己编写的函数</p><ul><li>函数的参数</li><li>返回值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 函数的可以返回任意类型的值,也可以接受任意类型的值为参数</span><br><span class="line">- 函数的返回值和参数没有必然联系的</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名称(参数名称 参数类型) <span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">函数语句 #函数语句只有一条时,可以省略<span class="keyword">BEGIN</span>和<span class="keyword">END</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 首先创建函数之前一定要先修改其定界符,要不然遇到函数中的第一个;就会执行报错</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> MYADD (a <span class="type">INT</span>,b <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span> </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">DECLARE</span> i <span class="type">INT</span> ; <span class="comment">-- 变量的定义</span></span><br><span class="line">  <span class="keyword">SET</span> i <span class="operator">=</span> a<span class="operator">+</span>b ; <span class="comment">-- 给变量设置值</span></span><br><span class="line">  <span class="keyword">RETURN</span> i ;  <span class="comment">-- 返回数据</span></span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> MYADD(<span class="number">12</span>,<span class="number">22</span>); <span class="comment">-- 函数的调用</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建自定义函数</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> STUAGEGTCOUNT (a <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">BIGINT</span> </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">DECLARE</span> c <span class="type">BIGINT</span>;</span><br><span class="line">   <span class="keyword">SET</span> c<span class="operator">=</span>(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span>a);</span><br><span class="line">   <span class="keyword">RETURN</span> c;</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line"><span class="comment">-- 调用自定义函数</span></span><br><span class="line"><span class="keyword">SELECT</span> STUAGEGTCOUNT(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p><strong>函数的调用</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 函数名称(实参列表);</span><br></pre></td></tr></table></figure><p><strong>删除函数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> [IF <span class="keyword">EXISTS</span>]  `MYADD`</span><br></pre></td></tr></table></figure><p><strong>自定义函数可能出现错误:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">错误代码： <span class="number">1418</span></span><br><span class="line">This <span class="keyword">function</span> has <span class="keyword">none</span> <span class="keyword">of</span> <span class="keyword">DETERMINISTIC</span>, <span class="keyword">NO</span> <span class="keyword">SQL</span>, <span class="keyword">or</span> <span class="keyword">READS</span> <span class="keyword">SQL</span> DATA <span class="keyword">in</span> its declaration <span class="keyword">and</span> <span class="type">binary</span> logging <span class="keyword">is</span> enabled (you <span class="operator">*</span>might<span class="operator">*</span> want <span class="keyword">to</span> use the less safe log_bin_trust_function_creators variable)</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;原因:&#x3D;&#x3D;mysql在新版本中添加<strong>函数保护器</strong>,默认如果不进行配置,则无法创建自定义函数,我们需要在当前会话中把函数保护器关掉,尽量不要在全局(系统的配置文件)关闭函数保护器;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看函数保护器的状态</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> &quot;%log_bin_trust_function_creators%&quot;</span><br><span class="line"><span class="comment">-- OFF:不能创建自定义函数(保护器处于开启状态)</span></span><br><span class="line"><span class="comment">-- ON:能创建自定义函数(保护器关闭)</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 允许创建自定义函数</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>经过上面的设置我们就可以正常的创建自定义函数了;</p><hr><h1 id="30-mysql存储过程-了解"><a href="#30-mysql存储过程-了解" class="headerlink" title="30. mysql存储过程(了解)"></a>30. mysql存储过程(了解)</h1><h2 id="30-1-sql语句的执行流程"><a href="#30-1-sql语句的执行流程" class="headerlink" title="30.1 sql语句的执行流程"></a>30.1 sql语句的执行流程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>语句<span class="comment">---&gt;sql执行优化器(编译)---&gt;词法分析,语法分析---&gt;sql优化---&gt;运行sql(读取数据)--&gt;结果</span></span><br></pre></td></tr></table></figure><hr><h2 id="30-2-什么是存储过程"><a href="#30-2-什么是存储过程" class="headerlink" title="30.2 什么是存储过程?"></a>30.2 什么是存储过程?</h2><p> sql语句的编译的集合,以名称来存储,合并为一个单元处理;</p><hr><h2 id="30-3-存储过程的特点"><a href="#30-3-存储过程的特点" class="headerlink" title="30.3 存储过程的特点"></a>30.3 存储过程的特点</h2><ul><li>实现较快的执行速度(避免重复的编译,词法分析,语法分析等操作)</li><li>减少网络流量</li></ul><hr><h2 id="30-4-存储过程的语法"><a href="#30-4-存储过程的语法" class="headerlink" title="30.4 存储过程的语法"></a>30.4 存储过程的语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建存储过程</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc2 (a <span class="type">INT</span>) </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span>a;</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用存储过程</span></span><br><span class="line"><span class="keyword">CALL</span> proc2(<span class="number">20</span>)</span><br></pre></td></tr></table></figure><h2 id="30-5-删除存储过程"><a href="#30-5-删除存储过程" class="headerlink" title="30.5 删除存储过程"></a>30.5 删除存储过程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> proc1;</span><br></pre></td></tr></table></figure><hr><h1 id="31-mysql函数和存储过程对比"><a href="#31-mysql函数和存储过程对比" class="headerlink" title="31. mysql函数和存储过程对比"></a>31. mysql函数和存储过程对比</h1><ul><li><p>存储过程和函数都是为了提高<strong>程序的运行效率</strong>和<strong>减少网络带宽</strong>而存在的</p></li><li><p>存储过程可以实现相对复杂的功能,而函数针对性比较强</p></li><li><p>存储过程可以返回多个值(无需<code>return</code>关键字),函数只能有一个返回值</p></li><li><p><strong>在实际商业项目中尽量不要使用存储过程和自定义函数</strong></p></li></ul><hr><h1 id="32-mysql中的视图-了解"><a href="#32-mysql中的视图-了解" class="headerlink" title="32. mysql中的视图(了解)"></a>32. mysql中的视图(了解)</h1><p>视图其实就是一个虚拟表,这虚拟表可以存储我们查询的结果,方便我们进行二次查询,提升查询效率;查询的时候就可以像使用表一样用视图;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建视图(View)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myStudentView <span class="keyword">AS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">20</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询视图的数据(可以把视图当成表来使用)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> myStudentView;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除视图</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> myStudentView;</span><br></pre></td></tr></table></figure><p><strong>注意: 视图是依赖表而存在的,如果表被删除了,视图就无效了;</strong></p><hr><h1 id="33-mysql中的触发器-了解"><a href="#33-mysql中的触发器-了解" class="headerlink" title="33. mysql中的触发器(了解)"></a>33. mysql中的触发器(了解)</h1><p>触发器(trigger):监听事件,并触发某操作</p><p>触发器的四要素:</p><ul><li>监视地点(table)</li><li>监视事件(insert&#x2F;update&#x2F;delete)</li><li>触发时机(after&#x2F;before)</li><li>触发事件(insert&#x2F;update&#x2F;delete)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建班级表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> grade (</span><br><span class="line">  id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">  gname <span class="type">VARCHAR</span> (<span class="number">64</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 创建学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">  id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">  nickname <span class="type">VARCHAR</span> (<span class="number">64</span>),</span><br><span class="line">  age TINYINT UNSIGNED,</span><br><span class="line">  g_id TINYINT UNSIGNED,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>需求: 我们删除班级,实现自动删除班级对应的学生 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="comment">-- 触发地点:grade  监听事件: delete  触发时机: before  触发事件:delete</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> `tigger1` BEFORE <span class="keyword">DELETE</span> <span class="keyword">ON</span> `grade` </span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> student; </span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><hr><h1 id="34-mysql中的存储引擎"><a href="#34-mysql中的存储引擎" class="headerlink" title="34. mysql中的存储引擎"></a>34. mysql中的存储引擎</h1><p>mysql可以将数据以不同的技术存储在文件或者(内存)中,这种技术叫存储引擎;</p><p>每种存储引擎都有不同的存储机制,索引技术,表锁定技术,最终应用的场景各不相同,但是现在最主流的mysql的存储引擎用的对多的还是<code>INNODB</code></p><table><thead><tr><th align="center">存储引擎</th><th align="center">MYISAM</th><th align="center">INNODB</th><th align="center">MEMORY</th></tr></thead><tbody><tr><td align="center">存储限制</td><td align="center">256TB</td><td align="center">64TB</td><td align="center">有限制</td></tr><tr><td align="center"><strong>事务安全性</strong></td><td align="center">NO</td><td align="center">&#x3D;&#x3D;YES&#x3D;&#x3D;</td><td align="center">NO</td></tr><tr><td align="center">支持索引</td><td align="center">YES</td><td align="center">&#x3D;&#x3D;YES&#x3D;&#x3D;</td><td align="center">YES</td></tr><tr><td align="center">数据压缩</td><td align="center">YES</td><td align="center">NO</td><td align="center">NO</td></tr><tr><td align="center">是否支持外键</td><td align="center">NO</td><td align="center">&#x3D;&#x3D;YES&#x3D;&#x3D;</td><td align="center">NO</td></tr></tbody></table><blockquote><p>如果没有特殊要求,在互联网项目中,INNODB存储引擎是我们首选;</p></blockquote><hr><h1 id="35-执行mysql的脚本"><a href="#35-执行mysql的脚本" class="headerlink" title="35.  执行mysql的脚本"></a>35.  执行mysql的脚本</h1><ul><li><p>登录mysql之后执行sql脚本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source sqlpath</span><br></pre></td></tr></table></figure></li><li><p>登录mysql时候直接执行sql脚本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="operator">&lt;</span>sqlpath</span><br></pre></td></tr></table></figure></li><li><p><strong>使用可视化工具备份和还原(推荐做法)</strong></p></li></ul><hr><h1 id="36-Mysql管理工具"><a href="#36-Mysql管理工具" class="headerlink" title="36. Mysql管理工具"></a>36. Mysql管理工具</h1><ul><li>Workbench(mysql官方推荐使用的)  免费的 跨平台的 </li><li>Sequel Pro 只在mac端有</li><li>HeidiSQL(免费  开源)</li><li>phpMyAdmin(web应用)</li><li>mysqlfont(免费  轻量级) 只有windows端有,对高分辨率屏支持不好</li><li><strong>Navicat(商业 收费) 跨平台  功能最强大  UI最漂亮</strong>  </li><li><strong>SQLyog(收费  不跨平台)</strong> 对高分辨率屏支持不好</li></ul><hr><h1 id="37-mysql的版本升级"><a href="#37-mysql的版本升级" class="headerlink" title="37. mysql的版本升级"></a>37. mysql的版本升级</h1><p>升级数据库版本之前一定要先备份数据,再执行升级;</p><ul><li>备份数据</li><li>卸载老版本的mysql<ul><li>停止系统的mysql服务</li><li>检查系统服务是否存在如果存在先删除 <code>sc delete mysql</code>,这个命令必须使用管理员用户权限</li><li>删除数据目录</li></ul></li><li>安装新版本的<code>mysql-8.0.22.0</code></li><li>恢复数据(执行前面备份的sql脚本)</li></ul><hr><h1 id="38-mysql中的模糊查询"><a href="#38-mysql中的模糊查询" class="headerlink" title="38. mysql中的模糊查询"></a>38. mysql中的模糊查询</h1><p><code>%</code>: 匹配0个或者多个任意字符</p><p><code>_</code>: 匹配任意一个字符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询昵称中以 &#x27;小&#x27; 开头的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;小%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查询昵称中包含 &#x27;小&#x27; 的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;%小%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>模糊查询的前缀查询效率<code>极低</code>(要进行全表扫描),要慎重使用;</p></li><li><p>一般生产环境会直接禁用<strong>like</strong>模糊查询功能;</p></li></ul><hr><h1 id="39-mysql中的事务"><a href="#39-mysql中的事务" class="headerlink" title="39. mysql中的事务"></a>39. mysql中的事务</h1><h2 id="39-1-mysql事务介绍"><a href="#39-1-mysql事务介绍" class="headerlink" title="39.1 mysql事务介绍"></a>39.1 mysql事务介绍</h2><p>把做完一个业务分成好多单元,整个过程每个单元<strong>全部</strong>处理成功,才算整个的业务处理成功,只要有有任何一个单元处理失败,则认为业务处理失败;</p><p><strong>作用: 保证了数据的完整性</strong></p><hr><h2 id="39-2-事务控制"><a href="#39-2-事务控制" class="headerlink" title="39.2 事务控制"></a>39.2 事务控制</h2><p>整个过程的每一个单元全部处理成功那么事务才会<strong>提交(commit)</strong>,只要其中任何一个单元出现异常,我们则让事务<strong>回滚(rollback)</strong></p><hr><h2 id="39-3-事务的特性"><a href="#39-3-事务的特性" class="headerlink" title="39.3 事务的特性"></a>39.3 事务的特性</h2><p>ACID</p><p>atomicity(原子性): 事务中所有的操作要么全部成功,要么全部失败;</p><p>consistency(一致性):事务执行前后的状态(数据)保持一致</p><p>isolation(隔离性): 多个事务在执行过程中互相不受影响</p><p>durability(持久性):事务一旦被提交,那么对数据库中的数据的改变时永久性的,即使在数据库系统遇到故障的时候,排除故障之后这些数据也不会丢失;</p><p>注意: 事务这个特性其实我们一直在使用,只是我们没有特别的在意这个事,因为mysql默认的事务的提交方式是自动提交的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> &quot;%autocommit%&quot;</span><br></pre></td></tr></table></figure><hr><h2 id="39-4-手动控制事务的提交与回滚"><a href="#39-4-手动控制事务的提交与回滚" class="headerlink" title="39.4 手动控制事务的提交与回滚"></a>39.4 手动控制事务的提交与回滚</h2><p>mysql默认事务的提交方式是自动提交的,但是我们一般使用到事务的时候都会进行手动的控制,也就是要关闭mysql的事务自动提交;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启事务(临时关闭mysql的&quot;事务自动提交&quot;)</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;<span class="comment">-- 或者使用 BEGIN;</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span>(nickname,sex,age)<span class="keyword">VALUES</span>(&quot;小胖1&quot;,<span class="string">&#x27;男&#x27;</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">member</span> <span class="keyword">SET</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启事务(临时关闭mysql的&quot;事务自动提交&quot;)</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;  <span class="comment">-- 或者使用BEGIN;</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span>(nickname,sex,age)<span class="keyword">VALUES</span>(&quot;小胖1&quot;,<span class="string">&#x27;男&#x27;</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">member</span> <span class="keyword">SET</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><h2 id="39-5-事务的隔离性"><a href="#39-5-事务的隔离性" class="headerlink" title="39.5 事务的隔离性"></a>39.5 事务的隔离性</h2><p>隔离性保证了,多个事务在执行过程中互相不受影响;</p><p>mysql中的事务隔离级别有以下几种:</p><ul><li>Read UNCOMMITTED(读未提交)</li><li>READ COMMITTED(读已提交) —-&gt;oracle中事务默认的隔离级别</li><li>REPEATABLE READ(重复读) —&gt;mysql中的事务的隔离级别</li><li>SERIALIZABLE(串行化)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询默认的事务隔离级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@tx</span>_isolation;  <span class="comment">--老版本中的查询方式</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation; <span class="comment">-- 新版本中查询方式</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更改当前会话的隔离级别</span></span><br><span class="line"><span class="keyword">set</span> session transaction isolation level read uncommitted; <span class="comment">-- 设置当前会话隔离级别为读未提交</span></span><br></pre></td></tr></table></figure><hr><h2 id="39-6-事务隔离级别引发的问题"><a href="#39-6-事务隔离级别引发的问题" class="headerlink" title="39.6 事务隔离级别引发的问题"></a>39.6 事务隔离级别引发的问题</h2><blockquote><p>脏读问题</p></blockquote><ul><li><p>脏读:  设置事务的隔离级别为 <code>READ UNCOMMITTED</code>,会读到其他事务没有提交的数据;</p></li><li><p>解决脏读: 设置事务的隔离级别为 <code>READ COMMITTED</code>,既可以解决数据脏读问题</p></li></ul><blockquote><p>不可重复读问题</p></blockquote><ul><li>不可重复读: 在一个事务中,前后两次读到的数据不一致</li><li>解决不可重复读: 使用的<code>REPEATABLE READ</code>隔离级别可以解决;</li></ul><blockquote><p>虚读|幻读问题</p></blockquote><ul><li><p>虚读: 设置为<code>READ UNCOMMITTED ,READ COMMITTED,REPEATABLE READ</code>的事务,有时候可以读取到其他事务新插入的行,这种情况就称为虚读;</p></li><li><p>解决虚读: 把事务的隔离级别设置成 <code>SERIALIZABLE</code>之后就可以解决虚读问题;</p></li></ul><blockquote><p>解决方案: 我们在实际开发过程中一般不会使用两个极端的隔离级别(读未提交,  串行化),我们会使用中间的两个;</p></blockquote><hr><h1 id="40-innodb锁机制"><a href="#40-innodb锁机制" class="headerlink" title="40. innodb锁机制"></a>40. innodb锁机制</h1><h2 id="40-1-innodb锁机制介绍"><a href="#40-1-innodb锁机制介绍" class="headerlink" title="40.1 innodb锁机制介绍"></a>40.1 innodb锁机制介绍</h2><p>从锁的颗粒来说锁分为行锁和表锁;</p><p>在innodb中提供了两种锁机制:</p><ul><li><p>乐观锁:  并不是硬编码的实现,而是通过version版本号来进行实现&#x3D;&#x3D;(innodb中并没有实现乐观锁)&#x3D;&#x3D;</p></li><li><p>悲观锁: 这是innodb存储引擎默认实现的锁机制,这种锁是<strong>表锁</strong>,而悲观锁的实现又分为两种实现:</p><ul><li>共享锁(S锁),读锁<ul><li>在读取的行设置一个共享模式的锁,这个共享锁允许其他的会话读取数据,但是不允许修改,如果其他的会话也需要修改数据,则要等待持有共享锁的会话结束锁的释放,才能修改数据;</li><li>可以在多个会话中加多个共享锁</li><li><strong>添加多个共享锁容易出现互相等待释放的情况,造成死锁问题,所以使用多个共享锁一定要慎重;</strong></li></ul></li><li>排它锁(X锁),写锁<ul><li>排它锁是不允许重复添加的</li><li>排它锁没有死锁问题</li></ul></li></ul><hr></li></ul><h2 id="40-2-显式加锁"><a href="#40-2-显式加锁" class="headerlink" title="40.2 显式加锁"></a>40.2 显式加锁</h2><ul><li>共享锁的添加: <code>lock in share mode</code></li><li>排它锁的添加: <code>for update</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from account lock in share mode;</span><br><span class="line">select * from account for update;</span><br></pre></td></tr></table></figure><hr><h2 id="40-3-mvcc并发系统快照读与当前读"><a href="#40-3-mvcc并发系统快照读与当前读" class="headerlink" title="40.3 mvcc并发系统快照读与当前读"></a>40.3 mvcc并发系统快照读与当前读</h2><p><strong>快照读:</strong> 不加锁的select操作就属于快照读</p><p>当前读: 加锁的操作属于当前读</p><p>当前读读到的是最新的数据,而且在读取的过程中是&#x3D;&#x3D;不允许&#x3D;&#x3D;其他的事务修改数据;</p><hr><h1 id="41-mysql中的执行计划"><a href="#41-mysql中的执行计划" class="headerlink" title="41. mysql中的执行计划"></a>41. mysql中的执行计划</h1><p>mysql执行流程:</p><p>客户端(sql语句)—&gt;mysql-rdbms–&gt;innodb存储引擎–&gt;sql查询优化器(sql语句的优化)—&gt;….</p><p>sql查询优化器会把优化的东西形成一个产物,这个产物就是执行计划;</p><p>我们在实际的开发过程中,一般涉及到mysql的优化都会先查看其执行计划;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> shop;</span><br></pre></td></tr></table></figure><ul><li><p>执行计划看的时候先看执行计划的id,<strong>id越大的先执行</strong>;</p></li><li><p>如果id相同从上往下看</p></li></ul><hr><h1 id="42-mysql中的索引技术-非常重要"><a href="#42-mysql中的索引技术-非常重要" class="headerlink" title="42. mysql中的索引技术(非常重要)"></a>42. mysql中的索引技术(非常重要)</h1><h2 id="42-1-索引技术的介绍"><a href="#42-1-索引技术的介绍" class="headerlink" title="42.1 索引技术的介绍"></a>42.1 索引技术的介绍</h2><ul><li>mysql中的索引技术可以帮助我们快速检索数据</li><li>innodb底层索引技术就是通过B+tree实现的</li><li>索引其实就是我们平常用到的 ‘<code>目录</code>‘</li><li>索引在mysql启动时就会加到内存中,形成B+Tree,在mysql停止的时候会持久化到硬盘;</li></ul><hr><h2 id="42-2-索引的分类"><a href="#42-2-索引的分类" class="headerlink" title="42.2 索引的分类"></a>42.2 索引的分类</h2><ul><li>普通索引</li><li>主键索引</li><li>唯一索引</li><li>全文索引</li></ul><hr><h2 id="42-3-普通索引"><a href="#42-3-普通索引" class="headerlink" title="42.3 普通索引"></a>42.3 普通索引</h2><p>普通索引如果不指定名称,则索引的名称和字段的名称相同;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的第一种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_nickname <span class="keyword">ON</span> account(nickname); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第二种方式(不常用)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> account <span class="keyword">ADD</span> INDEX idx_nickname1(nickname);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第三种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1(nickname <span class="type">VARCHAR</span>(<span class="number">64</span>),age TINYINT UNSIGNED,KEY idx_nickname(nickname));</span><br></pre></td></tr></table></figure><ul><li>建立普通索引的列的数据是可以重复的</li></ul><hr><h2 id="42-4-主键索引"><a href="#42-4-主键索引" class="headerlink" title="42.4 主键索引"></a>42.4 主键索引</h2><p>主键索引如果不指定索引的名称,则主键索引的名称为 <code>PRIMARY</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明为主键的列就是自动添加主键索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1(id <span class="type">INT</span> ,nickname <span class="type">VARCHAR</span>(<span class="number">64</span>),age TINYINT UNSIGNED,<span class="keyword">PRIMARY</span> KEY(id));</span><br></pre></td></tr></table></figure><ul><li><p>主键索引的列的数据非空,唯一的</p></li><li><p>一个表中建议只有一个主键列</p></li></ul><hr><h2 id="42-5-唯一索引"><a href="#42-5-唯一索引" class="headerlink" title="42.5 唯一索引"></a>42.5 唯一索引</h2><p>唯一索引如果不指定名称,则索引的名称和字段的名称相同;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的第一种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX uk_nickname <span class="keyword">ON</span> u1(nickname); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表时创建唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1 (</span><br><span class="line">  id <span class="type">INT</span>,</span><br><span class="line">  nickname <span class="type">VARCHAR</span> (<span class="number">64</span>) ,</span><br><span class="line">  age TINYINT UNSIGNED,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY uk_nickname(nickname) </span><br><span class="line">) ;</span><br></pre></td></tr></table></figure><ul><li>如果一列被约束为<code>UNIQUE</code>,则在这一列默认添加唯一索引</li><li>添加唯一索引的列可以为<code>NULL</code>值,这也是和主键索引,不同的地方</li></ul><hr><h2 id="42-6-全文索引"><a href="#42-6-全文索引" class="headerlink" title="42.6 全文索引"></a>42.6 全文索引</h2><blockquote><p>全文索引,通过建立<code>倒排索引</code>,可以提高数据的检索效率,解决判断字段中 <code>是否包含</code> 的问题;</p></blockquote><p>我们如果使用like关键字会出现很多问题:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 我们已经给nickname字段添加了普通索引</span></span><br><span class="line"><span class="comment">-- 会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> nickname<span class="operator">=</span><span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="comment">-- 会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;小明%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 不会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;%小明%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>不使用到索引我们如果进行大规模数据检索时,效率会大大的降低,所以前面我们说过 <code>我们只在简单业务或者数据量小的时候才考虑使用like关键字</code>;</p><blockquote><p>全文索引注意的地方:</p></blockquote><ul><li><p>mysql5.6以前,只有<code>MYISAM</code>存储引擎支持全文索引</p></li><li><p>在5.6中<code>INNODB</code>存储引擎加入了对全文索引的支持,<strong>但是只支持英文的全文索引,不支持中文的全文索引</strong></p></li><li><p>&#x3D;&#x3D;<strong>在5.7.6中,mysql内置了<code>ngram</code>分词器,用来支持中文;</strong>&#x3D;&#x3D;</p></li></ul><blockquote><p>配置ngram分词的最小长度:      </p></blockquote><p>默认长度为2,当然我们也可以设置成1,但是设置成1的话就会浪费大量的空间,不是很好,<code>mysql建议我们配置为2</code>;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ngram分词器对分词最小长度(也就是说分词器,分词的时候最小也是两个词一分)</span></span><br><span class="line">[mysqld]</span><br><span class="line">ft_min_word_len=2</span><br></pre></td></tr></table></figure><blockquote><p>创建全文索引</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的第一种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX ft_nickname <span class="keyword">ON</span> account(nickname) <span class="keyword">WITH</span> PARSER ngram ; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第二种方式(不常用)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> account <span class="keyword">ADD</span> FULLTEXT INDEX ft_nickname(nickname) <span class="keyword">WITH</span> PARSER ngram;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第三种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1(nickname <span class="type">VARCHAR</span>(<span class="number">64</span>),age TINYINT UNSIGNED,FULLTEXT KEY ft_nickname(nickname) <span class="keyword">WITH</span> PARSER ngram );</span><br></pre></td></tr></table></figure><blockquote><p>使用全文索引</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(nickname) AGAINST(&quot;你觉得华为笔记本合小米手机哪个好&quot;);</span><br></pre></td></tr></table></figure><ul><li><code>match</code>中的字段和创建全文建索引时的字段<strong>必须一致</strong>;</li></ul><blockquote><p>全文索引的检索流程</p></blockquote><p>用户输入词—&gt;sql执行引擎—&gt;<code>ngram</code>分词器对用户输入的词进行分词(配置了最小的分词个数)—&gt;把分词器分的词依次的去倒排索引中去查找,找出相应的记录返回;</p><hr><h2 id="42-7-组合索引"><a href="#42-7-组合索引" class="headerlink" title="42.7 组合索引"></a>42.7 组合索引</h2><p><strong>包含多个字段的索引</strong>称为组合索引;</p><blockquote><p>组合索引包含</p></blockquote><ul><li>组合普通索引</li><li>组合主键索引</li><li>组合唯一索引</li><li>组合全文索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建复合索引时必须指定索引的名称,不能省略</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX mu_title_content <span class="keyword">ON</span> article(title,content,publish_time);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span>; <span class="comment">-- 使用到索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span> <span class="keyword">AND</span> content <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span>; <span class="comment">-- 使用了索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span>  content <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span>; <span class="comment">-- 没有索引</span></span><br></pre></td></tr></table></figure><p><strong>建议多列索引的列不要超过2个列</strong></p><ul><li><p>以上这个复合索引相当于建立了这3个索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(title),(title,content),(title,content,publish_time)</span><br></pre></td></tr></table></figure></li><li><p>多列索引遵循<strong>最左前缀</strong>的原则</p></li><li><p>多列索引在创建的时候,如果其中有字段时<code>TEXT</code>或<code>BLOB</code>类型,就必须指定索引的长度;</p></li></ul><hr><h2 id="42-8-使用索引的优点"><a href="#42-8-使用索引的优点" class="headerlink" title="42.8 使用索引的优点"></a>42.8 使用索引的优点</h2><ul><li>使用主键索引或者唯一索引,可以保证数据库中的表的数据是唯一</li><li><strong>通过建立索引可以大大的提高数据检索的效率,减少表扫描的行数(避免进行全表扫描)</strong></li><li>我们在进行多表连接的时候,可以使用索引加速表之间的连接</li></ul><hr><h2 id="42-9-使用索引的缺点"><a href="#42-9-使用索引的缺点" class="headerlink" title="42.9 使用索引的缺点"></a>42.9 使用索引的缺点</h2><ul><li>在创建索引和维护索引时都需要耗费时间;</li><li>索引文件会占用物理存储空间,除了表的数据占用一部分空间,索引文件也会占用一部分空间;</li><li><strong>设置为<code>text</code>和<code>blob</code>类型的字段强烈不建议添加索引;</strong></li></ul><hr><h1 id="43-mysql中的记录截取"><a href="#43-mysql中的记录截取" class="headerlink" title="43. mysql中的记录截取"></a>43. mysql中的记录截取</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account LIMIT <span class="keyword">start</span>,count;</span><br><span class="line"><span class="keyword">start</span>:开始位置,从<span class="number">0</span>开始</span><br><span class="line">count:截取的记录数量</span><br></pre></td></tr></table></figure><hr><h1 id="44-mysql数据库设计-了解"><a href="#44-mysql数据库设计-了解" class="headerlink" title="44. mysql数据库设计(了解)"></a>44. mysql数据库设计(了解)</h1><ul><li><p><strong>第一设计范式 ：表中的每一列都不能再分(不要出现二维表)</strong></p></li><li><p>第二设计范式：满足第一设计范式，除主键外每一列都必须依靠主键</p></li><li><p>第三设计范式：满足第二设计范式，除主键列外，每一列都不能相互依靠</p></li></ul><p>数据库范式的提出是很早以前的事了,在很早以前硬盘是非常昂贵的,一般都会遵循1,2,3范式,但是随着互联网的发展,硬盘非常便宜,所以我们在现在的商业项目中一般不会遵循2,3范式(用时间换空间),<strong>第一范式会遵循</strong>;</p><hr><h1 id="45-国内大厂的数据库开发规范-参照阿里的开发规范"><a href="#45-国内大厂的数据库开发规范-参照阿里的开发规范" class="headerlink" title="45. 国内大厂的数据库开发规范(参照阿里的开发规范)"></a>45. 国内大厂的数据库开发规范(参照阿里的开发规范)</h1><ol><li><p>库名与应用名称尽量一致</p></li><li><p>表名、字段名必须使用小写字母或数字，禁止出现数字开头,如果一个单词不能表达那就使用下划线分隔;</p></li><li><p>表名不使用复数名词;</p></li><li><p>表的命名最好是加上“业务名称_表的作用”。如，edu_teacher </p></li><li><p>表必备三字段：id, gmt_create, gmt_modified<br>说明：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。（如果使用分库分表集群部署，则id类型为varchar，非自增，业务中使用分布式id生成器）<br>gmt_create, gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被动更新。</p></li><li><p>单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p></li><li><p>表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint （1 表示是，0 表示否）。<br>说明：任何字段如果为非负数，必须是 unsigned。<br>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的 命名方式是为了明确其取值含义与取值范围。<br>正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p></li><li><p>小数类型为 decimal，禁止使用 float 和 double。 说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</p></li><li><p>如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p></li><li><p>varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。</p></li><li><p>唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。<br>说明：uk_ 即 unique key；idx_ 即 index 的简称</p></li><li><p><strong>不得使用外键与级联，一切外键概念必须在应用层解决</strong>。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度</p></li><li><p>慎重使用<code>like</code>进行模糊查询, 通配符如果在前面则不会使用到索引,影响检索效率;</p></li><li><p>如果是简单的搜索业务建议使用mysql5.7中新增的全文索引,不建议直接上solor,elasticsearch这样的检索系统,因为会使得维护成本增加;</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
