<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/20/hello-world/"/>
      <url>/2022/08/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Stream流使用方法</title>
      <link href="/2022/03/12/Stream/"/>
      <url>/2022/03/12/Stream/</url>
      
        <content type="html"><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ol><li>提高代码可读性</li><li>大数据量效率高</li></ol><h3 id="1-1函数式编程思想"><a href="#1-1函数式编程思想" class="headerlink" title="1.1函数式编程思想"></a>1.1函数式编程思想</h3><h4 id="1-1-1概念"><a href="#1-1-1概念" class="headerlink" title="1.1.1概念"></a>1.1.1概念</h4><blockquote><p>函数式编程关注对数据进行什么操作</p><p>面向对象关注用什么对象完成什么事</p></blockquote><h4 id="1-1-2优点"><a href="#1-1-2优点" class="headerlink" title="1.1.2优点"></a>1.1.2优点</h4><blockquote><ol><li>简洁</li><li>易理解</li><li>易于“并发编程”</li></ol></blockquote><h2 id="2-Lambda表达式"><a href="#2-Lambda表达式" class="headerlink" title="2. Lambda表达式"></a>2. Lambda表达式</h2><h3 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h3><blockquote><p>jdk8认可的一种语法，对匿名内部类的写法进行简化。是函数式编程的一个重要体现。</p></blockquote><h3 id="2-2-核心原则"><a href="#2-2-核心原则" class="headerlink" title="2.2 核心原则"></a>2.2 核心原则</h3><blockquote><p>可推导时可省略</p><p>方法名可推导方法名可省略</p><p>参数名可推导参数名可省略</p></blockquote><h3 id="2-3-基本格式"><a href="#2-3-基本格式" class="headerlink" title="2. 3 基本格式"></a>2. 3 基本格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数列表)-&gt;&#123;代码&#125;</span><br></pre></td></tr></table></figure><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>我们在创建线程并启动时可以使用匿名内部类的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>可以使用Lambda的格式对其进行修改。修改后如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h3 id="2-4-省略规则"><a href="#2-4-省略规则" class="headerlink" title="2.4 省略规则"></a>2.4 省略规则</h3><ul><li>参数类型可以省略</li><li>方法体只有一句代码时大括号return和唯一一句代码的分号可以省略</li><li>方法只有一个参数时小括号可以省略</li><li>以上这些规则都记不住也可以省略不记</li></ul><h2 id="3-Stream流"><a href="#3-Stream流" class="headerlink" title="3.Stream流"></a>3.Stream流</h2><h3 id="3-1概述"><a href="#3-1概述" class="headerlink" title="3.1概述"></a>3.1概述</h3><blockquote><p>java8的Stream使用的是函数式编程模式，可以对集合或数组进行链状流式操作。方便我们对集合和数组操作。</p></blockquote><h3 id="3-2入门"><a href="#3-2入门" class="headerlink" title="3.2入门"></a>3.2入门</h3><h4 id="3-2-1创建流"><a href="#3-2-1创建流" class="headerlink" title="3.2.1创建流"></a>3.2.1创建流</h4><blockquote><p><strong>collection</strong>：集合对象.stream();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">Stream</span> <span class="variable">stream</span> <span class="operator">=</span> list.stream;</span><br></pre></td></tr></table></figure><p><strong>数组</strong>：Arrays.stream(“数组”)或者Stream.of</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stream.of()</span></span><br><span class="line"> Integer[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"> Stream&lt;Integer&gt; array1 = Stream.of(array);</span><br><span class="line"> <span class="comment">//Arrays.stream()</span></span><br><span class="line"> Stream&lt;Integer&gt; stream = Arrays.stream(array);</span><br></pre></td></tr></table></figure><p><strong>map</strong>：先转成Collection再.stream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;蜡笔小新&quot;</span>,<span class="number">19</span>);</span><br><span class="line">map.put(<span class="string">&quot;黑子&quot;</span>,<span class="number">17</span>);</span><br><span class="line">map.put(<span class="string">&quot;日向翔阳&quot;</span>,<span class="number">16</span>);</span><br><span class="line">Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; stream = map.entrySet().stream();</span><br></pre></td></tr></table></figure></blockquote><h4 id="3-2-2中间操作"><a href="#3-2-2中间操作" class="headerlink" title="3.2.2中间操作"></a>3.2.2中间操作</h4><blockquote><p><strong>filter</strong>:对流中元素进行过滤,符合条件的留在流中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> author.getAge()&gt;<span class="number">18</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> .filter(author -&gt; author.getAge()&gt;<span class="number">18</span>)    </span><br><span class="line">  </span><br></pre></td></tr></table></figure><p><strong>map</strong>:可以把对流中的元素进行计算或转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;Author&gt; authors1 = getAuthors();</span><br><span class="line">        authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Author, String&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> author.toString();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .forEach(author-&gt;&#123;</span><br><span class="line">                    System.out.println(author.getClass());</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">//lambda表达式写法</span></span><br><span class="line"> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(author -&gt; author.toString()</span><br><span class="line">                )</span><br><span class="line">                .forEach(author-&gt;&#123;</span><br><span class="line">                    System.out.println(author.getClass());</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">/*结果全转成String类型</span></span><br><span class="line"><span class="comment">class java.lang.String</span></span><br><span class="line"><span class="comment">class java.lang.String</span></span><br><span class="line"><span class="comment">class java.lang.String</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>distinct</strong>:去重(根据equals方法),根据需求选择是否重写equals</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">authors.stream()</span><br><span class="line">           .distinct()</span><br><span class="line">           .forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                   System.out.println(author);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><p><strong>sorted</strong>:对流中内容进行排序(如果流中对象实现了<strong>Comparable接口</strong>中的compareto()方法则只需要调用sorted()的无参方法,否则调用有参方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   authors.stream()</span><br><span class="line">               .distinct()</span><br><span class="line">               .sorted(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Author&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Author o1, Author o2)</span> &#123;</span><br><span class="line">                       <span class="keyword">return</span> o2.getAge()-o1.getAge();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)</span><br><span class="line">               .forEach(author-&gt;&#123;</span><br><span class="line">                   System.out.println(author);</span><br><span class="line">               &#125;);</span><br><span class="line"><span class="comment">//lambda表达式写法</span></span><br><span class="line"> authors1.stream()</span><br><span class="line">               .distinct()</span><br><span class="line">               .sorted((author1,author2)-&gt;author1.getAge()-author2.getAge())</span><br><span class="line">               .forEach(author-&gt;&#123;</span><br><span class="line">                   System.out.println(author);</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure><p><strong>limit</strong>:设置流的长度限制(超过的会被舍弃)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">authors1.stream()</span><br><span class="line">               .distinct()</span><br><span class="line">               .sorted(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Author&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Author o1, Author o2)</span> &#123;</span><br><span class="line">                       <span class="keyword">return</span> o2.getAge()-o1.getAge();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)</span><br><span class="line">               .limit(<span class="number">2</span>)</span><br><span class="line">               .forEach(author-&gt;&#123;</span><br><span class="line">                   System.out.println(author);</span><br><span class="line">               &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>skip</strong>:跳过流中前n个元素,返回剩下的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">authors1.stream()</span><br><span class="line">         .distinct()</span><br><span class="line">         .sorted((author1,author2)-&gt;author1.getAge()-author2.getAge())</span><br><span class="line">         .skip(<span class="number">1</span>)</span><br><span class="line">         .forEach(author-&gt;&#123;</span><br><span class="line">             System.out.println(author);</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure><p><strong>flatMap</strong>: flatMap可以把一个对象转换成多个对象作为流中的元素。(map只能把一个对象转换成另一个对象来作为流中的元素。而flatMap可以把一个对象转换成多个对象作为流中的元素。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted((author1,author2)-&gt;author1.getAge()-author2.getAge())</span><br><span class="line">                .flatMap(author-&gt;author.getBooks().stream())</span><br><span class="line">     <span class="comment">//将author中的books(list)也转为流对象并且进行拼接</span></span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted((b1,b2)-&gt; (<span class="type">int</span>) (b1.getId()-b2.getId()))</span><br><span class="line">                .forEach(author-&gt;&#123;</span><br><span class="line">                    System.out.println(author);</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果用map出来的就不是一条一条的book信息而是一个类型值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .flatMap(author -&gt; author.getBooks().stream()</span><br><span class="line">                )</span><br><span class="line">                .flatMap(book-&gt; Arrays.stream(book.getCategory().split(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">                .distinct()</span><br><span class="line">                .forEach(author-&gt;&#123;</span><br><span class="line">                    System.out.println(author);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h4 id="3-2-3终结操作"><a href="#3-2-3终结操作" class="headerlink" title="3.2.3终结操作"></a>3.2.3终结操作</h4><blockquote><p><strong>forEach</strong>:对流中的元素进行遍历操作，我们通过传入的参数去指定对遍历到的元素进行什么具体操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">authors1.stream()</span><br><span class="line">               .distinct()</span><br><span class="line">               .flatMap(author -&gt; author.getBooks().stream()</span><br><span class="line">               )</span><br><span class="line">               .flatMap(book-&gt; Arrays.stream(book.getCategory().split(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">               .distinct()</span><br><span class="line">               .forEach(author-&gt;&#123;</span><br><span class="line">                   System.out.println(author);</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure><p><strong>count</strong>:获取流中元素个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">              .distinct()</span><br><span class="line">              .flatMap(author -&gt; author.getBooks().stream()</span><br><span class="line">              )</span><br><span class="line">              .flatMap(book -&gt; Arrays.stream(book.getCategory().split(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">              .distinct()</span><br><span class="line">              .count();</span><br><span class="line">      System.out.println(count);</span><br></pre></td></tr></table></figure><p><strong>max and min</strong>:最大值和最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大  </span></span><br><span class="line">Optional&lt;Integer&gt; max = authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(book -&gt; book.getScore())</span><br><span class="line">                .max((b1, b2) -&gt; b1 - b2);</span><br><span class="line">        System.out.println(max.get());</span><br><span class="line"><span class="comment">//最小</span></span><br><span class="line">  Optional&lt;Integer&gt; max = authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(book -&gt; book.getScore())</span><br><span class="line">                .min((b1, b2) -&gt; b1 - b2);</span><br></pre></td></tr></table></figure><p><strong>collect</strong>:流转换成collect集合</p><ol><li><p><strong>转成List</strong>:Collectors.toList()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; collect = authors1.stream()</span><br><span class="line">        .distinct()</span><br><span class="line">        .map(author -&gt; author.getName())</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li><li><p><strong>转成Set</strong> : Collectors.toSet()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; collect = authors1.stream()</span><br><span class="line">            .distinct()</span><br><span class="line">            .map(author -&gt; author.getName())</span><br><span class="line">            .collect(Collectors.toSet());</span><br></pre></td></tr></table></figure></li><li><p><strong>转成Map</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; collect = authors1.stream()</span><br><span class="line">    <span class="comment">//一定要去重,因为map键不能重复</span></span><br><span class="line">              .distinct()</span><br><span class="line">              .collect(Collectors.toMap(author -&gt; author.getName(), author -&gt; author.getAge()));</span><br><span class="line">      System.out.println(collect);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h5 id="查找与匹配"><a href="#查找与匹配" class="headerlink" title="查找与匹配"></a>查找与匹配</h5><blockquote><ol><li><p><strong>anyMatch</strong>:可以用来判断是否有任意符合匹配条件的元素，结果为boolean类型。(只要有一个满足就行)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .anyMatch(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> author.getAge() &gt; <span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .anyMatch( author-&gt; author.getAge() &gt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>allMatch</strong>:所有都满足返回true </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">            .distinct()</span><br><span class="line">            .allMatch( author-&gt; author.getAge() &gt; <span class="number">18</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>noneMatch</strong>:所有都不符合返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">              .noneMatch(author -&gt; author.getAge() &gt; <span class="number">100</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>findAny</strong>:获取随机一个元素(不能保证)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        Optional&lt;Author&gt; any = authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .findAny();</span><br><span class="line"><span class="comment">//不建议使用get,有可能是空</span></span><br><span class="line">        System.out.println(any.get());</span><br><span class="line"><span class="comment">//建议使用这个</span></span><br><span class="line">   any.ifPresent(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">               System.out.println(author);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>findFirst</strong>:获取第一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    Optional&lt;Author&gt; any = authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .findFirst();</span><br><span class="line"><span class="comment">//建议使用这个</span></span><br><span class="line">   any.ifPresent(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">               System.out.println(author);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>reduce归并</strong> :对流进行操作,按照你定的规则返回一个结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//底层</span></span><br><span class="line">  <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> identity;</span><br><span class="line"><span class="keyword">for</span> (T element : <span class="built_in">this</span> stream)</span><br><span class="line">result = accumulator.apply(result, element)</span><br><span class="line"><span class="keyword">return</span> result;  </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将所有作者的名称拼接起来</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">reduce</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(author -&gt; author.getName())</span><br><span class="line">                .reduce(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> <span class="title class_">BinaryOperator</span>&lt;String&gt;() &#123;</span><br><span class="line">                  </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String s, String s2)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> s + s2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(reduce);</span><br><span class="line"><span class="comment">//简易版</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">reduce</span> <span class="operator">=</span> authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(author -&gt; author.getName())</span><br><span class="line">                .reduce(<span class="string">&quot;&quot;</span>,(s1,s2)-&gt;s1+s2);</span><br><span class="line">        System.out.println(reduce);</span><br><span class="line"><span class="comment">//reduce中传一个参数的</span></span><br><span class="line">Optional&lt;String&gt; reduce = authors1.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(author -&gt; author.getName())</span><br><span class="line">                .reduce((s1, s2) -&gt; s1 + s2);</span><br><span class="line">       reduce.ifPresent(name-&gt; System.out.println(name));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">源码为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//设定一个tag为foundAny判断是否是首次输入,如果是首次输入将首个输入赋值给result剩下操作与传初始值的操作一样</span></span><br><span class="line">    *     <span class="type">boolean</span> <span class="variable">foundAny</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">     *     <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     *     <span class="keyword">for</span> (T element : <span class="built_in">this</span> stream) &#123;</span><br><span class="line">     *         <span class="keyword">if</span> (!foundAny) &#123;</span><br><span class="line">     *             foundAny = <span class="literal">true</span>;</span><br><span class="line">     *             result = element;</span><br><span class="line">     *         &#125;</span><br><span class="line">     *         <span class="keyword">else</span></span><br><span class="line">     *             result = accumulator.apply(result, element);</span><br><span class="line">     *     &#125;</span><br><span class="line">     *     <span class="keyword">return</span> foundAny ? Optional.of(result) : Optional.empty();</span><br></pre></td></tr></table></figure></li></ol></li></ol></blockquote><h3 id="3-3注意事项"><a href="#3-3注意事项" class="headerlink" title="3.3注意事项"></a>3.3注意事项</h3><blockquote><ol><li><strong>惰性求值</strong>: 流如果没有终结操作,则中间操作不会执行</li><li><strong>流是一次性的</strong>:当一个流对象执行完一次终结操作后,再次使用中间操作或者终结操作会报错</li><li><strong>流不会干扰原数据的</strong>:流对数据进行操作时不会影响原数据,除非你在流中给引用类型赋值.</li></ol></blockquote><h2 id="4-Optional"><a href="#4-Optional" class="headerlink" title="4.Optional"></a>4.Optional</h2><h3 id="4-1概述"><a href="#4-1概述" class="headerlink" title="4.1概述"></a>4.1概述</h3><blockquote><p>代码中经常会出现空指针问题,需要  进行非空判断</p></blockquote><h3 id="4-2使用"><a href="#4-2使用" class="headerlink" title="4.2使用"></a>4.2使用</h3><h4 id="4-2-1创建"><a href="#4-2-1创建" class="headerlink" title="4.2.1创建"></a>4.2.1创建</h4><blockquote><p>Option可以将对象封装进去,然后对封装进去的数据进行操作.Option会提供方法进行非空判断.</p><ol><li><p><strong>静态方法ofNullable</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Author</span> <span class="variable">author</span> <span class="operator">=</span> getAuthor();</span><br><span class="line">        Optional&lt;Author&gt; authorOptional = Optional.ofNullable(author);</span><br></pre></td></tr></table></figure><p>也可以直接将方法的返回值设为Option,这样就可以直接接收到Option对象</p><p>底层代码:<strong>非空时调用of方法</strong>,空时调用<strong>Optional的empty()方法</strong>返回空的Optional对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">ofNullable</span><span class="params">(T value)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> value == <span class="literal">null</span> ? empty() : of(value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>静态方法of</strong>:不会进行非空判断,如果传入为空则报错(不建议使用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Author</span> <span class="variable">author</span> <span class="operator">=</span> getAuthor();</span><br><span class="line">        Optional&lt;Author&gt; authorOptional = Optional.of(author);</span><br><span class="line"><span class="comment">//传入null会报空指针异常</span></span><br><span class="line">authorOptional = Optional.of(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="4-2-2-安全消费-使用"><a href="#4-2-2-安全消费-使用" class="headerlink" title="4.2.2 安全消费(使用)"></a>4.2.2 安全消费(使用)</h4><blockquote><p>获取到Option对象后肯定需要 使用数据<strong>ifPresent</strong>:会判断Option对象是否为空,不为空则使用 .</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    author.ifPresent(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                System.out.println(author);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//简化版</span></span><br><span class="line">     author.ifPresent(au-&gt; System.out.println(au));</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-2-3-获取值"><a href="#4-2-3-获取值" class="headerlink" title="4.2.3 获取值"></a>4.2.3 获取值</h4><blockquote><p>如果我们想获取值自己进行处理可以使用get方法获取，但是不推荐。因为<strong>当Optional内部的数据为空的时候使用get()会出现异常。</strong></p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//一旦为空则会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;No value present&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> Optional&lt;Author&gt;  author= Optional.of(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//Optional中的value为null时会报错</span></span><br><span class="line">        <span class="type">Author</span> <span class="variable">author1</span> <span class="operator">=</span> author.get();</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-2-4-安全获取值"><a href="#4-2-4-安全获取值" class="headerlink" title="4.2.4 安全获取值"></a>4.2.4 安全获取值</h4><blockquote><ol><li><p><strong>orElseGet</strong>:当Option的value为空,返回你传入的内容.</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> &#123;</span><br><span class="line">    <span class="comment">//Option.value是否为空,如果为空返回other.get();other就是你传进来的接口,otherget()就是你传进来的内容</span></span><br><span class="line">     <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other.get();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt;  author= Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line"> <span class="comment">// Optional&lt;Author&gt;  author= Optional.ofNullable(new Author(18L,&quot;亚索&quot;,18,&quot;托儿所&quot;,null));</span></span><br><span class="line">        <span class="type">Author</span> <span class="variable">author1</span> <span class="operator">=</span> author.orElseGet(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Author&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Author <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Author</span>(<span class="number">19L</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">19</span>,<span class="string">&quot;法外狂徒&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(author1);</span><br></pre></td></tr></table></figure></li><li><p><strong>orElseThrow</strong>:当Option的value为空时,抛出定义的异常</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;X <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; T <span class="title function_">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X &#123;</span><br><span class="line">    <span class="comment">//如果value不为空返回value</span></span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//为空抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt;  author= Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line">     <span class="type">Author</span> <span class="variable">value</span> <span class="operator">=</span> author.orElseThrow(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Throwable&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> Throwable <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;value为空&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     System.out.println(value);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="4-2-5-过滤filter"><a href="#4-2-5-过滤filter" class="headerlink" title="4.2.5 过滤filter"></a>4.2.5 过滤filter</h4><blockquote><p>Optional也有一个filter方法,可以对数据进行过滤,如果<strong>原本有数据但是不符合规定,也会返回空value的Optional</strong></p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span> &#123;</span><br><span class="line">    <span class="comment">//做非空判断的,判断你传进来的过滤接口是否为空,如果为空抛出异常</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">public static &lt;T&gt; T requireNonNull(T obj) &#123;</span></span><br><span class="line"><span class="comment">    if (obj == null)</span></span><br><span class="line"><span class="comment">        throw new NullPointerException();</span></span><br><span class="line"><span class="comment">    return obj;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public boolean isPresent() &#123;</span></span><br><span class="line"><span class="comment">    //判断value是否为空,为空直接返回空value</span></span><br><span class="line"><span class="comment">    return value != null;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果接口不为空,value不为空,调用实现接口的test方法看最后返回的内容,如果不满足返回空value的Optional</span></span><br><span class="line">        <span class="keyword">return</span> predicate.test(value) ? <span class="built_in">this</span> : empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; author2 = author.filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> author.getAge() &gt; <span class="number">20</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-2-6-判断isPresen"><a href="#4-2-6-判断isPresen" class="headerlink" title="4.2.6 判断isPresen"></a>4.2.6 判断isPresen</h4><blockquote><p>​<strong>isPresen</strong>:判断value是否为null,为null返回false,不为null返回true</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很简单,判断value是否为null,为null返回false,不为null返回true</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPresent</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">present</span> <span class="operator">=</span> author.isPresent();</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-2-7转换map"><a href="#4-2-7转换map" class="headerlink" title="4.2.7转换map"></a>4.2.7转换map</h4><blockquote><p><strong>map</strong>:数据转换也可以做计算,并且Optional在底层做了ofNullable保证不报错</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends U&gt; mapper)</span> &#123;</span><br><span class="line">    <span class="comment">//判断传入的实现的匿名接口不为null,为null会报错</span></span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="comment">//isPresent()判断value是否为空,不为空则为进else如果为空调用empty()方法返回空的Optional</span></span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; s = author.map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Author, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> author.getName();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><h2 id="5-函数式接口"><a href="#5-函数式接口" class="headerlink" title="5.函数式接口"></a>5.函数式接口</h2><h3 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h3><blockquote><p><strong>接口中只有一个抽象方法</strong>的接口,称为函数式接口</p><p>JDK的函数式接口都有**@FuncationalInterface**注解进行标识.</p></blockquote><h3 id="5-2常见函数式接口"><a href="#5-2常见函数式接口" class="headerlink" title="5.2常见函数式接口"></a>5.2常见函数式接口</h3><blockquote><ol><li><p><strong>Consumer 消费接口</strong></p><p>无返回值,因此一般都是使用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li><li><p>​<strong>Function 计算转换接口</strong></p><p>有R类型的返回值,可以执行运算和转换操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">      </span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; Function&lt;V, R&gt; <span class="title function_">compose</span><span class="params">(Function&lt;? <span class="built_in">super</span> V, ? extends T&gt; before)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="title function_">andThen</span><span class="params">(Function&lt;? <span class="built_in">super</span> R, ? extends V&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Function&lt;T, T&gt; <span class="title function_">identity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>​<strong>Predicate 判断接口</strong></p><p>返回值为boolean类型,判断型接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>**Supplier **</p><p>T类型返回值,可以返回你想要的类型的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="5-3常用默认方法"><a href="#5-3常用默认方法" class="headerlink" title="5.3常用默认方法"></a>5.3常用默认方法</h3><blockquote><p> <strong>用于将Predicate判断接口的拼接</strong><br><strong>and</strong> 相当于&amp;&amp;</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">and</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">      Objects.requireNonNull(other);</span><br><span class="line">    <span class="comment">//返回自己的test的结果与上传进来的and里面的test</span></span><br><span class="line">      <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>or</strong>相当于||</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">or</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">       Objects.requireNonNull(other);</span><br><span class="line">       <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>negate</strong>相当于!</p><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">authors1.stream()</span><br><span class="line">              .distinct()</span><br><span class="line">              .filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                      <span class="keyword">return</span> author.getAge()&gt;<span class="number">10</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;.and(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                      <span class="keyword">return</span> author.getAge()&lt;<span class="number">23</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;))</span><br><span class="line">              .forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                      System.out.println(author);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="6方法引用"><a href="#6方法引用" class="headerlink" title="6方法引用"></a>6方法引用</h2><blockquote><p>当方法体重只有一个方法调用时可以对代码进行进一步简化</p></blockquote><h3 id="6-1推荐用法"><a href="#6-1推荐用法" class="headerlink" title="6.1推荐用法"></a>6.1推荐用法</h3><blockquote><p>​我们在使用lambda时不需要考虑什么时候用方法引用，用哪种方法引用，方法引用的格式是什么。我们只需要在写完lambda方法发现方法体只有一行代码，并且是方法的调用时使用快捷键尝试是否能够转换成方法引用即可。</p><p>​当我们方法引用使用的多了慢慢的也可以直接写出方法引用。</p></blockquote><h3 id="6-2-基本格式"><a href="#6-2-基本格式" class="headerlink" title="6.2 基本格式"></a>6.2 基本格式</h3><p>​类名或者对象名::方法名</p><h3 id="6-3详解"><a href="#6-3详解" class="headerlink" title="6.3详解"></a>6.3详解</h3><h4 id="6-3-1引用静态方法"><a href="#6-3-1引用静态方法" class="headerlink" title="6.3.1引用静态方法"></a>6.3.1引用静态方法</h4><blockquote><h4 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h4><p> 使用前提如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了某个类的静态方法</strong>，并且我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个静态方法中</strong>，这个时候我们就可以引用类的静态方法。</p><p>格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名::方法名</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">        Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line">        </span><br><span class="line">        authorStream.map(author -&gt; author.getAge())</span><br><span class="line">                .map(age-&gt;String.valueOf(age));</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"> List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">        Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line"></span><br><span class="line">        authorStream.map(author -&gt; author.getAge())</span><br><span class="line">                .map(String::valueOf);</span><br></pre></td></tr></table></figure></blockquote><h4 id="6-3-2-引用对象的实例方法"><a href="#6-3-2-引用对象的实例方法" class="headerlink" title="6.3.2 引用对象的实例方法"></a>6.3.2 引用对象的实例方法</h4><blockquote><h5 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名::方法名</span><br></pre></td></tr></table></figure><h5 id="使用前提-1"><a href="#使用前提-1" class="headerlink" title="使用前提"></a>使用前提</h5><p>​如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了某个对象的成员方法</strong>，并且我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个成员方法中</strong>，这个时候我们就可以引用对象的实例方法</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">authorStream.map(author -&gt; author.getName())</span><br><span class="line">        .forEach(name-&gt;sb.append(name));</span><br></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">authorStream.map(author -&gt; author.getName())</span><br><span class="line">        .forEach(sb::append);</span><br></pre></td></tr></table></figure></blockquote><h4 id="6-3-4-引用类的实例方法"><a href="#6-3-4-引用类的实例方法" class="headerlink" title="6.3.4 引用类的实例方法"></a>6.3.4 引用类的实例方法</h4><blockquote><h5 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名::方法名</span><br></pre></td></tr></table></figure><h5 id="使用前提-2"><a href="#使用前提-2" class="headerlink" title="使用前提"></a>使用前提</h5><p>​如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了第一个参数的成员方法</strong>，并且我们把要<strong>重写的抽象方法中剩余的所有的参数都按照顺序传入了这个成员方法中</strong>，这个时候我们就可以引用类的实例方法。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">interface</span> <span class="title class_">UseString</span>&#123;</span><br><span class="line">       String <span class="title function_">use</span><span class="params">(String str,<span class="type">int</span> start,<span class="type">int</span> length)</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">subAuthorName</span><span class="params">(String str, UseString useString)</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> useString.use(str,start,length);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">       subAuthorName(<span class="keyword">new</span> <span class="title class_">UseString</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> String <span class="title function_">use</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> str.substring(start,length);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    subAuthorName(String::substring);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="6-3-5-构造器引用"><a href="#6-3-5-构造器引用" class="headerlink" title="6.3.5 构造器引用"></a>6.3.5 构造器引用</h4><blockquote><p>如果方法体中的一行代码是构造器的话就可以使用构造器引用。</p><h5 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名::<span class="keyword">new</span></span><br></pre></td></tr></table></figure><h5 id="使用前提-3"><a href="#使用前提-3" class="headerlink" title="使用前提"></a>使用前提</h5><p>​如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了某个类的构造方法</strong>，并且我们把<strong>要重写的抽象方法中的所有的参数都按照顺序传入了这个构造方法中</strong>，这个时候我们就可以引用构造器。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">        .map(author -&gt; author.getName())</span><br><span class="line">        .map(name-&gt;<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(name))</span><br><span class="line">        .map(sb-&gt;sb.append(<span class="string">&quot;张三&quot;</span>).toString())</span><br><span class="line">        .forEach(str-&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">        .map(author -&gt; author.getName())</span><br><span class="line">        .map(StringBuilder::<span class="keyword">new</span>)</span><br><span class="line">        .map(sb-&gt;sb.append(<span class="string">&quot;张三&quot;</span>).toString())</span><br><span class="line">        .forEach(str-&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></blockquote><h2 id="7-高级用法"><a href="#7-高级用法" class="headerlink" title="7.高级用法"></a>7.高级用法</h2><h3 id="7-1-基本类型优化"><a href="#7-1-基本类型优化" class="headerlink" title="7.1 基本类型优化"></a>7.1 基本类型优化</h3><blockquote><p>主要还是流对象在操作时会使用包装类,会经常拆箱装箱,导致效率低下.因此可以对这一现象进行优化.</p><p>可以使用map操作进行避免</p><p>mapToInt,mapToLong,mapToDouble,flatMapToInt,flatMapToDouble</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">authors.stream()</span><br><span class="line">               .mapToInt(author -&gt; author.getAge())</span><br><span class="line">               .map(age -&gt; age + <span class="number">10</span>)</span><br><span class="line">               .filter(age-&gt;age&gt;<span class="number">18</span>)</span><br><span class="line">               .map(age-&gt;age+<span class="number">2</span>)</span><br><span class="line">               .forEach(System.out::println)</span><br></pre></td></tr></table></figure></blockquote><h3 id="7-2并行流"><a href="#7-2并行流" class="headerlink" title="7.2并行流"></a>7.2并行流</h3><blockquote><p>大量数据进行操作时,可以使用并行流提高效率,就是多项成.stream对多线程做了优化,可以使用其方法来实现,从而提高效率</p><p><strong>parallel</strong>:可以把串行流转换成并行流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用parallel需要先得到流对象</span></span><br><span class="line">authors1.stream().parallel()</span><br><span class="line">                .peek(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread()+author.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .distinct()</span><br><span class="line">                .filter(author -&gt; author.getAge()&gt;<span class="number">15</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>parallelStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用parallelStream可以直接得到流对象</span></span><br><span class="line"> authors1.parallelStream()</span><br><span class="line">                .peek(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Author&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread()+author.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .distinct()</span><br><span class="line">                .filter(author -&gt; author.getAge()&gt;<span class="number">15</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> Stream流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql</title>
      <link href="/2022/03/12/mysql/"/>
      <url>/2022/03/12/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="in里面的子查询不会使用索引"><a href="#in里面的子查询不会使用索引" class="headerlink" title="in里面的子查询不会使用索引"></a>in里面的子查询不会使用索引</h1><blockquote><p> 生产尽量不用子查询</p></blockquote><h1 id="1-mysql简介"><a href="#1-mysql简介" class="headerlink" title="1. mysql简介"></a>1. mysql简介</h1><ul><li><p>MySQL是一个<strong>关系型数据库管理系统</strong></p></li><li><p>由瑞典MySQL AB 公司开发，属于 <a href="https://baike.baidu.com/item/Oracle">Oracle</a> 旗下产品</p></li><li><p>Mysql是一个<strong>开源免费的</strong>关系型数据库管理系统</p></li><li><p>mysql分为社区办和企业版</p></li><li><p>我们学习的是社区版</p></li></ul><hr><h1 id="2-关系型数据库"><a href="#2-关系型数据库" class="headerlink" title="2. 关系型数据库"></a>2. 关系型数据库</h1><p>建立在关系模型基础上的数据库,借助数学中的集合代数等一些数学概念和方法,处理关系型数据库中的数据</p><hr><h1 id="3-Mysql的安装"><a href="#3-Mysql的安装" class="headerlink" title="3. Mysql的安装"></a>3. Mysql的安装</h1><ul><li>windows的安装</li><li>Linux的安装</li></ul><hr><h1 id="4-Mysql默认的字符集的配置-了解"><a href="#4-Mysql默认的字符集的配置-了解" class="headerlink" title="4. Mysql默认的字符集的配置(了解)"></a>4. Mysql默认的字符集的配置(了解)</h1><p>以windows中的mysql的配置为例:</p><ul><li><p>找到mysql的存放配置文件的地方 <code>C:\ProgramData\MySQL\MySQL Server 5.6/my.ini</code></p></li><li><p>修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>但是: <strong>我们完全不建议这样修改</strong>,因为我们每个项目系统使用的数据库编码完全有可能不一样;</p></blockquote><hr><h1 id="5-启动和停止mysql的服务"><a href="#5-启动和停止mysql的服务" class="headerlink" title="5. 启动和停止mysql的服务"></a>5. 启动和停止mysql的服务</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br><span class="line">net stop mysql</span><br></pre></td></tr></table></figure><p>注意: 如果命令显式不可用代表操作系统的版本不支持(家庭版)</p><hr><h1 id="6-mysql的登录命令"><a href="#6-mysql的登录命令" class="headerlink" title="6. mysql的登录命令"></a>6. mysql的登录命令</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u用户名  <span class="operator">-</span>p密码 </span><br><span class="line"><span class="operator">-</span>h: 默认为localhost</span><br><span class="line"><span class="operator">-</span>P: 默认<span class="number">3306</span></span><br></pre></td></tr></table></figure><hr><h1 id="7-mysql常用的系统命令"><a href="#7-mysql常用的系统命令" class="headerlink" title="7. mysql常用的系统命令"></a>7. mysql常用的系统命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看mysql的版本</span></span><br><span class="line">SELECT VERSION();</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看mysql当前登录的用户</span></span><br><span class="line">select user();</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看mysql的当前日期</span></span><br><span class="line">select now();</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看当前所在的数据库</span></span><br><span class="line">select database();</span><br></pre></td></tr></table></figure><hr><h1 id="8-mysql的语句规范"><a href="#8-mysql的语句规范" class="headerlink" title="8. mysql的语句规范"></a>8. mysql的语句规范</h1><ul><li>关键字和函数名建议大写</li><li>数据库的名称,表的名称,字段的名称建议小写</li><li>数据库 表名 字段名建议加上&#96;&#96;</li><li>sql语句的<strong>定界符</strong>默认以 ; 结尾</li></ul><hr><h1 id="9-数据库的操作SQL类型-了解"><a href="#9-数据库的操作SQL类型-了解" class="headerlink" title="9. 数据库的操作SQL类型(了解)"></a>9. 数据库的操作SQL类型(了解)</h1><ul><li><p>DDL(数据定义语言)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE/VIEW/INDEX</span><br></pre></td></tr></table></figure></li><li><p>DML(数据操纵语言)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 插入：<span class="keyword">INSERT</span></span><br><span class="line"><span class="number">2</span>) 更新：<span class="keyword">UPDATE</span></span><br><span class="line"><span class="number">3</span>) 删除：<span class="keyword">DELETE</span></span><br></pre></td></tr></table></figure></li><li><p>DQL(数据查询语言)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DQL基本结构是由<span class="keyword">SELECT</span>子句，<span class="keyword">FROM</span>子句，<span class="keyword">WHERE</span></span><br><span class="line">子句组成的查询块：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>字段名表<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表或视图名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>查询条件<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><hr></li></ul><h1 id="10-mysql中的概念"><a href="#10-mysql中的概念" class="headerlink" title="10. mysql中的概念"></a>10. mysql中的概念</h1><ul><li>数据库管理系统: 管理数据库的系统</li><li>数据库: 数组库是用来存放和组织<code>表</code>的</li><li>表:是存储数据的<strong>容器</strong>  </li><li>记录: 一行的数据</li><li>属性: 一列属性值</li></ul><hr><h1 id="11-数据库的操作-必会"><a href="#11-数据库的操作-必会" class="headerlink" title="11. 数据库的操作(必会)"></a>11. 数据库的操作(必会)</h1><ul><li>创建数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `db2`; #最简单的方式创建一个数据库</span><br></pre></td></tr></table></figure><p>注意: 数据库的名称可以加 &#96;&#96; ,也可以不加,默认mysql会给你自动加上</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE db2;  #可以省略``</span><br></pre></td></tr></table></figure><ul><li>带判断的创建数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `db1`; #如果不存在db1这个数据库则创建db1数据库,如果存在则不会创建但是也不会报错</span><br></pre></td></tr></table></figure><ul><li>创建数据库并且指定字符集</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#mysql默认的字符集是latin1,latin1不支持中文</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `db3` <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8MB4;</span><br></pre></td></tr></table></figure><ul><li>删除数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#删除数据库,如果数据库不存在则会报错</span><br><span class="line"><span class="keyword">DROP</span> DATABASE `db1`;</span><br><span class="line">#带判断的删除数据库</span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `db1`</span><br></pre></td></tr></table></figure><ul><li>查询数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查询数据库的创建信息</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE `db3`;</span><br><span class="line">#查询当前RDBMS中有哪些数据库</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br><span class="line">#查询当前所在的数据库</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br></pre></td></tr></table></figure><ul><li>进入数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE <span class="string">&#x27;db1&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="12-mysql中的数据类型"><a href="#12-mysql中的数据类型" class="headerlink" title="12. mysql中的数据类型"></a>12. mysql中的数据类型</h1><h2 id="12-1-整形"><a href="#12-1-整形" class="headerlink" title="12.1 整形"></a>12.1 整形</h2><table><thead><tr><th align="center">类型</th><th align="center">范围</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><strong>tinyint</strong></td><td align="center"><strong>1个字节 范围(-128<del>127)||0</del>255(无符号)</strong></td><td align="center"><strong>与java中的byte类型对应</strong></td></tr><tr><td align="center"><strong>smallint</strong></td><td align="center"><strong>2个字节 范围(-32768~32767|| 0 ~ 65535(无符号))</strong></td><td align="center"><strong>与java中的short对应</strong></td></tr><tr><td align="center">mediumint</td><td align="center">3 个字节, -8388608 to 8388607||0 to 16777215(无符号)</td><td align="center"></td></tr><tr><td align="center"><strong>int:Integer</strong></td><td align="center">4 个字节, -2147483648 to 2147483647||0 to 4294967295(无符号)</td><td align="center">与Java中的int类型对应</td></tr><tr><td align="center"><strong>bigint</strong></td><td align="center">8 个字节, -9223372036854775808 to 922337203685477580||0 to 18446744073709551615(无符号)</td><td align="center"><strong>与java中的long对应</strong></td></tr></tbody></table><hr><h2 id="12-2-浮点型"><a href="#12-2-浮点型" class="headerlink" title="12.2 浮点型"></a>12.2 浮点型</h2><table><thead><tr><th align="center">类型</th><th align="center">范围</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">float(m,d)</td><td align="center">单精度浮点型  8位精度(4字节)   m总个数，d小数位</td><td align="center">与java的float对应</td></tr><tr><td align="center">double(m,d)</td><td align="center">双精度浮点型  16位精度(8字节)   m总个数，d小数位</td><td align="center">与java的double对应</td></tr></tbody></table><p>注意: 在实际开发过程中设计数据库时&#x3D;&#x3D;一定一定一定&#x3D;&#x3D;,<strong>涉及到小数的不要使用FLOAT和DOUBLE类型</strong></p><hr><h2 id="12-3-定点"><a href="#12-3-定点" class="headerlink" title="12.3 定点"></a>12.3 定点</h2><p>浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值</p><table><thead><tr><th align="center">类型</th><th align="center">范围</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">decimal(m,d)</td><td align="center">参数m&lt;65 是总个数，d&lt;30且 d&lt;m 是小数位</td><td align="center">表示金额等精确值</td></tr></tbody></table><p>注意: Decimal这个类型如果Insert的数据比我们预设的d的长度大,也会进行四舍五入;  一般存储小数都会使用DECIMAL类型,<strong>不会丢失精度</strong></p><hr><h2 id="12-4-字符串"><a href="#12-4-字符串" class="headerlink" title="12.4 字符串"></a>12.4 字符串</h2><table><thead><tr><th align="center">类型</th><th align="center">范围</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><strong>char(n)</strong></td><td align="center"><strong>固定长度，最多255个</strong></td><td align="center">定长字符串,n 范围(0,255)， 如果不是定长的数据，n&lt;&#x3D;4 时才使用</td></tr><tr><td align="center"><strong>varchar(n)</strong></td><td align="center">最多65532个字符</td><td align="center">变长字符串，65532&gt;n&gt;4, 注意，n 是字符数，而不是字节数</td></tr><tr><td align="center">tinytext</td><td align="center">存储 L+1 个字节，其中 L &lt; 2^8</td><td align="center"></td></tr><tr><td align="center"><strong>text</strong></td><td align="center">存储 L+2 个字节，其中 L &lt; 2^16</td><td align="center">存储文本的</td></tr><tr><td align="center">mediumtext</td><td align="center">存储 L+3 个字节，其中 L &lt; 2^24</td><td align="center"></td></tr><tr><td align="center">longtext</td><td align="center">存储 L+4 个字节，其中 L &lt; 2^32</td><td align="center"></td></tr></tbody></table><h2 id="12-5-Blob二进制类型"><a href="#12-5-Blob二进制类型" class="headerlink" title="12.5 Blob二进制类型"></a>12.5 Blob二进制类型</h2><ul><li><p>BLOB和text存储方式不同，TEXT以文本方式存储，英文存储区分大小写，而Blob是以二进制方式存储，不分大小写。</p></li><li><p>BLOB存储的数据只能整体读出。 </p></li><li><p>TEXT可以指定字符集，BLOB不用指定字符集。</p></li></ul><hr><h2 id="12-6-日期时间类型"><a href="#12-6-日期时间类型" class="headerlink" title="12.6 日期时间类型"></a>12.6 日期时间类型</h2><table><thead><tr><th align="center">类型</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">date</td><td align="center">日期 ‘2008-12-2’</td></tr><tr><td align="center">time</td><td align="center">时间 ‘12:25:36’</td></tr><tr><td align="center">datetime</td><td align="center">日期时间 ‘2008-12-2 22:06:44’</td></tr><tr><td align="center">timestamp</td><td align="center">自动存储记录修改时间</td></tr></tbody></table><hr><h1 id="13-mysql中数据类型属性-约束"><a href="#13-mysql中数据类型属性-约束" class="headerlink" title="13. mysql中数据类型属性(约束)"></a>13. mysql中数据类型属性(约束)</h1><table><thead><tr><th align="center">MySQL关键字</th><th align="center">含义</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">NULL</td><td align="center">数据列可包含NULL值</td><td align="center">mysql默认不指定约束,字段也不添加值,默认为NULL</td></tr><tr><td align="center">NOT NULL</td><td align="center">数据列不允许包含NULL值</td><td align="center">非空约束</td></tr><tr><td align="center">DEFAULT</td><td align="center">默认值</td><td align="center">默认值约束</td></tr><tr><td align="center">PRIMARY KEY</td><td align="center">主键</td><td align="center">主键约束 &#x3D; 非空约束+唯一约束</td></tr><tr><td align="center">AUTO_INCREMENT</td><td align="center">自动递增，适用于整数类型</td><td align="center">自增(一般和<strong>数值类型的主键</strong>联合使用)</td></tr><tr><td align="center">UNSIGNED</td><td align="center">无符号</td><td align="center">保留正数部分</td></tr><tr><td align="center">UNIQUE</td><td align="center">唯一约束</td><td align="center">此字段的值不能重复</td></tr></tbody></table><hr><h1 id="14-表的操作"><a href="#14-表的操作" class="headerlink" title="14. 表的操作"></a>14. 表的操作</h1><p>数据表是数据库的最重要的组成部分之一,是其他对象的基础;</p><h2 id="14-1-查看数据库中的所有的表"><a href="#14-1-查看数据库中的所有的表" class="headerlink" title="14.1 查看数据库中的所有的表"></a>14.1 查看数据库中的所有的表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure><hr><h2 id="14-2-创建表"><a href="#14-2-创建表" class="headerlink" title="14.2 创建表"></a>14.2 创建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  `<span class="keyword">user</span>`(id <span class="type">int</span>,name <span class="type">char</span>(<span class="number">32</span>),age tinyint);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 带条件的创建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`(id <span class="type">int</span>,name <span class="type">char</span>(<span class="number">32</span>),age tinyint);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时指定字符集,如果不指定默认使用的是数据库的字符集</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`(id <span class="type">int</span>,name <span class="type">char</span>(<span class="number">32</span>),age tinyint) <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看表结构</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> `<span class="keyword">user</span>`;</span><br><span class="line"><span class="keyword">DESC</span> `<span class="keyword">user</span>`;  #简写</span><br></pre></td></tr></table></figure><hr><h2 id="14-3-删除表"><a href="#14-3-删除表" class="headerlink" title="14.3 删除表"></a>14.3 删除表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 带判断的删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`;</span><br></pre></td></tr></table></figure><hr><h2 id="14-4-修改表结构"><a href="#14-4-修改表结构" class="headerlink" title="14.4 修改表结构"></a>14.4 修改表结构</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">member</span>` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> sex <span class="type">CHAR</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- COLUMN关键字可以省略</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">member</span>` <span class="keyword">ADD</span>  sex <span class="type">CHAR</span>(<span class="number">1</span>);  </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">member</span> <span class="keyword">DROP</span> <span class="keyword">COLUMN</span>  city;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">member</span> <span class="keyword">DROP</span>  city;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询列</span></span><br><span class="line"><span class="keyword">DESC</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MODIFY只能修改列的属性 不能修改名字</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">member</span> MODIFY age <span class="type">SMALLINT</span>;</span><br><span class="line"><span class="comment">-- CHANGE 既能修改列的名称也能修改列的属性</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">member</span> CHANGE sex sex1 <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="15-记录-数据-的操作"><a href="#15-记录-数据-的操作" class="headerlink" title="15. 记录(数据)的操作"></a>15. 记录(数据)的操作</h1><h2 id="15-1-添加数据"><a href="#15-1-添加数据" class="headerlink" title="15.1 添加数据"></a>15.1 添加数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给表插入一条数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span>(id,nick_name,age,sex) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;小明&#x27;</span>,<span class="number">12</span>,<span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 批量插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span>(id,nick_name,age,sex) <span class="keyword">VALUES</span>(<span class="number">4</span>,&quot;小短腿&quot;,<span class="number">10</span>,<span class="string">&#x27;男&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;大胖&#x27;</span>,<span class="number">30</span>,<span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 骚操作(不指定字段全量插入)----&gt;一般不建议使用全量插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span> <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;小明&#x27;</span>,<span class="number">20</span>);</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span> <span class="keyword">VALUES</span>(<span class="keyword">DEFAULT</span>,<span class="string">&#x27;小明&#x27;</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="15-2-查询数据-简单查询"><a href="#15-2-查询数据-简单查询" class="headerlink" title="15.2 查询数据(简单查询)"></a>15.2 查询数据(简单查询)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 最简单的查询语句</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询指定的字段</span></span><br><span class="line"><span class="keyword">SELECT</span> nick_name <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="15-3-修改数据"><a href="#15-3-修改数据" class="headerlink" title="15.3 修改数据"></a>15.3 修改数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">member</span> <span class="keyword">SET</span> nick_name<span class="operator">=</span><span class="string">&#x27;小胖子&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="15-4-删除数据"><a href="#15-4-删除数据" class="headerlink" title="15.4 删除数据"></a>15.4 删除数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;                               </span><br></pre></td></tr></table></figure><hr><h1 id="16-表和表之间关系"><a href="#16-表和表之间关系" class="headerlink" title="16. 表和表之间关系"></a>16. 表和表之间关系</h1><h2 id="16-1-一对一的关系"><a href="#16-1-一对一的关系" class="headerlink" title="16.1 一对一的关系"></a>16.1 一对一的关系</h2><p>例如: 一个会员表中的一条记录只对应我们身份证表中的一条记录</p><ul><li><p>我们如果设计数据库时出现了一对一的表应该尽量避免;我们只需要给字段多的一方的表<strong>添加额外的字段即可</strong></p></li><li><p>如果我们设计的时候**无法避免(考虑的优化为题)**一对一的设计,我们需要让两个表的主键进行对应</p></li><li><p>如果一个表中的字段的个数超过16个,<strong>强烈建议</strong>使用一对一的表的设计</p></li></ul><hr><h2 id="16-2-一对多的关系"><a href="#16-2-一对多的关系" class="headerlink" title="16.2 一对多的关系"></a>16.2 一对多的关系</h2><p>例如: 一个会员对应多个订单,而一个订单只对应一个会员</p><ul><li>在多的一方的表加一个字段对应一的一方的表中的主键,数据类型要保持一致</li><li>而且我们根据墨菲定律,还可以为其加一个约束条件(<strong>外键(FOREIGN KEY)</strong>)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在表创建之后添加外键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在多的一方的表中添加了一个字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> m_id <span class="type">INT</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加外键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY orders(m_id)  <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY(m_id)  <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 可以指定外键的名称</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> ifbk_orders_mid_merber <span class="keyword">FOREIGN</span> KEY(m_id)  <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表的时候直接添加外键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> orders(</span><br><span class="line">id <span class="type">INT</span>  AUTO_INCREMENT COMMENT <span class="string">&#x27;订单ID&#x27;</span>,</span><br><span class="line">number <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单编号&#x27;</span>,</span><br><span class="line">address <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单的发货地址&#x27;</span>,</span><br><span class="line">m_id <span class="type">INT</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY(m_id) <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id)</span><br><span class="line">) COMMENT <span class="string">&#x27;订单表&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><p>创建一对多的表的时候,首先要创建一方对应的那个表</p></li><li><p>我们为了数据的安全性,我们会把多方中的参照的字段设置为外键,而且类型要和一方中的主键保持一致</p></li><li><p><strong>一般我们在商业项目中,尽量不要使用外键(等会解释)</strong></p></li></ul><hr><h2 id="16-3-多对多的关系"><a href="#16-3-多对多的关系" class="headerlink" title="16.3 多对多的关系"></a>16.3 多对多的关系</h2><p><img src="/upload/image-20201122113930434.png" alt="image-20201122113930434"></p><blockquote><p>思想: 借助一个额外的表,实现多对多关系</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建商品表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> shop(</span><br><span class="line">id <span class="type">INT</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">shop_name <span class="type">VARCHAR</span>(<span class="number">255</span>) COMMENT <span class="string">&#x27;商品名称&#x27;</span>,</span><br><span class="line">stock <span class="type">INT</span> UNSIGNED COMMENT <span class="string">&#x27;商品库存&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">) COMMENT <span class="string">&#x27;商品表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> member_shop;</span><br><span class="line"><span class="comment">-- 创建第三方的表(member_shop)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>  member_shop(</span><br><span class="line">m_id <span class="type">INT</span> COMMENT <span class="string">&#x27;参照member中的id&#x27;</span>,</span><br><span class="line">s_id <span class="type">INT</span> COMMENT <span class="string">&#x27;参照shop中的id&#x27;</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY(m_id) <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id),</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY(s_id) <span class="keyword">REFERENCES</span> shop(id)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT <span class="string">&#x27;第三方的表&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="17-mysql的多字段查询"><a href="#17-mysql的多字段查询" class="headerlink" title="17. mysql的多字段查询"></a>17. mysql的多字段查询</h1><blockquote><p>select * 这种方式不建议使用,我们只查询需要的字段,select * 这种方式对性能有影响</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询多个字段</span></span><br><span class="line"><span class="keyword">SELECT</span> nick_name,age <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询字段并且指定字段的别名</span></span><br><span class="line"><span class="keyword">SELECT</span> nick_name <span class="keyword">AS</span> nname,age <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br><span class="line"><span class="keyword">SELECT</span> nick_name  nname,age <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这才是一条完整的sql语句,我们在实际的开发中不会写这个多的东西,会省略一些东西(库名,字段的别名,表的别名...),sql的执行引擎会帮我们进行词法和语法的补全</span></span><br><span class="line"><span class="keyword">SELECT</span> db3.member.nick_name <span class="keyword">AS</span> nick_name,db3.member.age <span class="keyword">AS</span> age <span class="keyword">FROM</span> db3.member <span class="keyword">AS</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="18-mysql中的排序"><a href="#18-mysql中的排序" class="headerlink" title="18. mysql中的排序"></a>18. mysql中的排序</h1><blockquote><p>ORDER BY col_name ASC|DESC</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不指定任何的排序字段的情况下,默认是按主键的升序排列的</span></span><br><span class="line"><span class="keyword">SELECT</span> id,nick_name,age <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 指定按age来排序(默认是升序)</span></span><br><span class="line"><span class="keyword">SELECT</span> id,nick_name,age <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 指定按age的降序进行排序</span></span><br><span class="line"><span class="keyword">SELECT</span> id,nick_name,age <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span> ;</span><br></pre></td></tr></table></figure><hr><h1 id="19-mysql中的分组查询"><a href="#19-mysql中的分组查询" class="headerlink" title="19. mysql中的分组查询"></a>19. mysql中的分组查询</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    sname <span class="type">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">    age TINYINT UNSIGNED,</span><br><span class="line">    grade <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询grade字段不为NULL的总记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询每个班级及其班级的总人数</span></span><br><span class="line"><span class="keyword">SELECT</span> grade, <span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span>(grade);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- HAING 是对分组后的数据进行条件过滤</span></span><br><span class="line"><span class="keyword">SELECT</span> grade, <span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span>(grade) <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(grade)<span class="operator">&gt;</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询年龄age&gt;25的,班级及其班级里面的人数  WHERE 是对分组之前的数据进行筛选</span></span><br><span class="line"><span class="keyword">SELECT</span> grade,<span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">25</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span>(grade) ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询年龄age&gt;25的,班级人数&gt;1的,班级及其班级里面的人数</span></span><br><span class="line"><span class="keyword">SELECT</span> grade,<span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">25</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span>(grade) <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(grade)<span class="operator">&gt;</span><span class="number">1</span> ;</span><br></pre></td></tr></table></figure><hr><h1 id="20-AND和OR"><a href="#20-AND和OR" class="headerlink" title="20. AND和OR"></a>20. AND和OR</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- and代表两个添加都成立</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span>  <span class="keyword">WHERE</span>  age<span class="operator">&gt;</span><span class="number">25</span> <span class="keyword">AND</span> sex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- or其中只要有一个成立则查出来</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span>  <span class="keyword">WHERE</span>  age<span class="operator">&gt;</span><span class="number">25</span> <span class="keyword">OR</span> sex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span> </span><br></pre></td></tr></table></figure><hr><h1 id="21-IN和NOT-IN"><a href="#21-IN和NOT-IN" class="headerlink" title="21. IN和NOT IN"></a>21. IN和NOT IN</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 多个OR连接并不是很方便</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">OR</span> age<span class="operator">=</span><span class="number">40</span> <span class="keyword">OR</span> age<span class="operator">=</span><span class="number">50</span> <span class="keyword">OR</span> age<span class="operator">=</span><span class="number">45</span> ;</span><br><span class="line"><span class="comment">-- 使用IN进行匹配,达到上面OR的效果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="keyword">IN</span>(<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">45</span>) ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 多个AND连接不方便</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="operator">!=</span> <span class="number">30</span> <span class="keyword">AND</span> age<span class="operator">!=</span><span class="number">40</span> <span class="keyword">AND</span> age<span class="operator">!=</span><span class="number">50</span> <span class="keyword">AND</span> age<span class="operator">!=</span><span class="number">45</span> ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="keyword">NOT</span> <span class="keyword">IN</span>(<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">45</span>) ;</span><br></pre></td></tr></table></figure><hr><h1 id="22-BETWEEN…AND"><a href="#22-BETWEEN…AND" class="headerlink" title="22. BETWEEN…AND"></a>22. BETWEEN…AND</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询指定区域内的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age<span class="operator">&gt;=</span><span class="number">30</span> <span class="keyword">AND</span> age<span class="operator">&lt;=</span><span class="number">40</span></span><br><span class="line"><span class="comment">-- 也可以使用BETWEEN...and来代替</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">30</span> <span class="keyword">AND</span> <span class="number">40</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="23-NOT-BETWEEN…AND"><a href="#23-NOT-BETWEEN…AND" class="headerlink" title="23. NOT BETWEEN…AND"></a>23. NOT BETWEEN…AND</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age<span class="operator">&lt;</span><span class="number">30</span> <span class="keyword">OR</span> age<span class="operator">&gt;</span><span class="number">40</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">30</span> <span class="keyword">AND</span> <span class="number">40</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="24-mysql的子查询"><a href="#24-mysql的子查询" class="headerlink" title="24. mysql的子查询"></a>24. mysql的子查询</h1><p>把一个查询的结果当成另一个查询的条件进行使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询小花购买过的全部的商品</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  member_shop </span><br><span class="line"><span class="keyword">WHERE</span> m_id <span class="operator">=</span> </span><br><span class="line">  (<span class="keyword">SELECT</span> </span><br><span class="line">    id</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    <span class="keyword">member</span> </span><br><span class="line">  <span class="keyword">WHERE</span> nick_name <span class="operator">=</span> <span class="string">&#x27;小花&#x27;</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="25-多表连接查询"><a href="#25-多表连接查询" class="headerlink" title="25. 多表连接查询"></a>25. 多表连接查询</h1><ul><li><p>内连接(显式内连接)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询小花下过的订单(使用多表连接进行查询)  笛卡尔积</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  member.id m_id,</span><br><span class="line">  member.nick_name,</span><br><span class="line">  orders.`address`,</span><br><span class="line">  orders.`create_time` </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">member</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders </span><br><span class="line"><span class="keyword">ON</span> member.id <span class="operator">=</span> orders.m_id </span><br><span class="line"><span class="keyword">WHERE</span> member.nick_name <span class="operator">=</span> <span class="string">&#x27;小花&#x27;</span> ;</span><br></pre></td></tr></table></figure><p>注意:我们使用内连接的时候可以省略<code>INNER JOIN</code>,使<code>逗号</code>在多个表之间进行连接(隐式连接),连接条件也要使用<code>WHERE</code>关键系代替<code>ON</code>关键字</p><p>隐式连接的<strong>语法不太友好</strong>,简单的多个表之间的查询可以使用,但是复杂的sql就不建议使用<code>隐式连接</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询小花下过的订单(使用多表连接进行查询)  笛卡尔积</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  m.id  m_id,</span><br><span class="line">  m.nick_name,</span><br><span class="line">  o.`address`,</span><br><span class="line">  o.`create_time`</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">member</span> m,</span><br><span class="line">  orders o</span><br><span class="line"><span class="keyword">WHERE</span> m.id <span class="operator">=</span> o.m_id </span><br><span class="line">  <span class="keyword">AND</span> m.nick_name <span class="operator">=</span> <span class="string">&#x27;小花&#x27;</span> ;</span><br></pre></td></tr></table></figure></li><li><p>外链接</p><ul><li><p>左外连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  member.id m_id,</span><br><span class="line">  member.nick_name,</span><br><span class="line">  orders.`address`,</span><br><span class="line">  orders.`create_time` </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">member</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders </span><br><span class="line"><span class="keyword">ON</span> member.id <span class="operator">=</span> orders.m_id </span><br><span class="line"><span class="keyword">AND</span> member.nick_name <span class="operator">=</span> <span class="string">&#x27;小花&#x27;</span> ;</span><br></pre></td></tr></table></figure></li><li><p>右外连接(不建议使用,因为可以直接转换为左外链接)</p></li></ul><hr></li></ul><h1 id="26-多表的连接的商业项目使用建议"><a href="#26-多表的连接的商业项目使用建议" class="headerlink" title="26. 多表的连接的商业项目使用建议"></a>26. 多表的连接的商业项目使用建议</h1><ul><li>多表连接时尽量使用<strong>显式连接</strong>,因为显式连接的sql的语义明确</li><li>生产环境建议表的联查个数不要超过3张表(可以是3张)</li><li>如果3张表的联查还不能解决你的问题,那么你就需要在<strong>业务层面解决</strong>或者是<strong>数据库设计缺陷</strong></li><li><strong>在项目中不建议使用外键</strong>,我们完全可以在业务层保证数据的安全性;<ul><li>数据库本质的作用是用来存储数据,而不是进行数据约束的;因为外检会造成我们数据源库迁移的灾难;</li></ul></li></ul><hr><h1 id="27-级联删除与级联更新"><a href="#27-级联删除与级联更新" class="headerlink" title="27. 级联删除与级联更新"></a>27. 级联删除与级联更新</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ON DELETE CASCADE  级联删除</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY(`m_id`) <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ON UPDATE CASCADE   级联更新</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders  <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY (`m_id`) <span class="keyword">REFERENCES</span> <span class="keyword">member</span> (`id`)  <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE;</span><br></pre></td></tr></table></figure><p>当然级联更新和级联删除时可以同时设置的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders  <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY (`m_id`) <span class="keyword">REFERENCES</span> <span class="keyword">member</span> (`id`) </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE  <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE;</span><br></pre></td></tr></table></figure><blockquote><p>也可以借助可视化工具进行修改级联删除和级联更新</p></blockquote><hr><h1 id="28-mysql中的分隔符-定界符"><a href="#28-mysql中的分隔符-定界符" class="headerlink" title="28. mysql中的分隔符(定界符)"></a>28. mysql中的分隔符(定界符)</h1><p>mysql中默认的分割符是 <code>;</code>  也就是说遇到 <code>;</code> 就会立即执行sql</p><p>在<strong>函数 存储过程</strong>这些特性中需要写多个sql组成一个整体,当成整体来执行,而这些特性中,一条一条的语句之间语法规定必须用<code>;</code>来分开</p><p>所以我们要创建函数 存储过程 必须先要把默认的分隔符 <code>;</code>替换成其他的符号;</p><p><strong>在会话中替换默认的分隔符,使用下面语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$  </span><br></pre></td></tr></table></figure><hr><h1 id="29-mysql中的函数"><a href="#29-mysql中的函数" class="headerlink" title="29. mysql中的函数"></a>29. mysql中的函数</h1><p><img src="/upload/image-20201125194255210.png" alt="image-20201125194255210"></p><p>函数:在编程中函数其实就是一段业务的封装</p><p>mysql中的函数: 对多个sql业务的封装,<strong>避免反复的进行词法和语法分析</strong></p><h2 id="29-1-系统函数"><a href="#29-1-系统函数" class="headerlink" title="29.1 系统函数"></a>29.1 系统函数</h2><p>mysql系统帮我们定义的函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询mysql系统当前时间</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW();</span><br><span class="line"><span class="comment">-- 查询当前mysql的版本</span></span><br><span class="line"><span class="keyword">SELECT</span> VERSION();</span><br><span class="line"><span class="comment">-- 查询当前所在的数据库</span></span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"><span class="comment">-- 查询当前登录mysql的用户和主机</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>();</span><br><span class="line"><span class="comment">-- 获取一个字符串对应的md5值</span></span><br><span class="line"><span class="keyword">SELECT</span> MD5(&quot;HELLO&quot;);</span><br></pre></td></tr></table></figure><hr><h2 id="29-2-聚合函数"><a href="#29-2-聚合函数" class="headerlink" title="29.2 聚合函数"></a>29.2 聚合函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 统计某个字段的记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(`age`) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="comment">-- 查询某个字段的最大值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(age) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="comment">-- 查询某个字段的最小值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(age) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="comment">-- 查询某个字段的平均值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(age) <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><hr><h2 id="29-3-自定义函数-了解"><a href="#29-3-自定义函数-了解" class="headerlink" title="29.3 自定义函数(了解)"></a>29.3 自定义函数(了解)</h2><p>我们自己编写的函数</p><ul><li>函数的参数</li><li>返回值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 函数的可以返回任意类型的值,也可以接受任意类型的值为参数</span><br><span class="line">- 函数的返回值和参数没有必然联系的</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名称(参数名称 参数类型) <span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">函数语句 #函数语句只有一条时,可以省略<span class="keyword">BEGIN</span>和<span class="keyword">END</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 首先创建函数之前一定要先修改其定界符,要不然遇到函数中的第一个;就会执行报错</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> MYADD (a <span class="type">INT</span>,b <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span> </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">DECLARE</span> i <span class="type">INT</span> ; <span class="comment">-- 变量的定义</span></span><br><span class="line">  <span class="keyword">SET</span> i <span class="operator">=</span> a<span class="operator">+</span>b ; <span class="comment">-- 给变量设置值</span></span><br><span class="line">  <span class="keyword">RETURN</span> i ;  <span class="comment">-- 返回数据</span></span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> MYADD(<span class="number">12</span>,<span class="number">22</span>); <span class="comment">-- 函数的调用</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建自定义函数</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> STUAGEGTCOUNT (a <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">BIGINT</span> </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">DECLARE</span> c <span class="type">BIGINT</span>;</span><br><span class="line">   <span class="keyword">SET</span> c<span class="operator">=</span>(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span>a);</span><br><span class="line">   <span class="keyword">RETURN</span> c;</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line"><span class="comment">-- 调用自定义函数</span></span><br><span class="line"><span class="keyword">SELECT</span> STUAGEGTCOUNT(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p><strong>函数的调用</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 函数名称(实参列表);</span><br></pre></td></tr></table></figure><p><strong>删除函数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> [IF <span class="keyword">EXISTS</span>]  `MYADD`</span><br></pre></td></tr></table></figure><p><strong>自定义函数可能出现错误:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">错误代码： <span class="number">1418</span></span><br><span class="line">This <span class="keyword">function</span> has <span class="keyword">none</span> <span class="keyword">of</span> <span class="keyword">DETERMINISTIC</span>, <span class="keyword">NO</span> <span class="keyword">SQL</span>, <span class="keyword">or</span> <span class="keyword">READS</span> <span class="keyword">SQL</span> DATA <span class="keyword">in</span> its declaration <span class="keyword">and</span> <span class="type">binary</span> logging <span class="keyword">is</span> enabled (you <span class="operator">*</span>might<span class="operator">*</span> want <span class="keyword">to</span> use the less safe log_bin_trust_function_creators variable)</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;原因:&#x3D;&#x3D;mysql在新版本中添加<strong>函数保护器</strong>,默认如果不进行配置,则无法创建自定义函数,我们需要在当前会话中把函数保护器关掉,尽量不要在全局(系统的配置文件)关闭函数保护器;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看函数保护器的状态</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> &quot;%log_bin_trust_function_creators%&quot;</span><br><span class="line"><span class="comment">-- OFF:不能创建自定义函数(保护器处于开启状态)</span></span><br><span class="line"><span class="comment">-- ON:能创建自定义函数(保护器关闭)</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 允许创建自定义函数</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>经过上面的设置我们就可以正常的创建自定义函数了;</p><hr><h1 id="30-mysql存储过程-了解"><a href="#30-mysql存储过程-了解" class="headerlink" title="30. mysql存储过程(了解)"></a>30. mysql存储过程(了解)</h1><h2 id="30-1-sql语句的执行流程"><a href="#30-1-sql语句的执行流程" class="headerlink" title="30.1 sql语句的执行流程"></a>30.1 sql语句的执行流程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>语句<span class="comment">---&gt;sql执行优化器(编译)---&gt;词法分析,语法分析---&gt;sql优化---&gt;运行sql(读取数据)--&gt;结果</span></span><br></pre></td></tr></table></figure><hr><h2 id="30-2-什么是存储过程"><a href="#30-2-什么是存储过程" class="headerlink" title="30.2 什么是存储过程?"></a>30.2 什么是存储过程?</h2><p> sql语句的编译的集合,以名称来存储,合并为一个单元处理;</p><hr><h2 id="30-3-存储过程的特点"><a href="#30-3-存储过程的特点" class="headerlink" title="30.3 存储过程的特点"></a>30.3 存储过程的特点</h2><ul><li>实现较快的执行速度(避免重复的编译,词法分析,语法分析等操作)</li><li>减少网络流量</li></ul><hr><h2 id="30-4-存储过程的语法"><a href="#30-4-存储过程的语法" class="headerlink" title="30.4 存储过程的语法"></a>30.4 存储过程的语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建存储过程</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc2 (a <span class="type">INT</span>) </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span>a;</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用存储过程</span></span><br><span class="line"><span class="keyword">CALL</span> proc2(<span class="number">20</span>)</span><br></pre></td></tr></table></figure><h2 id="30-5-删除存储过程"><a href="#30-5-删除存储过程" class="headerlink" title="30.5 删除存储过程"></a>30.5 删除存储过程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> proc1;</span><br></pre></td></tr></table></figure><hr><h1 id="31-mysql函数和存储过程对比"><a href="#31-mysql函数和存储过程对比" class="headerlink" title="31. mysql函数和存储过程对比"></a>31. mysql函数和存储过程对比</h1><ul><li><p>存储过程和函数都是为了提高<strong>程序的运行效率</strong>和<strong>减少网络带宽</strong>而存在的</p></li><li><p>存储过程可以实现相对复杂的功能,而函数针对性比较强</p></li><li><p>存储过程可以返回多个值(无需<code>return</code>关键字),函数只能有一个返回值</p></li><li><p><strong>在实际商业项目中尽量不要使用存储过程和自定义函数</strong></p></li></ul><hr><h1 id="32-mysql中的视图-了解"><a href="#32-mysql中的视图-了解" class="headerlink" title="32. mysql中的视图(了解)"></a>32. mysql中的视图(了解)</h1><p>视图其实就是一个虚拟表,这虚拟表可以存储我们查询的结果,方便我们进行二次查询,提升查询效率;查询的时候就可以像使用表一样用视图;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建视图(View)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myStudentView <span class="keyword">AS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">20</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询视图的数据(可以把视图当成表来使用)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> myStudentView;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除视图</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> myStudentView;</span><br></pre></td></tr></table></figure><p><strong>注意: 视图是依赖表而存在的,如果表被删除了,视图就无效了;</strong></p><hr><h1 id="33-mysql中的触发器-了解"><a href="#33-mysql中的触发器-了解" class="headerlink" title="33. mysql中的触发器(了解)"></a>33. mysql中的触发器(了解)</h1><p>触发器(trigger):监听事件,并触发某操作</p><p>触发器的四要素:</p><ul><li>监视地点(table)</li><li>监视事件(insert&#x2F;update&#x2F;delete)</li><li>触发时机(after&#x2F;before)</li><li>触发事件(insert&#x2F;update&#x2F;delete)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建班级表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> grade (</span><br><span class="line">  id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">  gname <span class="type">VARCHAR</span> (<span class="number">64</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 创建学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">  id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">  nickname <span class="type">VARCHAR</span> (<span class="number">64</span>),</span><br><span class="line">  age TINYINT UNSIGNED,</span><br><span class="line">  g_id TINYINT UNSIGNED,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>需求: 我们删除班级,实现自动删除班级对应的学生 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="comment">-- 触发地点:grade  监听事件: delete  触发时机: before  触发事件:delete</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> `tigger1` BEFORE <span class="keyword">DELETE</span> <span class="keyword">ON</span> `grade` </span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> student; </span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><hr><h1 id="34-mysql中的存储引擎"><a href="#34-mysql中的存储引擎" class="headerlink" title="34. mysql中的存储引擎"></a>34. mysql中的存储引擎</h1><p>mysql可以将数据以不同的技术存储在文件或者(内存)中,这种技术叫存储引擎;</p><p>每种存储引擎都有不同的存储机制,索引技术,表锁定技术,最终应用的场景各不相同,但是现在最主流的mysql的存储引擎用的对多的还是<code>INNODB</code></p><table><thead><tr><th align="center">存储引擎</th><th align="center">MYISAM</th><th align="center">INNODB</th><th align="center">MEMORY</th></tr></thead><tbody><tr><td align="center">存储限制</td><td align="center">256TB</td><td align="center">64TB</td><td align="center">有限制</td></tr><tr><td align="center"><strong>事务安全性</strong></td><td align="center">NO</td><td align="center">&#x3D;&#x3D;YES&#x3D;&#x3D;</td><td align="center">NO</td></tr><tr><td align="center">支持索引</td><td align="center">YES</td><td align="center">&#x3D;&#x3D;YES&#x3D;&#x3D;</td><td align="center">YES</td></tr><tr><td align="center">数据压缩</td><td align="center">YES</td><td align="center">NO</td><td align="center">NO</td></tr><tr><td align="center">是否支持外键</td><td align="center">NO</td><td align="center">&#x3D;&#x3D;YES&#x3D;&#x3D;</td><td align="center">NO</td></tr></tbody></table><blockquote><p>如果没有特殊要求,在互联网项目中,INNODB存储引擎是我们首选;</p></blockquote><hr><h1 id="35-执行mysql的脚本"><a href="#35-执行mysql的脚本" class="headerlink" title="35.  执行mysql的脚本"></a>35.  执行mysql的脚本</h1><ul><li><p>登录mysql之后执行sql脚本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source sqlpath</span><br></pre></td></tr></table></figure></li><li><p>登录mysql时候直接执行sql脚本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="operator">&lt;</span>sqlpath</span><br></pre></td></tr></table></figure></li><li><p><strong>使用可视化工具备份和还原(推荐做法)</strong></p></li></ul><hr><h1 id="36-Mysql管理工具"><a href="#36-Mysql管理工具" class="headerlink" title="36. Mysql管理工具"></a>36. Mysql管理工具</h1><ul><li>Workbench(mysql官方推荐使用的)  免费的 跨平台的 </li><li>Sequel Pro 只在mac端有</li><li>HeidiSQL(免费  开源)</li><li>phpMyAdmin(web应用)</li><li>mysqlfont(免费  轻量级) 只有windows端有,对高分辨率屏支持不好</li><li><strong>Navicat(商业 收费) 跨平台  功能最强大  UI最漂亮</strong>  </li><li><strong>SQLyog(收费  不跨平台)</strong> 对高分辨率屏支持不好</li></ul><hr><h1 id="37-mysql的版本升级"><a href="#37-mysql的版本升级" class="headerlink" title="37. mysql的版本升级"></a>37. mysql的版本升级</h1><p>升级数据库版本之前一定要先备份数据,再执行升级;</p><ul><li>备份数据</li><li>卸载老版本的mysql<ul><li>停止系统的mysql服务</li><li>检查系统服务是否存在如果存在先删除 <code>sc delete mysql</code>,这个命令必须使用管理员用户权限</li><li>删除数据目录</li></ul></li><li>安装新版本的<code>mysql-8.0.22.0</code></li><li>恢复数据(执行前面备份的sql脚本)</li></ul><hr><h1 id="38-mysql中的模糊查询"><a href="#38-mysql中的模糊查询" class="headerlink" title="38. mysql中的模糊查询"></a>38. mysql中的模糊查询</h1><p><code>%</code>: 匹配0个或者多个任意字符</p><p><code>_</code>: 匹配任意一个字符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询昵称中以 &#x27;小&#x27; 开头的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;小%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查询昵称中包含 &#x27;小&#x27; 的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;%小%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>模糊查询的前缀查询效率<code>极低</code>(要进行全表扫描),要慎重使用;</p></li><li><p>一般生产环境会直接禁用<strong>like</strong>模糊查询功能;</p></li></ul><hr><h1 id="39-mysql中的事务"><a href="#39-mysql中的事务" class="headerlink" title="39. mysql中的事务"></a>39. mysql中的事务</h1><h2 id="39-1-mysql事务介绍"><a href="#39-1-mysql事务介绍" class="headerlink" title="39.1 mysql事务介绍"></a>39.1 mysql事务介绍</h2><p>把做完一个业务分成好多单元,整个过程每个单元<strong>全部</strong>处理成功,才算整个的业务处理成功,只要有有任何一个单元处理失败,则认为业务处理失败;</p><p><strong>作用: 保证了数据的完整性</strong></p><hr><h2 id="39-2-事务控制"><a href="#39-2-事务控制" class="headerlink" title="39.2 事务控制"></a>39.2 事务控制</h2><p>整个过程的每一个单元全部处理成功那么事务才会<strong>提交(commit)</strong>,只要其中任何一个单元出现异常,我们则让事务<strong>回滚(rollback)</strong></p><hr><h2 id="39-3-事务的特性"><a href="#39-3-事务的特性" class="headerlink" title="39.3 事务的特性"></a>39.3 事务的特性</h2><p>ACID</p><p>atomicity(原子性): 事务中所有的操作要么全部成功,要么全部失败;</p><p>consistency(一致性):事务执行前后的状态(数据)保持一致</p><p>isolation(隔离性): 多个事务在执行过程中互相不受影响</p><p>durability(持久性):事务一旦被提交,那么对数据库中的数据的改变时永久性的,即使在数据库系统遇到故障的时候,排除故障之后这些数据也不会丢失;</p><p>注意: 事务这个特性其实我们一直在使用,只是我们没有特别的在意这个事,因为mysql默认的事务的提交方式是自动提交的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> &quot;%autocommit%&quot;</span><br></pre></td></tr></table></figure><hr><h2 id="39-4-手动控制事务的提交与回滚"><a href="#39-4-手动控制事务的提交与回滚" class="headerlink" title="39.4 手动控制事务的提交与回滚"></a>39.4 手动控制事务的提交与回滚</h2><p>mysql默认事务的提交方式是自动提交的,但是我们一般使用到事务的时候都会进行手动的控制,也就是要关闭mysql的事务自动提交;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启事务(临时关闭mysql的&quot;事务自动提交&quot;)</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;<span class="comment">-- 或者使用 BEGIN;</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span>(nickname,sex,age)<span class="keyword">VALUES</span>(&quot;小胖1&quot;,<span class="string">&#x27;男&#x27;</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">member</span> <span class="keyword">SET</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启事务(临时关闭mysql的&quot;事务自动提交&quot;)</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;  <span class="comment">-- 或者使用BEGIN;</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span>(nickname,sex,age)<span class="keyword">VALUES</span>(&quot;小胖1&quot;,<span class="string">&#x27;男&#x27;</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">member</span> <span class="keyword">SET</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><h2 id="39-5-事务的隔离性"><a href="#39-5-事务的隔离性" class="headerlink" title="39.5 事务的隔离性"></a>39.5 事务的隔离性</h2><p>隔离性保证了,多个事务在执行过程中互相不受影响;</p><p>mysql中的事务隔离级别有以下几种:</p><ul><li>Read UNCOMMITTED(读未提交)</li><li>READ COMMITTED(读已提交) —-&gt;oracle中事务默认的隔离级别</li><li>REPEATABLE READ(重复读) —&gt;mysql中的事务的隔离级别</li><li>SERIALIZABLE(串行化)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询默认的事务隔离级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@tx</span>_isolation;  <span class="comment">--老版本中的查询方式</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation; <span class="comment">-- 新版本中查询方式</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更改当前会话的隔离级别</span></span><br><span class="line"><span class="keyword">set</span> session transaction isolation level read uncommitted; <span class="comment">-- 设置当前会话隔离级别为读未提交</span></span><br></pre></td></tr></table></figure><hr><h2 id="39-6-事务隔离级别引发的问题"><a href="#39-6-事务隔离级别引发的问题" class="headerlink" title="39.6 事务隔离级别引发的问题"></a>39.6 事务隔离级别引发的问题</h2><blockquote><p>脏读问题</p></blockquote><ul><li><p>脏读:  设置事务的隔离级别为 <code>READ UNCOMMITTED</code>,会读到其他事务没有提交的数据;</p></li><li><p>解决脏读: 设置事务的隔离级别为 <code>READ COMMITTED</code>,既可以解决数据脏读问题</p></li></ul><blockquote><p>不可重复读问题</p></blockquote><ul><li>不可重复读: 在一个事务中,前后两次读到的数据不一致</li><li>解决不可重复读: 使用的<code>REPEATABLE READ</code>隔离级别可以解决;</li></ul><blockquote><p>虚读|幻读问题</p></blockquote><ul><li><p>虚读: 设置为<code>READ UNCOMMITTED ,READ COMMITTED,REPEATABLE READ</code>的事务,有时候可以读取到其他事务新插入的行,这种情况就称为虚读;</p></li><li><p>解决虚读: 把事务的隔离级别设置成 <code>SERIALIZABLE</code>之后就可以解决虚读问题;</p></li></ul><blockquote><p>解决方案: 我们在实际开发过程中一般不会使用两个极端的隔离级别(读未提交,  串行化),我们会使用中间的两个;</p></blockquote><hr><h1 id="40-innodb锁机制"><a href="#40-innodb锁机制" class="headerlink" title="40. innodb锁机制"></a>40. innodb锁机制</h1><h2 id="40-1-innodb锁机制介绍"><a href="#40-1-innodb锁机制介绍" class="headerlink" title="40.1 innodb锁机制介绍"></a>40.1 innodb锁机制介绍</h2><p>从锁的颗粒来说锁分为行锁和表锁;</p><p>在innodb中提供了两种锁机制:</p><ul><li><p>乐观锁:  并不是硬编码的实现,而是通过version版本号来进行实现&#x3D;&#x3D;(innodb中并没有实现乐观锁)&#x3D;&#x3D;</p></li><li><p>悲观锁: 这是innodb存储引擎默认实现的锁机制,这种锁是<strong>表锁</strong>,而悲观锁的实现又分为两种实现:</p><ul><li>共享锁(S锁),读锁<ul><li>在读取的行设置一个共享模式的锁,这个共享锁允许其他的会话读取数据,但是不允许修改,如果其他的会话也需要修改数据,则要等待持有共享锁的会话结束锁的释放,才能修改数据;</li><li>可以在多个会话中加多个共享锁</li><li><strong>添加多个共享锁容易出现互相等待释放的情况,造成死锁问题,所以使用多个共享锁一定要慎重;</strong></li></ul></li><li>排它锁(X锁),写锁<ul><li>排它锁是不允许重复添加的</li><li>排它锁没有死锁问题</li></ul></li></ul><hr></li></ul><h2 id="40-2-显式加锁"><a href="#40-2-显式加锁" class="headerlink" title="40.2 显式加锁"></a>40.2 显式加锁</h2><ul><li>共享锁的添加: <code>lock in share mode</code></li><li>排它锁的添加: <code>for update</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from account lock in share mode;</span><br><span class="line">select * from account for update;</span><br></pre></td></tr></table></figure><hr><h2 id="40-3-mvcc并发系统快照读与当前读"><a href="#40-3-mvcc并发系统快照读与当前读" class="headerlink" title="40.3 mvcc并发系统快照读与当前读"></a>40.3 mvcc并发系统快照读与当前读</h2><p><strong>快照读:</strong> 不加锁的select操作就属于快照读</p><p>当前读: 加锁的操作属于当前读</p><p>当前读读到的是最新的数据,而且在读取的过程中是&#x3D;&#x3D;不允许&#x3D;&#x3D;其他的事务修改数据;</p><hr><h1 id="41-mysql中的执行计划"><a href="#41-mysql中的执行计划" class="headerlink" title="41. mysql中的执行计划"></a>41. mysql中的执行计划</h1><p>mysql执行流程:</p><p>客户端(sql语句)—&gt;mysql-rdbms–&gt;innodb存储引擎–&gt;sql查询优化器(sql语句的优化)—&gt;….</p><p>sql查询优化器会把优化的东西形成一个产物,这个产物就是执行计划;</p><p>我们在实际的开发过程中,一般涉及到mysql的优化都会先查看其执行计划;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> shop;</span><br></pre></td></tr></table></figure><ul><li><p>执行计划看的时候先看执行计划的id,<strong>id越大的先执行</strong>;</p></li><li><p>如果id相同从上往下看</p></li></ul><hr><h1 id="42-mysql中的索引技术-非常重要"><a href="#42-mysql中的索引技术-非常重要" class="headerlink" title="42. mysql中的索引技术(非常重要)"></a>42. mysql中的索引技术(非常重要)</h1><h2 id="42-1-索引技术的介绍"><a href="#42-1-索引技术的介绍" class="headerlink" title="42.1 索引技术的介绍"></a>42.1 索引技术的介绍</h2><ul><li>mysql中的索引技术可以帮助我们快速检索数据</li><li>innodb底层索引技术就是通过B+tree实现的</li><li>索引其实就是我们平常用到的 ‘<code>目录</code>‘</li><li>索引在mysql启动时就会加到内存中,形成B+Tree,在mysql停止的时候会持久化到硬盘;</li></ul><hr><h2 id="42-2-索引的分类"><a href="#42-2-索引的分类" class="headerlink" title="42.2 索引的分类"></a>42.2 索引的分类</h2><ul><li>普通索引</li><li>主键索引</li><li>唯一索引</li><li>全文索引</li></ul><hr><h2 id="42-3-普通索引"><a href="#42-3-普通索引" class="headerlink" title="42.3 普通索引"></a>42.3 普通索引</h2><p>普通索引如果不指定名称,则索引的名称和字段的名称相同;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的第一种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_nickname <span class="keyword">ON</span> account(nickname); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第二种方式(不常用)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> account <span class="keyword">ADD</span> INDEX idx_nickname1(nickname);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第三种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1(nickname <span class="type">VARCHAR</span>(<span class="number">64</span>),age TINYINT UNSIGNED,KEY idx_nickname(nickname));</span><br></pre></td></tr></table></figure><ul><li>建立普通索引的列的数据是可以重复的</li></ul><hr><h2 id="42-4-主键索引"><a href="#42-4-主键索引" class="headerlink" title="42.4 主键索引"></a>42.4 主键索引</h2><p>主键索引如果不指定索引的名称,则主键索引的名称为 <code>PRIMARY</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明为主键的列就是自动添加主键索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1(id <span class="type">INT</span> ,nickname <span class="type">VARCHAR</span>(<span class="number">64</span>),age TINYINT UNSIGNED,<span class="keyword">PRIMARY</span> KEY(id));</span><br></pre></td></tr></table></figure><ul><li><p>主键索引的列的数据非空,唯一的</p></li><li><p>一个表中建议只有一个主键列</p></li></ul><hr><h2 id="42-5-唯一索引"><a href="#42-5-唯一索引" class="headerlink" title="42.5 唯一索引"></a>42.5 唯一索引</h2><p>唯一索引如果不指定名称,则索引的名称和字段的名称相同;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的第一种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX uk_nickname <span class="keyword">ON</span> u1(nickname); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表时创建唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1 (</span><br><span class="line">  id <span class="type">INT</span>,</span><br><span class="line">  nickname <span class="type">VARCHAR</span> (<span class="number">64</span>) ,</span><br><span class="line">  age TINYINT UNSIGNED,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY uk_nickname(nickname) </span><br><span class="line">) ;</span><br></pre></td></tr></table></figure><ul><li>如果一列被约束为<code>UNIQUE</code>,则在这一列默认添加唯一索引</li><li>添加唯一索引的列可以为<code>NULL</code>值,这也是和主键索引,不同的地方</li></ul><hr><h2 id="42-6-全文索引"><a href="#42-6-全文索引" class="headerlink" title="42.6 全文索引"></a>42.6 全文索引</h2><blockquote><p>全文索引,通过建立<code>倒排索引</code>,可以提高数据的检索效率,解决判断字段中 <code>是否包含</code> 的问题;</p></blockquote><p>我们如果使用like关键字会出现很多问题:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 我们已经给nickname字段添加了普通索引</span></span><br><span class="line"><span class="comment">-- 会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> nickname<span class="operator">=</span><span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="comment">-- 会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;小明%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 不会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;%小明%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>不使用到索引我们如果进行大规模数据检索时,效率会大大的降低,所以前面我们说过 <code>我们只在简单业务或者数据量小的时候才考虑使用like关键字</code>;</p><blockquote><p>全文索引注意的地方:</p></blockquote><ul><li><p>mysql5.6以前,只有<code>MYISAM</code>存储引擎支持全文索引</p></li><li><p>在5.6中<code>INNODB</code>存储引擎加入了对全文索引的支持,<strong>但是只支持英文的全文索引,不支持中文的全文索引</strong></p></li><li><p>&#x3D;&#x3D;<strong>在5.7.6中,mysql内置了<code>ngram</code>分词器,用来支持中文;</strong>&#x3D;&#x3D;</p></li></ul><blockquote><p>配置ngram分词的最小长度:      </p></blockquote><p>默认长度为2,当然我们也可以设置成1,但是设置成1的话就会浪费大量的空间,不是很好,<code>mysql建议我们配置为2</code>;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ngram分词器对分词最小长度(也就是说分词器,分词的时候最小也是两个词一分)</span></span><br><span class="line">[mysqld]</span><br><span class="line">ft_min_word_len=2</span><br></pre></td></tr></table></figure><blockquote><p>创建全文索引</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的第一种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX ft_nickname <span class="keyword">ON</span> account(nickname) <span class="keyword">WITH</span> PARSER ngram ; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第二种方式(不常用)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> account <span class="keyword">ADD</span> FULLTEXT INDEX ft_nickname(nickname) <span class="keyword">WITH</span> PARSER ngram;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第三种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1(nickname <span class="type">VARCHAR</span>(<span class="number">64</span>),age TINYINT UNSIGNED,FULLTEXT KEY ft_nickname(nickname) <span class="keyword">WITH</span> PARSER ngram );</span><br></pre></td></tr></table></figure><blockquote><p>使用全文索引</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(nickname) AGAINST(&quot;你觉得华为笔记本合小米手机哪个好&quot;);</span><br></pre></td></tr></table></figure><ul><li><code>match</code>中的字段和创建全文建索引时的字段<strong>必须一致</strong>;</li></ul><blockquote><p>全文索引的检索流程</p></blockquote><p>用户输入词—&gt;sql执行引擎—&gt;<code>ngram</code>分词器对用户输入的词进行分词(配置了最小的分词个数)—&gt;把分词器分的词依次的去倒排索引中去查找,找出相应的记录返回;</p><hr><h2 id="42-7-组合索引"><a href="#42-7-组合索引" class="headerlink" title="42.7 组合索引"></a>42.7 组合索引</h2><p><strong>包含多个字段的索引</strong>称为组合索引;</p><blockquote><p>组合索引包含</p></blockquote><ul><li>组合普通索引</li><li>组合主键索引</li><li>组合唯一索引</li><li>组合全文索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建复合索引时必须指定索引的名称,不能省略</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX mu_title_content <span class="keyword">ON</span> article(title,content,publish_time);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span>; <span class="comment">-- 使用到索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span> <span class="keyword">AND</span> content <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span>; <span class="comment">-- 使用了索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span>  content <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span>; <span class="comment">-- 没有索引</span></span><br></pre></td></tr></table></figure><p><strong>建议多列索引的列不要超过2个列</strong></p><ul><li><p>以上这个复合索引相当于建立了这3个索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(title),(title,content),(title,content,publish_time)</span><br></pre></td></tr></table></figure></li><li><p>多列索引遵循<strong>最左前缀</strong>的原则</p></li><li><p>多列索引在创建的时候,如果其中有字段时<code>TEXT</code>或<code>BLOB</code>类型,就必须指定索引的长度;</p></li></ul><hr><h2 id="42-8-使用索引的优点"><a href="#42-8-使用索引的优点" class="headerlink" title="42.8 使用索引的优点"></a>42.8 使用索引的优点</h2><ul><li>使用主键索引或者唯一索引,可以保证数据库中的表的数据是唯一</li><li><strong>通过建立索引可以大大的提高数据检索的效率,减少表扫描的行数(避免进行全表扫描)</strong></li><li>我们在进行多表连接的时候,可以使用索引加速表之间的连接</li></ul><hr><h2 id="42-9-使用索引的缺点"><a href="#42-9-使用索引的缺点" class="headerlink" title="42.9 使用索引的缺点"></a>42.9 使用索引的缺点</h2><ul><li>在创建索引和维护索引时都需要耗费时间;</li><li>索引文件会占用物理存储空间,除了表的数据占用一部分空间,索引文件也会占用一部分空间;</li><li><strong>设置为<code>text</code>和<code>blob</code>类型的字段强烈不建议添加索引;</strong></li></ul><hr><h1 id="43-mysql中的记录截取"><a href="#43-mysql中的记录截取" class="headerlink" title="43. mysql中的记录截取"></a>43. mysql中的记录截取</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account LIMIT <span class="keyword">start</span>,count;</span><br><span class="line"><span class="keyword">start</span>:开始位置,从<span class="number">0</span>开始</span><br><span class="line">count:截取的记录数量</span><br></pre></td></tr></table></figure><hr><h1 id="44-mysql数据库设计-了解"><a href="#44-mysql数据库设计-了解" class="headerlink" title="44. mysql数据库设计(了解)"></a>44. mysql数据库设计(了解)</h1><ul><li><p><strong>第一设计范式 ：表中的每一列都不能再分(不要出现二维表)</strong></p></li><li><p>第二设计范式：满足第一设计范式，除主键外每一列都必须依靠主键</p></li><li><p>第三设计范式：满足第二设计范式，除主键列外，每一列都不能相互依靠</p></li></ul><p>数据库范式的提出是很早以前的事了,在很早以前硬盘是非常昂贵的,一般都会遵循1,2,3范式,但是随着互联网的发展,硬盘非常便宜,所以我们在现在的商业项目中一般不会遵循2,3范式(用时间换空间),<strong>第一范式会遵循</strong>;</p><hr><h1 id="45-国内大厂的数据库开发规范-参照阿里的开发规范"><a href="#45-国内大厂的数据库开发规范-参照阿里的开发规范" class="headerlink" title="45. 国内大厂的数据库开发规范(参照阿里的开发规范)"></a>45. 国内大厂的数据库开发规范(参照阿里的开发规范)</h1><ol><li><p>库名与应用名称尽量一致</p></li><li><p>表名、字段名必须使用小写字母或数字，禁止出现数字开头,如果一个单词不能表达那就使用下划线分隔;</p></li><li><p>表名不使用复数名词;</p></li><li><p>表的命名最好是加上“业务名称_表的作用”。如，edu_teacher </p></li><li><p>表必备三字段：id, gmt_create, gmt_modified<br>说明：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。（如果使用分库分表集群部署，则id类型为varchar，非自增，业务中使用分布式id生成器）<br>gmt_create, gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被动更新。</p></li><li><p>单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p></li><li><p>表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint （1 表示是，0 表示否）。<br>说明：任何字段如果为非负数，必须是 unsigned。<br>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的 命名方式是为了明确其取值含义与取值范围。<br>正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p></li><li><p>小数类型为 decimal，禁止使用 float 和 double。 说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</p></li><li><p>如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p></li><li><p>varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。</p></li><li><p>唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。<br>说明：uk_ 即 unique key；idx_ 即 index 的简称</p></li><li><p><strong>不得使用外键与级联，一切外键概念必须在应用层解决</strong>。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度</p></li><li><p>慎重使用<code>like</code>进行模糊查询, 通配符如果在前面则不会使用到索引,影响检索效率;</p></li><li><p>如果是简单的搜索业务建议使用mysql5.7中新增的全文索引,不建议直接上solor,elasticsearch这样的检索系统,因为会使得维护成本增加;</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
